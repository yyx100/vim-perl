<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre><span class="synStatement">package</span><span class="synType"> Data::Printer::Filter</span>;
<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;
<span class="synStatement">use </span>Clone::PP <span class="synString">qw(clone)</span>;
<span class="synStatement">require</span> Carp;
<span class="synStatement">require</span> Data::Printer;

<span class="synStatement">my</span> <span class="synIdentifier">%_filters_for</span>   = ();
<span class="synStatement">my</span> <span class="synIdentifier">%_extras_for</span>    = ();

<span class="synKeyword">sub </span><span class="synFunction">import </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$caller</span> = <span class="synStatement">caller</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$id</span> = Data::Printer::_object_id( \<span class="synIdentifier">$caller</span> );

    <span class="synStatement">my</span> <span class="synIdentifier">%properties</span> = ();

    <span class="synStatement">my</span> <span class="synIdentifier">$filter</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$type</span>, <span class="synIdentifier">$code</span>, <span class="synIdentifier">$extra</span>) = <span class="synIdentifier">@_</span>;

        Carp::croak( <span class="synString">&quot;syntax: filter 'Class', sub { ... }&quot;</span> )
          <span class="synConditional">unless</span> <span class="synIdentifier">$type</span> <span class="synOperator">and</span> <span class="synIdentifier">$code</span> <span class="synOperator">and</span> <span class="synOperator">ref</span> <span class="synIdentifier">$code</span> <span class="synOperator">eq</span> <span class="synString">'CODE'</span>;

        <span class="synConditional">if</span> (<span class="synIdentifier">$extra</span>) {
            Carp::croak( <span class="synString">'extra filter field must be a hashref'</span> )
                <span class="synConditional">unless</span> <span class="synOperator">ref</span> <span class="synIdentifier">$extra</span> <span class="synOperator">and</span> <span class="synOperator">ref</span> <span class="synIdentifier">$extra</span> <span class="synOperator">eq</span> <span class="synString">'HASH'</span>;

            <span class="synIdentifier">$_extras_for{$id}{$type}</span> = <span class="synIdentifier">$extra</span>;
        }
        <span class="synConditional">else</span> {
            <span class="synIdentifier">$_extras_for{$id}{$type}</span> = {};
        }

        <span class="synStatement">unshift</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$_filters_for{$id}{$type}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>, <span class="synKeyword">sub </span>{
            <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;

            <span class="synComment"># send our closured %properties var instead</span>
            <span class="synComment"># so newline(), indent(), etc can work it</span>
            <span class="synIdentifier">%properties</span> = <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> clone </span><span class="synIdentifier">$p</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>;
            <span class="synStatement">delete</span> <span class="synIdentifier">$properties{</span><span class="synString">filters</span><span class="synIdentifier">}</span>; <span class="synComment"># no need to rework filters</span>
            <span class="synIdentifier">$code</span>-&gt;(<span class="synIdentifier">$item</span>, \<span class="synIdentifier">%properties</span>);
        };
    };

    <span class="synStatement">my</span> <span class="synIdentifier">$filters</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">return</span> <span class="synIdentifier">$_filters_for{$id}</span>;
    };

    <span class="synStatement">my</span> <span class="synIdentifier">$extras</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">return</span> <span class="synIdentifier">$_extras_for{$id}</span>;
    };

    <span class="synStatement">my</span> <span class="synIdentifier">$newline</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">return</span> <span class="synIdentifier">${$properties{</span><span class="synString">_linebreak</span><span class="synIdentifier">}}</span> . (<span class="synString">' '</span> x <span class="synIdentifier">$properties{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>);
    };

    <span class="synStatement">my</span> <span class="synIdentifier">$indent</span> = <span class="synKeyword">sub </span>{
        <span class="synIdentifier">$properties{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> += <span class="synIdentifier">$properties{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$properties{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>++;
        <span class="synStatement">return</span>;
    };

    <span class="synStatement">my</span> <span class="synIdentifier">$outdent</span> = <span class="synKeyword">sub </span>{
        <span class="synIdentifier">$properties{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> -= <span class="synIdentifier">$properties{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$properties{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>--;
        <span class="synStatement">return</span>;
    };

    <span class="synStatement">my</span> <span class="synIdentifier">$imported</span> = <span class="synKeyword">sub </span><span class="synType">(\[@$%&amp;];%) </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
        <span class="synStatement">return</span> Data::Printer::p( <span class="synIdentifier">$item</span>, <span class="synIdentifier">%properties</span> );
    };

    {
        <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;
        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:filter&quot;</span><span class="synIdentifier">}</span>  = <span class="synIdentifier">$filter</span>;
        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:indent&quot;</span><span class="synIdentifier">}</span>  = <span class="synIdentifier">$indent</span>;
        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:outdent&quot;</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$outdent</span>;
        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:newline&quot;</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$newline</span>;

        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:p&quot;</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$imported</span>;

        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:_filter_list&quot;</span><span class="synIdentifier">}</span>   = <span class="synIdentifier">$filters</span>;
        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:_extra_options&quot;</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$extras</span>;
    }
};


<span class="synNumber">1</span>;
<span class="synComment">__END__</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Data::Printer::Filter - Create powerful stand-alone filters for Data::Printer</span>

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synperlPOD">Create your filter module:</span>

<span class="synPreProc">  package Data::Printer::Filter::MyFilter;</span>
<span class="synPreProc">  use strict;</span>
<span class="synPreProc">  use warnings;</span>

<span class="synPreProc">  use Data::Printer::Filter;</span>

<span class="synPreProc">  # type filter</span>
<span class="synPreProc">  filter 'SCALAR', sub {</span>
<span class="synPreProc">      my ($ref, $properties) = @_;</span>
<span class="synPreProc">      my $val = $$ref;</span>
<span class="synPreProc">      </span>
<span class="synPreProc">      if ($val &gt; 100) {</span>
<span class="synPreProc">          return 'too big!!';</span>
<span class="synPreProc">      }</span>
<span class="synPreProc">      else {</span>
<span class="synPreProc">          return $val;</span>
<span class="synPreProc">      }</span>
<span class="synPreProc">  };</span>

<span class="synPreProc">  # you can also filter objects of any class</span>
<span class="synPreProc">  filter 'Some::Class', sub {</span>
<span class="synPreProc">      my ($object, $properties) = @_;</span>

<span class="synPreProc">      return $ref-&gt;some_method;   # or whatever</span>

<span class="synPreProc">      # see 'HELPER FUNCTIONS' below for</span>
<span class="synPreProc">      # customization options, including</span>
<span class="synPreProc">      # proper indentation.</span>
<span class="synPreProc">  };</span>

<span class="synPreProc">  1;</span>


<span class="synperlPOD">Later, in your main code:</span>

<span class="synPreProc">  use Data::Printer {</span>
<span class="synPreProc">      filters =&gt; {</span>
<span class="synPreProc">          -external =&gt; [ 'MyFilter', 'OtherFilter' ],</span>

<span class="synPreProc">          # you can still add regular (inline) filters</span>
<span class="synPreProc">          SCALAR =&gt; sub {</span>
<span class="synPreProc">              ...</span>
<span class="synPreProc">          }</span>
<span class="synPreProc">      },</span>
<span class="synPreProc">  };</span>



<span class="synStatement">=head1</span><span class="synString"> WARNING - ALPHA CODE (VERY LOOSE API)</span>

<span class="synperlPOD">We are still experimenting with the standalone filter syntax, so</span>
<span class="synIdentifier">B&lt;&lt; filters written like so may break in the future without any warning! &gt;&gt;</span>

<span class="synIdentifier">B&lt;&lt; If you care, or have any suggestions &gt;&gt;</span><span class="synperlPOD">, please drop me a line via RT, email,</span>
<span class="synperlPOD">or find me ('garu') on irc.perl.org.</span>

<span class="synperlPOD">You have been warned.</span>


<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

<span class="synIdentifier">L&lt;Data::Printer&gt;</span><span class="synperlPOD"> lets you add custom filters to display data structures and</span>
<span class="synperlPOD">objects, by either specifying them during &quot;use&quot;, in the </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span>
<span class="synperlPOD">configuration file, or even in runtime customizations.</span>

<span class="synperlPOD">But there are times when you may want to group similar filters, or make</span>
<span class="synperlPOD">them standalone in order to be easily reutilized in other environments and</span>
<span class="synperlPOD">applications, or even upload them to CPAN so other people can benefit from</span>
<span class="synperlPOD">a cleaner - and clearer - object/structure dump.</span>

<span class="synperlPOD">This is where </span><span class="synIdentifier">C&lt;Data::Printer::Filter&gt;</span><span class="synperlPOD"> comes in. It </span><span class="synIdentifier">B&lt;exports&gt;</span><span class="synperlPOD"> into your</span>
<span class="synperlPOD">package's namespace the </span><span class="synIdentifier">L&lt;/filter&gt;</span><span class="synperlPOD"> function, along with some helpers to</span>
<span class="synperlPOD">create custom filter packages.</span>

<span class="synIdentifier">L&lt;Data::Printer&gt;</span><span class="synperlPOD"> recognizes all filters in the </span><span class="synIdentifier">C&lt;Data::Printer::Filter::*&gt;</span>
<span class="synperlPOD">namespace. You can load them by specifying them in the '-external' filter</span>
<span class="synperlPOD">list (note the dash, to avoid clashing with a potential class or pragma</span>
<span class="synperlPOD">labelled 'external'):</span>

<span class="synPreProc">  use Data::Printer {</span>
<span class="synPreProc">      filters =&gt; {</span>
<span class="synPreProc">          -external =&gt; 'MyFilter',</span>
<span class="synPreProc">      },</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">This will load all filters defined by the </span><span class="synIdentifier">C&lt;Data::Printer::Filter::MyFilter&gt;</span>
<span class="synperlPOD">module.</span>

<span class="synperlPOD">If there are more than one filter, use an array reference instead:</span>

<span class="synPreProc">  -external =&gt; [ 'MyFilter', 'MyOtherFilter' ]</span>

<span class="synperlPOD">B&lt;&lt; IMPORTANT: THIS WAY OF LOADING EXTERNAL PLUGINS IS EXPERIMENTAL AND</span>
<span class="synperlPOD">SUBJECT TO SUDDEN CHANGE! IF YOU CARE, AND/OR HAVE IDEAS ON A BETTER API,</span>
<span class="synperlPOD">PLEASE LET US KNOW &gt;&gt;</span>

<span class="synStatement">=head1</span><span class="synString"> HELPER FUNCTIONS</span>

<span class="synStatement">=head2</span><span class="synString"> filter TYPE, sub { ... };</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;filter&gt;</span><span class="synperlPOD"> function creates a new filter for </span><span class="synIdentifier">I&lt;TYPE&gt;</span><span class="synperlPOD">, using</span>
<span class="synperlPOD">the given subref. The subref receives two arguments: the item</span>
<span class="synperlPOD">itself - be it an object or a reference to a standard Perl type -</span>
<span class="synperlPOD">and the properties in effect (so you can inspect for certain</span>
<span class="synperlPOD">options, etc). The subroutine is expected to return a string</span>
<span class="synperlPOD">containing whatever it wants </span><span class="synIdentifier">C&lt;Data::Printer&gt;</span><span class="synperlPOD"> to display on screen.</span>

<span class="synStatement">=head2</span><span class="synString"> p()</span>

<span class="synperlPOD">This is the same as </span><span class="synIdentifier">C&lt;Data::Printer&gt;</span><span class="synperlPOD">'s </span><span class="synIdentifier">p()</span><span class="synperlPOD">, only you can't rename it.</span>
<span class="synperlPOD">You can use this to throw some data structures back at </span><span class="synIdentifier">C&lt;Data::Printer&gt;</span>
<span class="synperlPOD">and use the results in your own return string - like when manipulating</span>
<span class="synperlPOD">hashes or arrays.</span>

<span class="synStatement">=head2</span><span class="synString"> newline()</span>

<span class="synperlPOD">This helper returns a string using the linebreak as specified by the</span>
<span class="synperlPOD">caller's settings. For instance, it provides the proper indentation</span>
<span class="synperlPOD">level of spaces for you and considers the </span><span class="synIdentifier">C&lt;multiline&gt;</span><span class="synperlPOD"> option to</span>
<span class="synperlPOD">avoid line breakage.</span>

<span class="synperlPOD">In other words, if you do this:</span>

<span class="synPreProc">   filter ARRAY =&gt; {</span>
<span class="synPreProc">       my ($ref, $p) = @_;</span>
<span class="synPreProc">       my $string = &quot;Hey!! I got this array:&quot;;</span>

<span class="synPreProc">       foreach my $val (@$ref) {</span>
<span class="synPreProc">           $string .= newline . p($val);</span>
<span class="synPreProc">       }</span>

<span class="synPreProc">       return $string;</span>
<span class="synPreProc">   };</span>

<span class="synperlPOD">... your </span><span class="synIdentifier">C&lt;p($val)&gt;</span><span class="synperlPOD"> returns will be properly indented, vertically aligned</span>
<span class="synperlPOD">to your level of the data structure, while simply using &quot;\n&quot; would just</span>
<span class="synperlPOD">make things messy if your structure has more than one level of depth.</span>

<span class="synStatement">=head2</span><span class="synString"> indent()</span>

<span class="synStatement">=head2</span><span class="synString"> outdent()</span>

<span class="synperlPOD">These two helpers let you increase/decrease the indentation level of</span>
<span class="synperlPOD">your data display, for </span><span class="synIdentifier">C&lt;newline()&gt;</span><span class="synperlPOD"> and nested </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> calls inside your filters.</span>

<span class="synperlPOD">For example, the filter defined in the </span><span class="synIdentifier">C&lt;newline&gt;</span><span class="synperlPOD"> explanation above would</span>
<span class="synperlPOD">show the values on the same (vertically aligned) level as the &quot;I got this array&quot;</span>
<span class="synperlPOD">message. If you wanted your array to be one level further deep, you could use</span>
<span class="synperlPOD">this instead:</span>

<span class="synPreProc">  filter ARRAY =&gt; {</span>
<span class="synPreProc">      my ($ref, $p) = @_;</span>
<span class="synPreProc">      my $string = &quot;Hey!! I got this array:&quot;;</span>

<span class="synPreProc">      indent;</span>
<span class="synPreProc">      foreach my $val (@$ref) {</span>
<span class="synPreProc">          $string .= newline . p($val);</span>
<span class="synPreProc">      }</span>
<span class="synPreProc">      outdent;</span>

<span class="synPreProc">      return $string;</span>
<span class="synPreProc">  };</span>


<span class="synStatement">=head1</span><span class="synString"> COLORIZATION</span>

<span class="synperlPOD">You can use </span><span class="synIdentifier">L&lt;Term::ANSIColor&gt;</span><span class="synperlPOD">'s </span><span class="synIdentifier">C&lt;colored()&gt;</span><span class="synperlPOD">' for string</span>
<span class="synperlPOD">colorization. Data::Printer will automatically enable/disable</span>
<span class="synperlPOD">colors for you.</span>

<span class="synStatement">=head1</span><span class="synString"> EXISTING FILTERS</span>

<span class="synperlPOD">This is meant to provide a complete list of standalone filters for</span>
<span class="synperlPOD">Data::Printer available on CPAN. If you write one, please put it under</span>
<span class="synperlPOD">the </span><span class="synIdentifier">C&lt;Data::Printer::Filter::*&gt;</span><span class="synperlPOD"> namespace, and drop me a line so I can</span>
<span class="synperlPOD">add it to this list!</span>

<span class="synStatement">=head2</span><span class="synString"> Databases</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::DB&gt;</span><span class="synperlPOD"> provides filters for Database objects. So</span>
<span class="synperlPOD">far only DBI is covered, but more to come!</span>

<span class="synStatement">=head2</span><span class="synString"> Dates &amp; Times</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::DateTime&gt;</span><span class="synperlPOD"> pretty-prints several date</span>
<span class="synperlPOD">and time objects (not just DateTime) for you on the fly, including</span>
<span class="synperlPOD">duration/delta objects!</span>

<span class="synStatement">=head2</span><span class="synString"> Digest</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::Digest&gt;</span><span class="synperlPOD"> displays a string containing the</span>
<span class="synperlPOD">hash of the actual message digest instead of the object. Works on</span>
<span class="synIdentifier">C&lt;Digest::MD5&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;Digest::SHA&gt;</span><span class="synperlPOD">, any digest class that inherits from</span>
<span class="synIdentifier">C&lt;Digest::base&gt;</span><span class="synperlPOD"> and some others that implement their own thing!</span>

<span class="synStatement">=head2</span><span class="synString"> ClassicRegex</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::ClassicRegex&gt;</span><span class="synperlPOD"> changes the way Data::Printer</span>
<span class="synperlPOD">dumps regular expressions, doing it the classic </span><span class="synIdentifier">C&lt;qr//&gt;</span><span class="synperlPOD"> way that got</span>
<span class="synperlPOD">popular in </span><span class="synIdentifier">C&lt;Data::Dumper&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head2</span><span class="synString"> URI</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::URI&gt;</span><span class="synperlPOD"> pretty-prints </span><span class="synIdentifier">L&lt;URI&gt;</span><span class="synperlPOD"> objects, displaying</span>
<span class="synperlPOD">the URI as a string instead of dumping the object.</span>

<span class="synStatement">=head2</span><span class="synString"> JSON</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::JSON&gt;</span><span class="synperlPOD"> lets you see your JSON structures</span>
<span class="synperlPOD">replacing boolean objects with simple </span><span class="synIdentifier">C&lt;true/false&gt;</span><span class="synperlPOD"> strings!</span>

<span class="synStatement">=head2</span><span class="synString"> URIs</span>

<span class="synIdentifier">L&lt;Data::Printer::Filter::URI&gt;</span><span class="synperlPOD"> filters through several </span><span class="synIdentifier">L&lt;URI&gt;</span><span class="synperlPOD"> manipulation</span>
<span class="synperlPOD">classes and displays the URI as a colored string. A very nice addition</span>
<span class="synperlPOD">by Stanislaw Pusep (SYP).</span>

<span class="synStatement">=head1</span><span class="synString"> USING MORE THAN ONE FILTER FOR THE SAME TYPE/CLASS</span>

<span class="synperlPOD">As of version 0.13, standalone filters let you stack together</span>
<span class="synperlPOD">filters for the same type or class. Filters of the same type are</span>
<span class="synperlPOD">called in order, until one of them returns a string. This lets</span>
<span class="synperlPOD">you have several filters inspecting the same given value until</span>
<span class="synperlPOD">one of them decides to actually treat it somehow.</span>

<span class="synperlPOD">If your filter catched a value and you don't want to treat it,</span>
<span class="synperlPOD">simply return and the next filter will be called. If there are no</span>
<span class="synperlPOD">other filters for that particular class or type available, the</span>
<span class="synperlPOD">standard Data::Printer calls will be used.</span>

<span class="synperlPOD">For example:</span>

<span class="synPreProc">  filter SCALAR =&gt; sub {</span>
<span class="synPreProc">      my ($ref, $properties) = @_;</span>
<span class="synPreProc">      if ( Scalar::Util::looks_like_number $$ref ) {</span>
<span class="synPreProc">          return sprintf &quot;%.8d&quot;, $$ref;</span>
<span class="synPreProc">      }</span>
<span class="synPreProc">      return; # lets the other SCALAR filter have a go</span>
<span class="synPreProc">  };</span>

<span class="synPreProc">  filter SCALAR =&gt; sub {</span>
<span class="synPreProc">      my ($ref, $properties) = @_;</span>
<span class="synPreProc">      return qq[&quot;$$ref&quot;];</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">Note that this &quot;filter stack&quot; is not possible on inline filters, since</span>
<span class="synperlPOD">it's a hash and keys with the same name are overwritten. Instead, you</span>
<span class="synperlPOD">can pass them as an array reference:</span>

<span class="synPreProc">  use Data::Printer filters =&gt; {</span>
<span class="synPreProc">      SCALAR =&gt; [ sub { ... }, sub { ... } ],</span>
<span class="synPreProc">  };</span>


<span class="synStatement">=head1</span><span class="synString"> SEE ALSO</span>

<span class="synIdentifier">L&lt;Data::Printer&gt;</span>


<span class="synStatement">=head1</span><span class="synString"> LICENSE AND COPYRIGHT</span>

<span class="synperlPOD">Copyright 2011 Breno G. de Oliveira </span><span class="synIdentifier">C&lt;&lt; &lt;garu at cpan.org&gt; &gt;&gt;</span><span class="synperlPOD">. All rights reserved.</span>

<span class="synperlPOD">This module is free software; you can redistribute it and/or modify it</span>
<span class="synperlPOD">under the same terms as Perl itself. See </span><span class="synIdentifier">L&lt;perlartistic&gt;</span><span class="synperlPOD">.</span>


</pre>

 </body>
</html>
