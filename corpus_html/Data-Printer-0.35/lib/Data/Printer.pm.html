<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre><span class="synStatement">package</span><span class="synType"> Data::Printer</span>;
<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;
<span class="synStatement">use </span>Term::ANSIColor <span class="synString">qw(color colored)</span>;
<span class="synStatement">use </span>Scalar::Util;
<span class="synStatement">use </span>Sort::Naturally;
<span class="synStatement">use </span>Carp <span class="synString">qw(croak)</span>;
<span class="synStatement">use </span>Clone::PP <span class="synString">qw(clone)</span>;
<span class="synStatement">use if</span> <span class="synIdentifier">$]</span> &gt;= <span class="synFloat">5.010</span>, <span class="synString">'Hash::Util::FieldHash'</span> =&gt; <span class="synString">qw(fieldhash)</span>;
<span class="synStatement">use if</span> <span class="synIdentifier">$]</span> &lt; <span class="synFloat">5.010</span>, <span class="synString">'Hash::Util::FieldHash::Compat'</span> =&gt; <span class="synString">qw(fieldhash)</span>;
<span class="synStatement">use </span>File::Spec;
<span class="synStatement">use </span>File::HomeDir ();
<span class="synStatement">use </span>Fcntl;
<span class="synStatement">use version</span> <span class="synFloat">0.77</span> ();

<span class="synStatement">our</span> <span class="synIdentifier">$VERSION</span> = <span class="synString">'0.35'</span>;

<span class="synPreProc">BEGIN </span>{
    <span class="synConditional">if</span> (<span class="synIdentifier">$^O</span> =~ <span class="synStatement">/</span><span class="synString">Win32</span><span class="synStatement">/i</span>) {
        <span class="synStatement">require</span> Win32::Console::ANSI;
        Win32::Console::ANSI-&gt;<span class="synStatement">import</span>;
    }
}


<span class="synComment"># defaults</span>
<span class="synStatement">my</span> <span class="synIdentifier">$BREAK</span> = <span class="synString">&quot;</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
<span class="synStatement">my</span> <span class="synIdentifier">$properties</span> = {
    <span class="synString">'name'</span>           =&gt; <span class="synString">'var'</span>,
    <span class="synString">'indent'</span>         =&gt; <span class="synNumber">4</span>,
    <span class="synString">'index'</span>          =&gt; <span class="synNumber">1</span>,
    <span class="synString">'max_depth'</span>      =&gt; <span class="synNumber">0</span>,
    <span class="synString">'multiline'</span>      =&gt; <span class="synNumber">1</span>,
    <span class="synString">'sort_keys'</span>      =&gt; <span class="synNumber">1</span>,
    <span class="synString">'deparse'</span>        =&gt; <span class="synNumber">0</span>,
    <span class="synString">'hash_separator'</span> =&gt; <span class="synString">'   '</span>,
    <span class="synString">'separator'</span>      =&gt; <span class="synString">','</span>,
    <span class="synString">'end_separator'</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">'show_tied'</span>      =&gt; <span class="synNumber">1</span>,
    <span class="synString">'show_tainted'</span>   =&gt; <span class="synNumber">1</span>,
    <span class="synString">'show_weak'</span>      =&gt; <span class="synNumber">1</span>,
    <span class="synString">'show_readonly'</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">'show_lvalue'</span>    =&gt; <span class="synNumber">1</span>,
    <span class="synString">'print_escapes'</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">'quote_keys'</span>     =&gt; <span class="synString">'auto'</span>,
    <span class="synString">'use_prototypes'</span> =&gt; <span class="synNumber">1</span>,
    <span class="synString">'output'</span>         =&gt; <span class="synString">'stderr'</span>,
    <span class="synString">'return_value'</span>   =&gt; <span class="synString">'dump'</span>,       <span class="synComment"># also 'void' or 'pass'</span>
    <span class="synString">'colored'</span>        =&gt; <span class="synString">'auto'</span>,       <span class="synComment"># also 0 or 1</span>
    <span class="synString">'caller_info'</span>    =&gt; <span class="synNumber">0</span>,
    <span class="synString">'caller_message'</span> =&gt; <span class="synString">'Printing in line __LINE__ of __FILENAME__:'</span>,
    <span class="synString">'class_method'</span>   =&gt; <span class="synString">'_data_printer'</span>, <span class="synComment"># use a specific dump method, if available</span>
    <span class="synString">'color'</span>          =&gt; {
        <span class="synString">'array'</span>       =&gt; <span class="synString">'bright_white'</span>,
        <span class="synString">'number'</span>      =&gt; <span class="synString">'bright_blue'</span>,
        <span class="synString">'string'</span>      =&gt; <span class="synString">'bright_yellow'</span>,
        <span class="synString">'class'</span>       =&gt; <span class="synString">'bright_green'</span>,
        <span class="synString">'method'</span>      =&gt; <span class="synString">'bright_green'</span>,
        <span class="synString">'undef'</span>       =&gt; <span class="synString">'bright_red'</span>,
        <span class="synString">'hash'</span>        =&gt; <span class="synString">'magenta'</span>,
        <span class="synString">'regex'</span>       =&gt; <span class="synString">'yellow'</span>,
        <span class="synString">'code'</span>        =&gt; <span class="synString">'green'</span>,
        <span class="synString">'glob'</span>        =&gt; <span class="synString">'bright_cyan'</span>,
        <span class="synString">'vstring'</span>     =&gt; <span class="synString">'bright_blue'</span>,
        <span class="synString">'lvalue'</span>      =&gt; <span class="synString">'bright_white'</span>,
        <span class="synString">'format'</span>      =&gt; <span class="synString">'bright_cyan'</span>,
        <span class="synString">'repeated'</span>    =&gt; <span class="synString">'white on_red'</span>,
        <span class="synString">'caller_info'</span> =&gt; <span class="synString">'bright_cyan'</span>,
        <span class="synString">'weak'</span>        =&gt; <span class="synString">'cyan'</span>,
        <span class="synString">'tainted'</span>     =&gt; <span class="synString">'red'</span>,
        <span class="synString">'escaped'</span>     =&gt; <span class="synString">'bright_red'</span>,
        <span class="synString">'unknown'</span>     =&gt; <span class="synString">'bright_yellow on_blue'</span>,
    },
    <span class="synString">'class'</span> =&gt; {
        <span class="synString">inherited</span>    =&gt; <span class="synString">'none'</span>,   <span class="synComment"># also 'all', 'public' or 'private'</span>
        <span class="synString">universal</span>    =&gt; <span class="synNumber">1</span>,
        <span class="synString">parents</span>      =&gt; <span class="synNumber">1</span>,
        <span class="synString">linear_isa</span>   =&gt; <span class="synString">'auto'</span>,
        <span class="synString">expand</span>       =&gt; <span class="synNumber">1</span>,        <span class="synComment"># how many levels to expand. 0 for none, 'all' for all</span>
        <span class="synString">internals</span>    =&gt; <span class="synNumber">1</span>,
        <span class="synString">export</span>       =&gt; <span class="synNumber">1</span>,
        <span class="synString">sort_methods</span> =&gt; <span class="synNumber">1</span>,
        <span class="synString">show_methods</span> =&gt; <span class="synString">'all'</span>,    <span class="synComment"># also 'none', 'public', 'private'</span>
        <span class="synString">show_reftype</span> =&gt; <span class="synNumber">0</span>,
        <span class="synString">_depth</span>       =&gt; <span class="synNumber">0</span>,        <span class="synComment"># used internally</span>
    },
    <span class="synString">'filters'</span> =&gt; {
        <span class="synComment"># The IO ref type isn't supported as you can't actually create one,</span>
        <span class="synComment"># any handle you make is automatically blessed into an IO::* object,</span>
        <span class="synComment"># and those are separately handled.</span>
        <span class="synString">SCALAR</span>  =&gt; [ \<span class="synIdentifier">&amp;SCALAR</span>   ],
        <span class="synString">ARRAY</span>   =&gt; [ \<span class="synIdentifier">&amp;ARRAY</span>    ],
        <span class="synString">HASH</span>    =&gt; [ \<span class="synIdentifier">&amp;HASH</span>     ],
        <span class="synString">REF</span>     =&gt; [ \<span class="synIdentifier">&amp;REF</span>      ],
        <span class="synString">CODE</span>    =&gt; [ \<span class="synIdentifier">&amp;CODE</span>     ],
        <span class="synString">GLOB</span>    =&gt; [ \<span class="synIdentifier">&amp;GLOB</span>     ],
        <span class="synString">VSTRING</span> =&gt; [ \<span class="synIdentifier">&amp;VSTRING</span>  ],
        <span class="synString">LVALUE</span>  =&gt; [ \<span class="synIdentifier">&amp;LVALUE</span> ],
        <span class="synString">FORMAT</span>  =&gt; [ \<span class="synIdentifier">&amp;FORMAT</span> ],
        <span class="synString">Regexp</span>  =&gt; [ \<span class="synIdentifier">&amp;Regexp</span>   ],
        <span class="synString">-unknown</span>=&gt; [ \<span class="synIdentifier">&amp;_unknown</span> ],
        <span class="synString">-class</span>  =&gt; [ \<span class="synIdentifier">&amp;_class</span>   ],
    },

    <span class="synString">_output</span>          =&gt; *STDERR,     <span class="synComment"># used internally</span>
    <span class="synString">_current_indent</span>  =&gt; <span class="synNumber">0</span>,           <span class="synComment"># used internally</span>
    <span class="synString">_linebreak</span>       =&gt; \<span class="synIdentifier">$BREAK</span>,     <span class="synComment"># used internally</span>
    <span class="synString">_seen</span>            =&gt; {},          <span class="synComment"># used internally</span>
    <span class="synString">_seen_override</span>   =&gt; {},          <span class="synComment"># used internally</span>
    <span class="synString">_depth</span>           =&gt; <span class="synNumber">0</span>,           <span class="synComment"># used internally</span>
    <span class="synString">_tie</span>             =&gt; <span class="synNumber">0</span>,           <span class="synComment"># used internally</span>
};


<span class="synKeyword">sub </span><span class="synFunction">import </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$args</span>;
    <span class="synConditional">if</span> (<span class="synStatement">scalar</span> <span class="synIdentifier">@_</span>) {
        <span class="synIdentifier">$args</span> = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synStatement">shift</span> : {<span class="synIdentifier">@_</span>};
        croak <span class="synString">'Data::Printer can receive either a hash or a hash reference.'</span>
            <span class="synConditional">unless</span> <span class="synOperator">ref</span> <span class="synIdentifier">$args</span> <span class="synOperator">and</span> <span class="synOperator">ref</span> <span class="synIdentifier">$args</span> <span class="synOperator">eq</span> <span class="synString">'HASH'</span>;
    }

    <span class="synComment"># the RC file overrides the defaults,</span>
    <span class="synComment"># (and we load it only once)</span>
    <span class="synConditional">unless</span>( <span class="synStatement">exists</span> <span class="synIdentifier">$properties-&gt;{</span><span class="synString">_initialized</span><span class="synIdentifier">}</span> ) {
        _load_rc_file(<span class="synIdentifier">$args</span>);
        <span class="synIdentifier">$properties-&gt;{</span><span class="synString">_initialized</span><span class="synIdentifier">}</span> = <span class="synNumber">1</span>;
    }

    <span class="synComment"># and 'use' arguments override the RC file</span>
    <span class="synConditional">if</span> (<span class="synIdentifier">$args</span>) {
        <span class="synIdentifier">$properties</span> = _merge( <span class="synIdentifier">$args</span> );
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$exported</span> = (<span class="synIdentifier">$properties-&gt;{</span><span class="synString">use_prototypes</span><span class="synIdentifier">}</span> ? \<span class="synIdentifier">&amp;p</span> : \<span class="synIdentifier">&amp;np</span> );
    <span class="synStatement">my</span> <span class="synIdentifier">$imported</span> = <span class="synIdentifier">$properties-&gt;{</span><span class="synString">alias</span><span class="synIdentifier">}</span> || <span class="synString">'p'</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$caller</span> = <span class="synStatement">caller</span>;
    <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;
    <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">$caller</span><span class="synSpecial">\:</span><span class="synString">:</span><span class="synIdentifier">$imported</span><span class="synString">&quot;</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$exported</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">p </span><span class="synType">(\[@$%&amp;];%) </span>{
    <span class="synStatement">return</span> _print_and_return( <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>, _data_printer(!!<span class="synOperator">defined</span> <span class="synStatement">wantarray</span>, <span class="synIdentifier">@_</span>) );
}

<span class="synComment"># np() is a p() clone without prototypes.</span>
<span class="synComment"># Just like regular Data::Dumper, this version</span>
<span class="synComment"># expects a reference as its first argument.</span>
<span class="synComment"># We make a single exception for when we only</span>
<span class="synComment"># get one argument, in which case we ref it</span>
<span class="synComment"># for the user and keep going.</span>
<span class="synKeyword">sub </span><span class="synFunction">np  </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$item</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> (!<span class="synOperator">ref</span> <span class="synIdentifier">$item</span> &amp;&amp; <span class="synIdentifier">@_</span> == <span class="synNumber">0</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$item_value</span> = <span class="synIdentifier">$item</span>;
        <span class="synIdentifier">$item</span> = \<span class="synIdentifier">$item_value</span>;
    }

    <span class="synStatement">return</span> _print_and_return( <span class="synIdentifier">$item</span>, _data_printer(!!<span class="synOperator">defined</span> <span class="synStatement">wantarray</span>, <span class="synIdentifier">$item</span>, <span class="synIdentifier">@_</span>) );
}

<span class="synKeyword">sub </span><span class="synFunction">_print_and_return </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$dump</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">return_value</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'pass'</span> ) {
        <span class="synStatement">print</span> <span class="synStatement">{</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> <span class="synStatement">}</span> <span class="synIdentifier">$dump</span> . <span class="synIdentifier">$/</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$item</span>;
        <span class="synConditional">if</span> (<span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span>) {
            <span class="synStatement">return</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$item</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
        }
        <span class="synConditional">elsif</span> (<span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synString">'HASH'</span>) {
            <span class="synStatement">return</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$item</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>;
        }
        <span class="synConditional">elsif</span> ( <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synIdentifier">$_</span> <span class="synStatement">}</span> <span class="synString">qw(REF SCALAR CODE Regexp GLOB VSTRING)</span> ) {
            <span class="synStatement">return</span> <span class="synIdentifier">$$item</span>;
        }
        <span class="synConditional">else</span> {
            <span class="synStatement">return</span> <span class="synIdentifier">$item</span>;
        }
    }
    <span class="synConditional">elsif</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">return_value</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'void'</span> ) {
        <span class="synStatement">print</span> <span class="synStatement">{</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> <span class="synStatement">}</span> <span class="synIdentifier">$dump</span> . <span class="synIdentifier">$/</span>;
        <span class="synStatement">return</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">print</span> <span class="synStatement">{</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> <span class="synStatement">}</span> <span class="synIdentifier">$dump</span> . <span class="synIdentifier">$/</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synStatement">wantarray</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$dump</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_data_printer </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$wantarray</span> = <span class="synStatement">shift</span>;

    croak <span class="synString">'When calling p() without prototypes, please pass arguments as references'</span>
        <span class="synConditional">unless</span> <span class="synOperator">ref</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>;

    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">%local_properties</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">local</span> <span class="synIdentifier">%ENV</span> = <span class="synIdentifier">%ENV</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$p</span> = _merge(\<span class="synIdentifier">%local_properties</span>);
    <span class="synConditional">unless</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">multiline</span><span class="synIdentifier">}</span>) {
        <span class="synIdentifier">$BREAK</span> = <span class="synString">' '</span>;
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">'indent'</span><span class="synIdentifier">}</span> = <span class="synNumber">0</span>;
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">'index'</span><span class="synIdentifier">}</span>  = <span class="synNumber">0</span>;
    }

    <span class="synComment"># We disable colors if colored is set to false.</span>
    <span class="synComment"># If set to &quot;auto&quot;, we disable colors if the user</span>
    <span class="synComment"># set ANSI_COLORS_DISABLED or if we're either</span>
    <span class="synComment"># returning the value (instead of printing) or</span>
    <span class="synComment"># being piped to another command.</span>
    <span class="synConditional">if</span> ( !<span class="synIdentifier">$p-&gt;{</span><span class="synString">colored</span><span class="synIdentifier">}</span>
          <span class="synOperator">or</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">colored</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'auto'</span>
              <span class="synOperator">and</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$ENV{</span><span class="synString">ANSI_COLORS_DISABLED</span><span class="synIdentifier">}</span>
                   <span class="synOperator">or</span> <span class="synIdentifier">$wantarray</span>
                   <span class="synOperator">or</span> <span class="synOperator">not</span> <span class="synStatement">-t</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span>
                  )
          )
    ) {
        <span class="synIdentifier">$ENV{</span><span class="synString">ANSI_COLORS_DISABLED</span><span class="synIdentifier">}</span> = <span class="synNumber">1</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">delete</span> <span class="synIdentifier">$ENV{</span><span class="synString">ANSI_COLORS_DISABLED</span><span class="synIdentifier">}</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$out</span> = color(<span class="synString">'reset'</span>);

    <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">caller_info</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span> == <span class="synNumber">0</span> ) {
        <span class="synIdentifier">$out</span> .= _get_info_message(<span class="synIdentifier">$p</span>);
    }

    <span class="synIdentifier">$out</span> .= _p( <span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span> );
    <span class="synStatement">return</span> (<span class="synIdentifier">$out</span>, <span class="synIdentifier">$p</span>);
}


<span class="synKeyword">sub </span><span class="synFunction">_p </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = (<span class="synOperator">defined</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_reftype</span><span class="synIdentifier">}</span> ? <span class="synIdentifier">$p-&gt;{</span><span class="synString">_reftype</span><span class="synIdentifier">}</span> : <span class="synOperator">ref</span> <span class="synIdentifier">$item</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$tie</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synComment"># Object's unique ID, avoiding circular structures</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$id</span> = _object_id( <span class="synIdentifier">$item</span> );
    <span class="synConditional">if</span> ( <span class="synStatement">exists</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_seen</span><span class="synIdentifier">}-&gt;{$id}</span> ) {
        <span class="synConditional">if</span> ( <span class="synOperator">not</span> <span class="synOperator">defined</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_reftype</span><span class="synIdentifier">}</span> ) {
            <span class="synStatement">return</span> colored(<span class="synIdentifier">$p-&gt;{</span><span class="synString">_seen</span><span class="synIdentifier">}-&gt;{$id}</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">repeated</span><span class="synIdentifier">}</span>);
        }
    }
    <span class="synComment"># some filters don't want us to show their repeated refs</span>
    <span class="synConditional">elsif</span>( !<span class="synStatement">exists</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_seen_override</span><span class="synIdentifier">}{$ref}</span> ) {
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_seen</span><span class="synIdentifier">}-&gt;{$id}</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">name</span><span class="synIdentifier">}</span>;
    }

    <span class="synStatement">delete</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_reftype</span><span class="synIdentifier">}</span>; <span class="synComment"># abort override</span>

    <span class="synComment"># globs don't play nice</span>
    <span class="synIdentifier">$ref</span> = <span class="synString">'GLOB'</span> <span class="synConditional">if</span> <span class="synString">&quot;</span><span class="synIdentifier">$item</span><span class="synString">&quot;</span> =~ <span class="synStatement">/</span><span class="synString">GLOB</span><span class="synSpecial">\([^()]+\)</span><span class="synString">$</span><span class="synStatement">/</span>;


    <span class="synComment"># filter item (if user set a filter for it)</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$found</span>;
    <span class="synConditional">if</span> ( <span class="synStatement">exists</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">filters</span><span class="synIdentifier">}-&gt;{$ref}</span> ) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$filter</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$p-&gt;{</span><span class="synString">filters</span><span class="synIdentifier">}-&gt;{$ref}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span> ) {
            <span class="synConditional">if</span> ( <span class="synOperator">defined</span> (<span class="synStatement">my</span> <span class="synIdentifier">$result</span> = <span class="synIdentifier">$filter</span>-&gt;(<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>)) ) {
                <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$result</span>;
                <span class="synIdentifier">$found</span> = <span class="synNumber">1</span>;
                <span class="synStatement">last</span>;
            }
        }
    }

    <span class="synConditional">if</span> (<span class="synOperator">not</span> <span class="synIdentifier">$found</span> <span class="synOperator">and</span> Scalar::Util::blessed(<span class="synIdentifier">$item</span>) ) {
        <span class="synComment"># let '-class' filters have a go</span>
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$filter</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$p-&gt;{</span><span class="synString">filters</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'-class'</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span> ) {
            <span class="synConditional">if</span> ( <span class="synOperator">defined</span> (<span class="synStatement">my</span> <span class="synIdentifier">$result</span> = <span class="synIdentifier">$filter</span>-&gt;(<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>)) ) {
                <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$result</span>;
                <span class="synIdentifier">$found</span> = <span class="synNumber">1</span>;
                <span class="synStatement">last</span>;
            }
        }
    }
    
    <span class="synConditional">if</span> ( <span class="synOperator">not</span> <span class="synIdentifier">$found</span> ) {
        <span class="synComment"># if it's not a class and not a known core type, we must be in</span>
        <span class="synComment"># a future perl with some type we're unaware of</span>
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$filter</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$p-&gt;{</span><span class="synString">filters</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'-unknown'</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span> ) {
            <span class="synConditional">if</span> ( <span class="synOperator">defined</span> (<span class="synStatement">my</span> <span class="synIdentifier">$result</span> = <span class="synIdentifier">$filter</span>-&gt;(<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>)) ) {
                <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$result</span>;
                <span class="synStatement">last</span>;
            }
        }
    }

    <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">show_tied</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> ) {
        <span class="synIdentifier">$string</span> .= <span class="synString">' (tied to '</span> . <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> . <span class="synString">')'</span>;
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> = <span class="synString">''</span>;
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}



<span class="synComment">######################################</span>
<span class="synComment">## Default filters</span>
<span class="synComment">######################################</span>

<span class="synKeyword">sub </span><span class="synFunction">SCALAR </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synConditional">if</span> (<span class="synOperator">not</span> <span class="synOperator">defined</span> <span class="synIdentifier">$$item</span>) {
        <span class="synIdentifier">$string</span> .= colored(<span class="synString">'undef'</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'undef'</span><span class="synIdentifier">}</span>);
    }
    <span class="synConditional">elsif</span> (Scalar::Util::looks_like_number(<span class="synIdentifier">$$item</span>)) {
        <span class="synIdentifier">$string</span> .= colored(<span class="synIdentifier">$$item</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'number'</span><span class="synIdentifier">}</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">my</span> <span class="synIdentifier">$val</span> = _escape_chars(<span class="synIdentifier">$$item</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}{</span><span class="synString">string</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$p</span>);

        <span class="synIdentifier">$string</span> .= <span class="synString">q[&quot;]</span> . colored(<span class="synIdentifier">$val</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'string'</span><span class="synIdentifier">}</span>) . <span class="synString">q[&quot;]</span>;
    }

    <span class="synIdentifier">$string</span> .= <span class="synString">' '</span> . colored(<span class="synString">'(TAINTED)'</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'tainted'</span><span class="synIdentifier">}</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">show_tainted</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> Scalar::Util::tainted(<span class="synIdentifier">$$item</span>);

    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> = <span class="synOperator">ref</span> <span class="synStatement">tied</span> <span class="synIdentifier">$$item</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">show_readonly</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synIdentifier">&amp;</span><span class="synType">Internals::</span><span class="synIdentifier">SvREADONLY</span>( <span class="synIdentifier">$item</span> )) {
        <span class="synIdentifier">$string</span> .= <span class="synString">' (read-only)'</span>;
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_escape_chars </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$str</span>, <span class="synIdentifier">$orig_color</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$orig_color</span>   = color( <span class="synIdentifier">$orig_color</span> );
    <span class="synStatement">my</span> <span class="synIdentifier">$esc_color</span> = color( <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}{</span><span class="synString">escaped</span><span class="synIdentifier">}</span> );

    <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">print_escapes</span><span class="synIdentifier">}</span>) {
        <span class="synIdentifier">$str</span> =~ <span class="synStatement">s/</span><span class="synSpecial">\e</span><span class="synStatement">/</span><span class="synIdentifier">$esc_color</span><span class="synSpecial">\\</span><span class="synString">e</span><span class="synIdentifier">$orig_color</span><span class="synStatement">/g</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">%escaped</span> = (
            <span class="synString">&quot;</span><span class="synSpecial">\n</span><span class="synString">&quot;</span> =&gt; <span class="synString">'\n'</span>,
            <span class="synString">&quot;</span><span class="synSpecial">\r</span><span class="synString">&quot;</span> =&gt; <span class="synString">'\r'</span>,
            <span class="synString">&quot;</span><span class="synSpecial">\t</span><span class="synString">&quot;</span> =&gt; <span class="synString">'\t'</span>,
            <span class="synString">&quot;</span><span class="synSpecial">\f</span><span class="synString">&quot;</span> =&gt; <span class="synString">'\f'</span>,
            <span class="synString">&quot;</span><span class="synSpecial">\b</span><span class="synString">&quot;</span> =&gt; <span class="synString">'\b'</span>,
            <span class="synString">&quot;</span><span class="synSpecial">\a</span><span class="synString">&quot;</span> =&gt; <span class="synString">'\a'</span>,
        );
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$k</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%escaped</span> ) {
            <span class="synIdentifier">$str</span> =~ <span class="synStatement">s/</span><span class="synIdentifier">$k</span><span class="synStatement">/</span><span class="synIdentifier">$esc_color$escaped{$k}$orig_color</span><span class="synStatement">/g</span>;
        }
    }
    <span class="synComment"># always escape the null character</span>
    <span class="synIdentifier">$str</span> =~ <span class="synStatement">s/</span><span class="synSpecial">\0</span><span class="synStatement">/</span><span class="synIdentifier">$esc_color</span><span class="synSpecial">\\</span><span class="synString">0</span><span class="synIdentifier">$orig_color</span><span class="synStatement">/g</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$str</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">ARRAY </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;
    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>++;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">max_depth</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span> &gt; <span class="synIdentifier">$p-&gt;{</span><span class="synString">max_depth</span><span class="synIdentifier">}</span> ) {
        <span class="synIdentifier">$string</span> .= <span class="synString">'[ ... ]'</span>;
    }
    <span class="synConditional">elsif</span> (<span class="synOperator">not</span> <span class="synIdentifier">@$item</span>) {
        <span class="synIdentifier">$string</span> .= <span class="synString">'[]'</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$string</span> .= <span class="synString">&quot;[</span><span class="synIdentifier">$BREAK</span><span class="synString">&quot;</span>;
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> += <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;

        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$i</span> (<span class="synNumber">0</span> .. <span class="synIdentifier">$#{$item}</span> ) {
            <span class="synIdentifier">$p-&gt;{</span><span class="synString">name</span><span class="synIdentifier">}</span> .= <span class="synString">&quot;[</span><span class="synIdentifier">$i</span><span class="synString">]&quot;</span>;

            <span class="synStatement">my</span> <span class="synIdentifier">$array_elem</span> = <span class="synIdentifier">$item-&gt;[$i]</span>;
            <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>);
            <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">'index'</span><span class="synIdentifier">}</span>) {
                <span class="synIdentifier">$string</span> .= colored(
                             <span class="synStatement">sprintf</span>(<span class="synString">&quot;%-*s&quot;</span>, <span class="synNumber">3</span> + <span class="synStatement">length</span>(<span class="synIdentifier">$#{$item}</span>), <span class="synString">&quot;[</span><span class="synIdentifier">$i</span><span class="synString">]&quot;</span>),
                             <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'array'</span><span class="synIdentifier">}</span>
                       );
            }

            <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$array_elem</span>;

            <span class="synComment"># scalar references should be re-referenced</span>
            <span class="synComment"># to gain a '\' sign in front of them</span>
            <span class="synConditional">if</span> (!<span class="synIdentifier">$ref</span> <span class="synOperator">or</span> <span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synString">'SCALAR'</span>) {
                <span class="synIdentifier">$string</span> .= _p( \<span class="synIdentifier">$array_elem</span>, <span class="synIdentifier">$p</span> );
            }
            <span class="synConditional">else</span> {
                <span class="synIdentifier">$string</span> .= _p( <span class="synIdentifier">$array_elem</span>, <span class="synIdentifier">$p</span> );
            }
            <span class="synIdentifier">$string</span> .= <span class="synString">' '</span> . colored(<span class="synString">'(weak)'</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'weak'</span><span class="synIdentifier">}</span>)
                <span class="synConditional">if</span> <span class="synIdentifier">$ref</span> <span class="synOperator">and</span> Scalar::Util::isweak(<span class="synIdentifier">$item-&gt;[$i]</span>) <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">show_weak</span><span class="synIdentifier">}</span>;

            <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$p-&gt;{</span><span class="synString">separator</span><span class="synIdentifier">}</span>
              <span class="synConditional">if</span> <span class="synIdentifier">$i</span> &lt; <span class="synIdentifier">$#{$item}</span> || <span class="synIdentifier">$p-&gt;{</span><span class="synString">end_separator</span><span class="synIdentifier">}</span>;

            <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$BREAK</span>;

            <span class="synStatement">my</span> <span class="synIdentifier">$size</span> = <span class="synNumber">2</span> + <span class="synStatement">length</span>(<span class="synIdentifier">$i</span>); <span class="synComment"># [10], [100], etc</span>
            <span class="synStatement">substr</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">name</span><span class="synIdentifier">}</span>, -<span class="synIdentifier">$size</span>, <span class="synIdentifier">$size</span>, <span class="synString">''</span>;
        }
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> -= <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>) . <span class="synString">&quot;]&quot;</span>;
    }

    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> = <span class="synOperator">ref</span> <span class="synStatement">tied</span> <span class="synIdentifier">@$item</span>;
    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>--;

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">REF </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synComment"># look-ahead, add a '\' only if it's not an object</span>
    <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">$ref_ahead</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$$item</span> ) {
        <span class="synIdentifier">$string</span> .= <span class="synString">'</span><span class="synSpecial">\\</span><span class="synString"> '</span> <span class="synConditional">if</span> <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_</span> <span class="synOperator">eq</span> <span class="synIdentifier">$ref_ahead</span> <span class="synStatement">}</span>
            <span class="synString">qw(SCALAR CODE Regexp ARRAY HASH GLOB REF)</span>;
    }
    <span class="synIdentifier">$string</span> .= _p(<span class="synIdentifier">$$item</span>, <span class="synIdentifier">$p</span>);

    <span class="synIdentifier">$string</span> .= <span class="synString">' '</span> . colored(<span class="synString">'(weak)'</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'weak'</span><span class="synIdentifier">}</span>)
        <span class="synConditional">if</span> Scalar::Util::isweak(<span class="synIdentifier">$$item</span>) <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">show_weak</span><span class="synIdentifier">}</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">CODE </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$code</span> = <span class="synString">'sub { ... }'</span>;
    <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">deparse</span><span class="synIdentifier">}</span>) {
        <span class="synIdentifier">$code</span> = _deparse( <span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span> );
    }
    <span class="synIdentifier">$string</span> .= colored(<span class="synIdentifier">$code</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'code'</span><span class="synIdentifier">}</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">HASH </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>++;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">max_depth</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span> &gt; <span class="synIdentifier">$p-&gt;{</span><span class="synString">max_depth</span><span class="synIdentifier">}</span> ) {
        <span class="synIdentifier">$string</span> .= <span class="synString">'{ ... }'</span>;
    }
    <span class="synConditional">elsif</span> (<span class="synOperator">not</span> <span class="synStatement">keys</span> <span class="synIdentifier">%$item</span>) {
        <span class="synIdentifier">$string</span> .= <span class="synString">'{}'</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$string</span> .= <span class="synString">&quot;{</span><span class="synIdentifier">$BREAK</span><span class="synString">&quot;</span>;
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> += <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$total_keys</span>  = <span class="synStatement">scalar</span> <span class="synStatement">keys</span> <span class="synIdentifier">%$item</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$len</span>         = <span class="synNumber">0</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$multiline</span>   = <span class="synIdentifier">$p-&gt;{</span><span class="synString">multiline</span><span class="synIdentifier">}</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$hash_color</span>  = <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}{</span><span class="synString">hash</span><span class="synIdentifier">}</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$quote_keys</span>  = <span class="synIdentifier">$p-&gt;{</span><span class="synString">quote_keys</span><span class="synIdentifier">}</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">@keys</span> = ();

        <span class="synComment"># first pass, preparing keys to display (and getting largest key size)</span>
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$key</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">sort_keys</span><span class="synIdentifier">}</span> ? nsort <span class="synStatement">keys</span> <span class="synIdentifier">%$item</span> : <span class="synStatement">keys</span> <span class="synIdentifier">%$item</span> ) {
            <span class="synStatement">my</span> <span class="synIdentifier">$new_key</span> = _escape_chars(<span class="synIdentifier">$key</span>, <span class="synIdentifier">$hash_color</span>, <span class="synIdentifier">$p</span>);
            <span class="synStatement">my</span> <span class="synIdentifier">$colored</span> = colored( <span class="synIdentifier">$new_key</span>, <span class="synIdentifier">$hash_color</span> );

            <span class="synComment"># wrap in uncolored single quotes if there's</span>
            <span class="synComment"># any space or escaped characters</span>
            <span class="synConditional">if</span> ( <span class="synIdentifier">$quote_keys</span>
                  <span class="synOperator">and</span> (
                        <span class="synIdentifier">$quote_keys</span> <span class="synOperator">ne</span> <span class="synString">'auto'</span>
                        <span class="synOperator">or</span> (
                             <span class="synIdentifier">$key</span> <span class="synOperator">eq</span> <span class="synString">q()</span>
                             <span class="synOperator">or</span> <span class="synIdentifier">$new_key</span> <span class="synOperator">ne</span> <span class="synIdentifier">$key</span>
                             <span class="synOperator">or</span> <span class="synIdentifier">$new_key</span> =~ <span class="synStatement">/</span><span class="synSpecial">\s</span><span class="synString">|</span><span class="synSpecial">\n</span><span class="synString">|</span><span class="synSpecial">\t</span><span class="synString">|</span><span class="synSpecial">\r</span><span class="synStatement">/</span>
                        )
                  )
            ) {
                <span class="synIdentifier">$colored</span> = <span class="synString">qq['</span><span class="synIdentifier">$colored</span><span class="synString">']</span>;
            }

            <span class="synStatement">push</span> <span class="synIdentifier">@keys</span>, {
                <span class="synString">raw</span>     =&gt; <span class="synIdentifier">$key</span>,
                <span class="synString">colored</span> =&gt; <span class="synIdentifier">$colored</span>,
            };

            <span class="synComment"># length of the largest key is used for indenting</span>
            <span class="synConditional">if</span> (<span class="synIdentifier">$multiline</span>) {
                <span class="synStatement">my</span> <span class="synIdentifier">$l</span> = <span class="synStatement">length</span> <span class="synIdentifier">$colored</span>;
                <span class="synIdentifier">$len</span> = <span class="synIdentifier">$l</span> <span class="synConditional">if</span> <span class="synIdentifier">$l</span> &gt; <span class="synIdentifier">$len</span>;
            }
        }

        <span class="synComment"># second pass, traversing and rendering</span>
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$key</span> (<span class="synIdentifier">@keys</span>) {
            <span class="synStatement">my</span> <span class="synIdentifier">$raw_key</span>     = <span class="synIdentifier">$key-&gt;{</span><span class="synString">raw</span><span class="synIdentifier">}</span>;
            <span class="synStatement">my</span> <span class="synIdentifier">$colored_key</span> = <span class="synIdentifier">$key-&gt;{</span><span class="synString">colored</span><span class="synIdentifier">}</span>;
            <span class="synStatement">my</span> <span class="synIdentifier">$element</span>     = <span class="synIdentifier">$item-&gt;{$raw_key}</span>;
            <span class="synIdentifier">$p-&gt;{</span><span class="synString">name</span><span class="synIdentifier">}</span>     .= <span class="synString">&quot;{</span><span class="synIdentifier">$raw_key</span><span class="synString">}&quot;</span>;

            <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>)
                     . <span class="synStatement">sprintf</span>(<span class="synString">&quot;%-*s&quot;</span>, <span class="synIdentifier">$len</span>, <span class="synIdentifier">$colored_key</span>)
                     . <span class="synIdentifier">$p-&gt;{</span><span class="synString">hash_separator</span><span class="synIdentifier">}</span>
                     ;

            <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$element</span>;
            <span class="synComment"># scalar references should be re-referenced</span>
            <span class="synComment"># to gain a '\' sign in front of them</span>
            <span class="synConditional">if</span> (!<span class="synIdentifier">$ref</span> <span class="synOperator">or</span> <span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synString">'SCALAR'</span>) {
                <span class="synIdentifier">$string</span> .= _p( \<span class="synIdentifier">$element</span>, <span class="synIdentifier">$p</span> );
            }
            <span class="synConditional">else</span> {
                <span class="synIdentifier">$string</span> .= _p( <span class="synIdentifier">$element</span>, <span class="synIdentifier">$p</span> );
            }

            <span class="synIdentifier">$string</span> .= <span class="synString">' '</span> . colored(<span class="synString">'(weak)'</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'weak'</span><span class="synIdentifier">}</span>)
                <span class="synConditional">if</span> <span class="synIdentifier">$ref</span>
                  <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">show_weak</span><span class="synIdentifier">}</span>
                  <span class="synOperator">and</span> Scalar::Util::isweak(<span class="synIdentifier">$item-&gt;{$raw_key}</span>);

            <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$p-&gt;{</span><span class="synString">separator</span><span class="synIdentifier">}</span>
              <span class="synConditional">if</span> --<span class="synIdentifier">$total_keys</span> &gt; <span class="synNumber">0</span> || <span class="synIdentifier">$p-&gt;{</span><span class="synString">end_separator</span><span class="synIdentifier">}</span>;

            <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$BREAK</span>;

            <span class="synStatement">my</span> <span class="synIdentifier">$size</span> = <span class="synNumber">2</span> + <span class="synStatement">length</span>(<span class="synIdentifier">$raw_key</span>); <span class="synComment"># {foo}, {z}, etc</span>
            <span class="synStatement">substr</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">name</span><span class="synIdentifier">}</span>, -<span class="synIdentifier">$size</span>, <span class="synIdentifier">$size</span>, <span class="synString">''</span>;
        }
        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> -= <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>) . <span class="synString">&quot;}&quot;</span>;
    }

    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> = <span class="synOperator">ref</span> <span class="synStatement">tied</span> <span class="synIdentifier">%$item</span>;
    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>--;

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">Regexp </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$val</span> = <span class="synString">&quot;</span><span class="synIdentifier">$item</span><span class="synString">&quot;</span>;
    <span class="synComment"># a regex to parse a regex. Talk about full circle :)</span>
    <span class="synComment"># note: we are not validating anything, just grabbing modifiers</span>
    <span class="synConditional">if</span> (<span class="synIdentifier">$val</span> =~ <span class="synStatement">m/</span><span class="synSpecial">\(\?\^?([uladxismpogce]*)(?:\-[uladxismpogce]+)?</span><span class="synString">:</span><span class="synSpecial">(.*)\)</span><span class="synStatement">/s</span>) {
        <span class="synStatement">my</span> (<span class="synIdentifier">$modifiers</span>, <span class="synIdentifier">$val</span>) = (<span class="synIdentifier">$1</span>, <span class="synIdentifier">$2</span>);
        <span class="synIdentifier">$string</span> .= colored(<span class="synIdentifier">$val</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'regex'</span><span class="synIdentifier">}</span>);
        <span class="synConditional">if</span> (<span class="synIdentifier">$modifiers</span>) {
            <span class="synIdentifier">$string</span> .= <span class="synString">&quot;  (modifiers: </span><span class="synIdentifier">$modifiers</span><span class="synString">)&quot;</span>;
        }
    }
    <span class="synConditional">else</span> {
        croak <span class="synString">&quot;Unrecognized regex </span><span class="synIdentifier">$val</span><span class="synString">. Please submit a bug report for Data::Printer.&quot;</span>;
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">VSTRING </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;
    <span class="synIdentifier">$string</span> .= colored(version-&gt;declare(<span class="synIdentifier">$$item</span>)-&gt;normal, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'vstring'</span><span class="synIdentifier">}</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">FORMAT </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;
    <span class="synIdentifier">$string</span> .= colored(<span class="synString">&quot;FORMAT&quot;</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'format'</span><span class="synIdentifier">}</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">LVALUE </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = SCALAR( <span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span> );
    <span class="synIdentifier">$string</span> .= colored( <span class="synString">' (LVALUE)'</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}{</span><span class="synString">lvalue</span><span class="synIdentifier">}</span> )
        <span class="synConditional">if</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">show_lvalue</span><span class="synIdentifier">}</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">GLOB </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;

    <span class="synIdentifier">$string</span> .= colored(<span class="synString">&quot;</span><span class="synIdentifier">$$item</span><span class="synString">&quot;</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'glob'</span><span class="synIdentifier">}</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$extra</span> = <span class="synString">''</span>;

    <span class="synComment"># unfortunately, some systems (like Win32) do not</span>
    <span class="synComment"># implement some of these flags (maybe not even</span>
    <span class="synComment"># fcntl() itself, so we must wrap it.</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$flags</span>;
    <span class="synStatement">eval</span> { <span class="synStatement">no warnings</span> <span class="synString">qw( unopened closed )</span>; <span class="synIdentifier">$flags</span> = <span class="synStatement">fcntl</span>(<span class="synIdentifier">$$item</span>, F_GETFL, <span class="synNumber">0</span>) };
    <span class="synConditional">if</span> (<span class="synIdentifier">$flags</span>) {
        <span class="synIdentifier">$extra</span> .= (<span class="synIdentifier">$flags</span> &amp; O_WRONLY) ? <span class="synString">'write-only'</span>
                : (<span class="synIdentifier">$flags</span> &amp; O_RDWR)   ? <span class="synString">'read/write'</span>
                : <span class="synString">'read-only'</span>
                ;

        <span class="synComment"># How to avoid croaking when the system</span>
        <span class="synComment"># doesn't implement one of those, without skipping</span>
        <span class="synComment"># the whole thing? Maybe there's a better way.</span>
        <span class="synComment"># Solaris, for example, doesn't have O_ASYNC :(</span>
        <span class="synStatement">my</span> <span class="synIdentifier">%flags</span> = ();
        <span class="synStatement">eval</span> { <span class="synIdentifier">$flags{</span><span class="synString">'append'</span><span class="synIdentifier">}</span>      = O_APPEND   };
        <span class="synStatement">eval</span> { <span class="synIdentifier">$flags{</span><span class="synString">'async'</span><span class="synIdentifier">}</span>       = O_ASYNC    }; <span class="synComment"># leont says this is the only one I should care for.</span>
        <span class="synStatement">eval</span> { <span class="synIdentifier">$flags{</span><span class="synString">'create'</span><span class="synIdentifier">}</span>      = O_CREAT    };
        <span class="synStatement">eval</span> { <span class="synIdentifier">$flags{</span><span class="synString">'truncate'</span><span class="synIdentifier">}</span>    = O_TRUNC    };
        <span class="synStatement">eval</span> { <span class="synIdentifier">$flags{</span><span class="synString">'nonblocking'</span><span class="synIdentifier">}</span> = O_NONBLOCK };

        <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">@flags</span> = <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$flags</span> &amp; <span class="synIdentifier">$flags{$_}</span> <span class="synStatement">}</span> <span class="synStatement">keys</span> <span class="synIdentifier">%flags</span>) {
            <span class="synIdentifier">$extra</span> .= <span class="synString">&quot;, flags: </span><span class="synIdentifier">@flags</span><span class="synString">&quot;</span>;
        }
        <span class="synIdentifier">$extra</span> .= <span class="synString">', '</span>;
    }
    <span class="synStatement">my</span> <span class="synIdentifier">@layers</span> = ();
    <span class="synStatement">eval</span> { <span class="synIdentifier">@layers</span> = PerlIO::get_layers <span class="synIdentifier">$$item</span> }; <span class="synComment"># </span><span class="synTodo">TODO:</span><span class="synComment"> try PerlIO::Layers::get_layers (leont)</span>
    <span class="synConditional">unless</span> (<span class="synIdentifier">$@</span>) {
        <span class="synIdentifier">$extra</span> .= <span class="synString">&quot;layers: </span><span class="synIdentifier">@layers</span><span class="synString">&quot;</span>;
    }
    <span class="synIdentifier">$string</span> .= <span class="synString">&quot;  (</span><span class="synIdentifier">$extra</span><span class="synString">)&quot;</span> <span class="synConditional">if</span> <span class="synIdentifier">$extra</span>;

    <span class="synIdentifier">$p-&gt;{</span><span class="synString">_tie</span><span class="synIdentifier">}</span> = <span class="synOperator">ref</span> <span class="synStatement">tied</span> *<span class="synIdentifier">$$item</span>;
    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">_unknown </span>{
    <span class="synStatement">my</span>(<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$item</span>;
    
    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;
    <span class="synIdentifier">$string</span> = colored(<span class="synIdentifier">$ref</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'unknown'</span><span class="synIdentifier">}</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_class </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$item</span>;

    <span class="synComment"># if the user specified a method to use instead, we do that</span>
    <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">class_method</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$item-&gt;can</span>(<span class="synIdentifier">$p-&gt;{</span><span class="synString">class_method</span><span class="synIdentifier">}</span>) ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span>-&gt;(<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>);
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;
    <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>++;

    <span class="synIdentifier">$string</span> .= colored(<span class="synIdentifier">$ref</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'class'</span><span class="synIdentifier">}</span>);

    <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">show_reftype</span><span class="synIdentifier">}</span> ) {
        <span class="synIdentifier">$string</span> .= <span class="synString">' ('</span> . colored(
            Scalar::Util::reftype(<span class="synIdentifier">$item</span>),
            <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'class'</span><span class="synIdentifier">}</span>
        ) . <span class="synString">')'</span>;
    }

    <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">expand</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'all'</span>
        <span class="synOperator">or</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">expand</span><span class="synIdentifier">}</span> &gt;= <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>
    ) {
        <span class="synIdentifier">$string</span> .= <span class="synString">&quot;  {</span><span class="synIdentifier">$BREAK</span><span class="synString">&quot;</span>;

        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> += <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;

        <span class="synConditional">if</span> (<span class="synIdentifier">$]</span> &gt;= <span class="synFloat">5.010</span>) {
            <span class="synStatement">require</span> mro;
        } <span class="synConditional">else</span> {
            <span class="synStatement">require</span> MRO::Compat;
        }
        <span class="synStatement">require</span> Package::Stash;

        <span class="synStatement">my</span> <span class="synIdentifier">$stash</span> = Package::Stash-&gt;new(<span class="synIdentifier">$ref</span>);

        <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">@superclasses</span> = <span class="synIdentifier">@{$stash-&gt;get_symbol</span><span class="synperlVarBlock">(</span><span class="synString">'@ISA'</span><span class="synperlVarBlock">)||[]</span><span class="synIdentifier">}</span> ) {
            <span class="synConditional">if</span> (<span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">parents</span><span class="synIdentifier">}</span>) {
                <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>)
                        . <span class="synString">'Parents       '</span>
                        . <span class="synStatement">join</span>(<span class="synString">', '</span>, <span class="synStatement">map</span> <span class="synStatement">{</span> colored(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'class'</span><span class="synIdentifier">}</span>) <span class="synStatement">}</span>
                                     <span class="synIdentifier">@superclasses</span>
                        ) . <span class="synIdentifier">$BREAK</span>;
            }

            <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">linear_isa</span><span class="synIdentifier">}</span> <span class="synOperator">and</span>
                  (
                    (<span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">linear_isa</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'auto'</span> <span class="synOperator">and</span> <span class="synIdentifier">@superclasses</span> &gt; <span class="synNumber">1</span>)
                    <span class="synOperator">or</span>
                    (<span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">linear_isa</span><span class="synIdentifier">}</span> <span class="synOperator">ne</span> <span class="synString">'auto'</span>)
                  )
            ) {
                <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>)
                        . <span class="synString">'Linear @ISA   '</span>
                        . <span class="synStatement">join</span>(<span class="synString">', '</span>, <span class="synStatement">map</span> <span class="synStatement">{</span> colored( <span class="synIdentifier">$_</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'class'</span><span class="synIdentifier">}</span>) <span class="synStatement">}</span>
                                  <span class="synIdentifier">@{</span><span class="synperlVarBlock">mro::get_linear_isa(</span><span class="synIdentifier">$ref</span><span class="synperlVarBlock">)</span><span class="synIdentifier">}</span>
                        ) . <span class="synIdentifier">$BREAK</span>;
            }
        }

        <span class="synIdentifier">$string</span> .= _show_methods(<span class="synIdentifier">$ref</span>, <span class="synIdentifier">$p</span>)
            <span class="synConditional">if</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">show_methods</span><span class="synIdentifier">}</span> <span class="synOperator">and</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">show_methods</span><span class="synIdentifier">}</span> <span class="synOperator">ne</span> <span class="synString">'none'</span>;

        <span class="synConditional">if</span> ( <span class="synIdentifier">$p-&gt;{</span><span class="synString">'class'</span><span class="synIdentifier">}-&gt;{</span><span class="synString">'internals'</span><span class="synIdentifier">}</span> ) {
            <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>)
                    . <span class="synString">'internals: '</span>;

            <span class="synStatement">local</span> <span class="synIdentifier">$p-&gt;{</span><span class="synString">_reftype</span><span class="synIdentifier">}</span> = Scalar::Util::reftype <span class="synIdentifier">$item</span>;
            <span class="synIdentifier">$string</span> .= _p(<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>);
            <span class="synIdentifier">$string</span> .= <span class="synIdentifier">$BREAK</span>;
        }

        <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> -= <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>) . <span class="synString">&quot;}&quot;</span>;
    }
    <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">_depth</span><span class="synIdentifier">}</span>--;

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}



<span class="synComment">######################################</span>
<span class="synComment">## Auxiliary (internal) subs</span>
<span class="synComment">######################################</span>

<span class="synComment"># All glory to Vincent Pit for coming up with this implementation,</span>
<span class="synComment"># to Goro Fuji for Hash::FieldHash, and of course to Michael Schwern</span>
<span class="synComment"># and his &quot;Object::ID&quot;, whose code is copied almost verbatim below.</span>
{
    fieldhash <span class="synStatement">my</span> <span class="synIdentifier">%IDs</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$Last_ID</span> = <span class="synString">&quot;a&quot;</span>;
    <span class="synKeyword">sub </span><span class="synFunction">_object_id </span>{
        <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

        <span class="synComment"># This is 15% faster than ||=</span>
        <span class="synStatement">return</span> <span class="synIdentifier">$IDs{$self}</span> <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$IDs{$self}</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$IDs{$self}</span> = ++<span class="synIdentifier">$Last_ID</span>;
    }
}


<span class="synKeyword">sub </span><span class="synFunction">_show_methods </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$ref</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$string</span> = <span class="synString">''</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$methods</span> = {
        <span class="synString">public</span> =&gt; [],
        <span class="synString">private</span> =&gt; [],
    };
    <span class="synStatement">my</span> <span class="synIdentifier">$inherited</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">inherited</span><span class="synIdentifier">}</span> || <span class="synString">'none'</span>;

    <span class="synStatement">require</span> B;

    <span class="synStatement">my</span> <span class="synIdentifier">$methods_of</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$name</span>) = <span class="synIdentifier">@_</span>;
        <span class="synStatement">map</span> <span class="synStatement">{</span>
            <span class="synStatement">my</span> <span class="synIdentifier">$m</span>;
            <span class="synConditional">if</span> (<span class="synIdentifier">$_</span>
                <span class="synOperator">and</span> <span class="synIdentifier">$m</span> = B::svref_2object(<span class="synIdentifier">$_</span>)
                <span class="synOperator">and</span> <span class="synIdentifier">$m-&gt;isa</span>(<span class="synString">'B::CV'</span>)
                <span class="synOperator">and</span> <span class="synOperator">not</span> <span class="synIdentifier">$m-&gt;GV-&gt;isa</span>(<span class="synString">'B::Special'</span>)
            ) {
                [ <span class="synIdentifier">$m-&gt;GV-&gt;STASH-&gt;NAME</span>, <span class="synIdentifier">$m-&gt;GV-&gt;NAME</span> ]
            } <span class="synConditional">else</span> {
                ()
            }
        <span class="synStatement">}</span> <span class="synStatement">values</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2">Package::Stash</span><span class="synIdentifier">-&gt;new($name)-&gt;get_all_symbols</span><span class="synperlVarBlock2">(</span><span class="synString">'CODE'</span><span class="synperlVarBlock2">)</span><span class="synIdentifier">}</span>
    };

    <span class="synStatement">my</span> <span class="synIdentifier">%seen_method_name</span>;

<span class="synLabel">METHOD:</span>
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$method</span> (
        <span class="synStatement">map</span> <span class="synIdentifier">$methods_of</span>-&gt;(<span class="synIdentifier">$_</span>), <span class="synIdentifier">@{</span><span class="synperlVarBlock">mro::get_linear_isa(</span><span class="synIdentifier">$ref</span><span class="synperlVarBlock">)</span><span class="synIdentifier">}</span>,
                               <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">universal</span><span class="synIdentifier">}</span> ? <span class="synString">'UNIVERSAL'</span> : ()
    ) {
        <span class="synStatement">my</span> (<span class="synIdentifier">$package_string</span>, <span class="synIdentifier">$method_string</span>) = <span class="synIdentifier">@$method</span>;

        <span class="synStatement">next</span> METHOD <span class="synConditional">if</span> <span class="synIdentifier">$seen_method_name{$method_string}</span>++;

        <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synStatement">substr</span>(<span class="synIdentifier">$method_string</span>, <span class="synNumber">0</span>, <span class="synNumber">1</span>) <span class="synOperator">eq</span> <span class="synString">'_'</span> ? <span class="synString">'private'</span> : <span class="synString">'public'</span>;

        <span class="synConditional">if</span> (<span class="synIdentifier">$package_string</span> <span class="synOperator">ne</span> <span class="synIdentifier">$ref</span>) {
            <span class="synStatement">next</span> METHOD <span class="synConditional">unless</span> <span class="synIdentifier">$inherited</span> <span class="synOperator">ne</span> <span class="synString">'none'</span>
                           <span class="synOperator">and</span> (<span class="synIdentifier">$inherited</span> <span class="synOperator">eq</span> <span class="synString">'all'</span> <span class="synOperator">or</span> <span class="synIdentifier">$type</span> <span class="synOperator">eq</span> <span class="synIdentifier">$inherited</span>);
            <span class="synIdentifier">$method_string</span> .= <span class="synString">' ('</span> . <span class="synIdentifier">$package_string</span> . <span class="synString">')'</span>;
        }

        <span class="synStatement">push</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$methods-&gt;{$type}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>, <span class="synIdentifier">$method_string</span>;
    }

    <span class="synComment"># render our string doing a natural sort by method name</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$show_methods</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">show_methods</span><span class="synIdentifier">}</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$type</span> (<span class="synString">qw(public private)</span>) {
        <span class="synStatement">next</span> <span class="synConditional">unless</span> <span class="synIdentifier">$show_methods</span> <span class="synOperator">eq</span> <span class="synString">'all'</span>
                 <span class="synOperator">or</span> <span class="synIdentifier">$show_methods</span> <span class="synOperator">eq</span> <span class="synIdentifier">$type</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">@list</span> = (<span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}{</span><span class="synString">sort_methods</span><span class="synIdentifier">}</span> ? nsort <span class="synIdentifier">@{$methods-&gt;{$type}}</span> : <span class="synIdentifier">@{$methods-&gt;{$type}}</span>);

        <span class="synIdentifier">$string</span> .= (<span class="synString">' '</span> x <span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span>)
                 . <span class="synString">&quot;</span><span class="synIdentifier">$type</span><span class="synString"> methods (&quot;</span> . <span class="synStatement">scalar</span> <span class="synIdentifier">@list</span> . <span class="synString">')'</span>
                 . (<span class="synIdentifier">@list</span> ? <span class="synString">' : '</span> : <span class="synString">''</span>)
                 . <span class="synStatement">join</span>(<span class="synString">', '</span>, <span class="synStatement">map</span> <span class="synStatement">{</span> colored(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{</span><span class="synString">method</span><span class="synIdentifier">}</span>) <span class="synStatement">}</span>
                              <span class="synIdentifier">@list</span>
                   ) . <span class="synIdentifier">$BREAK</span>;
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$string</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_deparse </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$item</span>, <span class="synIdentifier">$p</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">require</span> B::Deparse;
    <span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">indent</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$deparseopts</span> = [<span class="synString">&quot;-sCi</span><span class="synIdentifier">${i}</span><span class="synString">v'Useless const omitted'&quot;</span>];

    <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = <span class="synString">'sub '</span> . B::Deparse-&gt;new(<span class="synIdentifier">$deparseopts</span>)-&gt;coderef2text(<span class="synIdentifier">$item</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$pad</span> = <span class="synString">&quot;</span><span class="synSpecial">\n</span><span class="synString">&quot;</span> . (<span class="synString">' '</span> x (<span class="synIdentifier">$p-&gt;{</span><span class="synString">_current_indent</span><span class="synIdentifier">}</span> + <span class="synIdentifier">$i</span>));
    <span class="synIdentifier">$sub</span>    =~ <span class="synStatement">s/</span><span class="synSpecial">\n</span><span class="synStatement">/</span><span class="synIdentifier">$pad</span><span class="synStatement">/gse</span>;
    <span class="synStatement">return</span> <span class="synIdentifier">$sub</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_get_info_message </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$p</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@caller</span> = <span class="synStatement">caller</span> <span class="synNumber">2</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$message</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">caller_message</span><span class="synIdentifier">}</span>;

    <span class="synIdentifier">$message</span> =~ <span class="synStatement">s/</span><span class="synSpecial">\b</span><span class="synString">__PACKAGE__</span><span class="synSpecial">\b</span><span class="synStatement">/</span><span class="synIdentifier">$caller[</span><span class="synNumber">0</span><span class="synIdentifier">]</span><span class="synStatement">/g</span>;
    <span class="synIdentifier">$message</span> =~ <span class="synStatement">s/</span><span class="synSpecial">\b</span><span class="synString">__FILENAME__</span><span class="synSpecial">\b</span><span class="synStatement">/</span><span class="synIdentifier">$caller[</span><span class="synNumber">1</span><span class="synIdentifier">]</span><span class="synStatement">/g</span>;
    <span class="synIdentifier">$message</span> =~ <span class="synStatement">s/</span><span class="synSpecial">\b</span><span class="synString">__LINE__</span><span class="synSpecial">\b</span><span class="synStatement">/</span><span class="synIdentifier">$caller[</span><span class="synNumber">2</span><span class="synIdentifier">]</span><span class="synStatement">/g</span>;

    <span class="synStatement">return</span> colored(<span class="synIdentifier">$message</span>, <span class="synIdentifier">$p-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}{</span><span class="synString">caller_info</span><span class="synIdentifier">}</span>) . <span class="synIdentifier">$BREAK</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">_merge </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$p</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$clone</span> = clone <span class="synIdentifier">$properties</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$p</span>) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$key</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%$p</span>) {
            <span class="synConditional">if</span> (<span class="synIdentifier">$key</span> <span class="synOperator">eq</span> <span class="synString">'color'</span> <span class="synOperator">or</span> <span class="synIdentifier">$key</span> <span class="synOperator">eq</span> <span class="synString">'colour'</span>) {
                <span class="synStatement">my</span> <span class="synIdentifier">$color</span> = <span class="synIdentifier">$p-&gt;{$key}</span>;
                <span class="synConditional">if</span> ( <span class="synOperator">not</span> <span class="synOperator">ref</span> <span class="synIdentifier">$color</span> <span class="synOperator">or</span> <span class="synOperator">ref</span> <span class="synIdentifier">$color</span> <span class="synOperator">ne</span> <span class="synString">'HASH'</span> ) {
                    Carp::carp <span class="synString">q['color' should be a HASH reference. Did you mean 'colored'?]</span>;
                    <span class="synIdentifier">$clone-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}</span> = {};
                }
                <span class="synConditional">else</span> {
                    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$target</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%$color</span> ) {
                        <span class="synIdentifier">$clone-&gt;{</span><span class="synString">color</span><span class="synIdentifier">}-&gt;{$target}</span> = <span class="synIdentifier">$p-&gt;{$key}-&gt;{$target}</span>;
                    }
                }
            }
            <span class="synConditional">elsif</span> (<span class="synIdentifier">$key</span> <span class="synOperator">eq</span> <span class="synString">'class'</span>) {
                <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$item</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%{$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}}</span> ) {
                    <span class="synIdentifier">$clone-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}-&gt;{$item}</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">class</span><span class="synIdentifier">}-&gt;{$item}</span>;
                }
            }
            <span class="synConditional">elsif</span> (<span class="synIdentifier">$key</span> <span class="synOperator">eq</span> <span class="synString">'filters'</span>) {
                <span class="synStatement">my</span> <span class="synIdentifier">$val</span> = <span class="synIdentifier">$p-&gt;{$key}</span>;

                <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$item</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%$val</span>) {
                    <span class="synStatement">my</span> <span class="synIdentifier">$filters</span> = <span class="synIdentifier">$val-&gt;{$item}</span>;

                    <span class="synComment"># EXPERIMENTAL: filters in modules</span>
                    <span class="synConditional">if</span> (<span class="synIdentifier">$item</span> <span class="synOperator">eq</span> <span class="synString">'-external'</span>) {
                        <span class="synStatement">my</span> <span class="synIdentifier">@external</span> = ( <span class="synOperator">ref</span>(<span class="synIdentifier">$filters</span>) ? <span class="synIdentifier">@$filters</span> : (<span class="synIdentifier">$filters</span>) );

                        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> ( <span class="synIdentifier">@external</span> ) {
                            <span class="synStatement">my</span> <span class="synIdentifier">$module</span> = <span class="synString">&quot;Data::Printer::Filter::</span><span class="synIdentifier">$class</span><span class="synString">&quot;</span>;
                            <span class="synStatement">eval</span> <span class="synString">&quot;use </span><span class="synIdentifier">$module</span><span class="synString">&quot;</span>;
                            <span class="synConditional">if</span> (<span class="synIdentifier">$@</span>) {
                                <span class="synStatement">warn</span> <span class="synString">&quot;Error loading filter '</span><span class="synIdentifier">$module</span><span class="synString">': </span><span class="synIdentifier">$@</span><span class="synString">&quot;</span>;
                            }
                            <span class="synConditional">else</span> {
                                <span class="synStatement">my</span> <span class="synIdentifier">%from_module</span> = <span class="synIdentifier">%{$module-&gt;_filter_list}</span>;
                                <span class="synStatement">my</span> <span class="synIdentifier">%extras</span>      = <span class="synIdentifier">%{$module-&gt;_extra_options}</span>;

                                <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$k</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%from_module</span>) {
                                    <span class="synStatement">unshift</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$clone-&gt;{</span><span class="synString">filters</span><span class="synIdentifier">}-&gt;{$k}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>, <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$from_module{$k}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
                                    <span class="synIdentifier">$clone-&gt;{</span><span class="synString">_seen_override</span><span class="synIdentifier">}{$k}</span> = <span class="synNumber">1</span>
                                        <span class="synConditional">if</span> <span class="synIdentifier">$extras{$k}{</span><span class="synString">show_repeated</span><span class="synIdentifier">}</span>;
                                }
                            }
                        }
                    }
                    <span class="synConditional">else</span> {
                        <span class="synStatement">my</span> <span class="synIdentifier">@filter_list</span> = ( <span class="synOperator">ref</span> <span class="synIdentifier">$filters</span> <span class="synOperator">eq</span> <span class="synString">'CODE'</span> ? ( <span class="synIdentifier">$filters</span> ) : <span class="synIdentifier">@$filters</span> );
                        <span class="synStatement">unshift</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$clone-&gt;{</span><span class="synString">filters</span><span class="synIdentifier">}-&gt;{$item}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>, <span class="synIdentifier">@filter_list</span>;
                    }
                }
            }
            <span class="synConditional">elsif</span> (<span class="synIdentifier">$key</span> <span class="synOperator">eq</span> <span class="synString">'output'</span>) {
                <span class="synStatement">my</span> <span class="synIdentifier">$out</span> = <span class="synIdentifier">$p-&gt;{</span><span class="synString">output</span><span class="synIdentifier">}</span>;
                <span class="synStatement">my</span> <span class="synIdentifier">$ref</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$out</span>;

                <span class="synIdentifier">$clone-&gt;{</span><span class="synString">output</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$out</span>;

                <span class="synStatement">my</span> <span class="synIdentifier">%output_target</span> = (
                     <span class="synString">stdout</span> =&gt; *STDOUT,
                     <span class="synString">stderr</span> =&gt; *STDERR,
                );

                <span class="synStatement">my</span> <span class="synIdentifier">$error</span>;
                <span class="synConditional">if</span> (!<span class="synIdentifier">$ref</span> <span class="synOperator">and</span> <span class="synStatement">exists</span> <span class="synIdentifier">$output_target{</span><span class="synperlVarMember"> </span><span class="synStatement">lc</span><span class="synperlVarMember"> </span><span class="synIdentifier">$out</span><span class="synperlVarMember"> </span><span class="synIdentifier">}</span>) {
                    <span class="synIdentifier">$clone-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$output_target{</span><span class="synperlVarMember"> </span><span class="synStatement">lc</span><span class="synperlVarMember"> </span><span class="synIdentifier">$out</span><span class="synperlVarMember"> </span><span class="synIdentifier">}</span>;
                }
                <span class="synConditional">elsif</span> ( ( <span class="synIdentifier">$ref</span> <span class="synOperator">and</span> <span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synString">'GLOB'</span>)
                     <span class="synOperator">or</span> (!<span class="synIdentifier">$ref</span> <span class="synOperator">and</span> \<span class="synIdentifier">$out</span> =~ <span class="synStatement">/</span><span class="synString">GLOB</span><span class="synSpecial">\([^()]+\)</span><span class="synString">$</span><span class="synStatement">/</span>)
                ) {
                    <span class="synIdentifier">$clone-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$out</span>;
                }
                <span class="synConditional">elsif</span> ( !<span class="synIdentifier">$ref</span> <span class="synOperator">or</span> <span class="synIdentifier">$ref</span> <span class="synOperator">eq</span> <span class="synString">'SCALAR'</span> ) {
                    <span class="synConditional">if</span>( <span class="synStatement">open</span> <span class="synStatement">my</span> <span class="synIdentifier">$fh</span>, <span class="synString">'&gt;&gt;'</span>, <span class="synIdentifier">$out</span> ) {
                        <span class="synIdentifier">$clone-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$fh</span>;
                    }
                    <span class="synConditional">else</span> {
                        <span class="synIdentifier">$error</span> = <span class="synNumber">1</span>;
                    }
                }
                <span class="synConditional">else</span> {
                    <span class="synIdentifier">$error</span> = <span class="synNumber">1</span>;
                }

                <span class="synConditional">if</span> (<span class="synIdentifier">$error</span>) {
                    Carp::carp <span class="synString">'Error opening custom output handle.'</span>;
                    <span class="synIdentifier">$clone-&gt;{</span><span class="synString">_output</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$output_target{</span><span class="synperlVarMember"> </span><span class="synString">'stderr'</span><span class="synperlVarMember"> </span><span class="synIdentifier">}</span>;
                }
            }
            <span class="synConditional">else</span> {
                <span class="synIdentifier">$clone-&gt;{$key}</span> = <span class="synIdentifier">$p-&gt;{$key}</span>;
            }
        }
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$clone</span>;
}


<span class="synKeyword">sub </span><span class="synFunction">_load_rc_file </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$args</span> = <span class="synStatement">shift</span> || {};

    <span class="synStatement">my</span> <span class="synIdentifier">$file</span> = <span class="synStatement">exists</span> <span class="synIdentifier">$args-&gt;{</span><span class="synString">rc_file</span><span class="synIdentifier">}</span>    ? <span class="synIdentifier">$args-&gt;{</span><span class="synString">rc_file</span><span class="synIdentifier">}</span>
             : <span class="synStatement">exists</span> <span class="synIdentifier">$ENV{</span><span class="synString">DATAPRINTERRC</span><span class="synIdentifier">}</span> ? <span class="synIdentifier">$ENV{</span><span class="synString">DATAPRINTERRC</span><span class="synIdentifier">}</span>
             : File::Spec-&gt;catfile(File::HomeDir-&gt;my_home,<span class="synString">'.dataprinter'</span>);

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synStatement">-e</span> <span class="synIdentifier">$file</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$mode</span> = (<span class="synStatement">stat</span> <span class="synIdentifier">$file</span> )[<span class="synNumber">2</span>];
    <span class="synConditional">if</span> (<span class="synIdentifier">$^O</span> !~ <span class="synStatement">/</span><span class="synString">Win32</span><span class="synStatement">/i</span> &amp;&amp; (<span class="synIdentifier">$mode</span> &amp; <span class="synNumber">0020</span> || <span class="synIdentifier">$mode</span> &amp; <span class="synNumber">0002</span>) ) {
        <span class="synStatement">warn</span> <span class="synString">&quot;rc file '</span><span class="synIdentifier">$file</span><span class="synString">' must NOT be writeable to other users. Skipping.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synConditional">if</span> ( <span class="synStatement">-l</span> <span class="synIdentifier">$file</span> || (!<span class="synStatement">-f</span> _) || <span class="synStatement">-p</span> _ || <span class="synStatement">-S</span> _ || <span class="synStatement">-b</span> _ || <span class="synStatement">-c</span> _ ) {
        <span class="synStatement">warn</span> <span class="synString">&quot;rc file '</span><span class="synIdentifier">$file</span><span class="synString">' doesn't look like a plain file. Skipping.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synConditional">unless</span> (<span class="synStatement">-o</span> <span class="synIdentifier">$file</span>) {
        <span class="synStatement">warn</span> <span class="synString">&quot;rc file '</span><span class="synIdentifier">$file</span><span class="synString">' must be owned by your (effective) user. Skipping.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synConditional">if</span> ( <span class="synStatement">open</span> <span class="synStatement">my</span> <span class="synIdentifier">$fh</span>, <span class="synString">'&lt;'</span>, <span class="synIdentifier">$file</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$rc_data</span>;
        { <span class="synStatement">local</span> <span class="synIdentifier">$/</span>; <span class="synIdentifier">$rc_data</span> = &lt;<span class="synIdentifier">$fh</span>&gt; }
        <span class="synStatement">close</span> <span class="synIdentifier">$fh</span>;

        <span class="synConditional">if</span>( <span class="synIdentifier">${</span><span class="synperlVarBlock">^TAINT</span><span class="synIdentifier">}</span> != <span class="synNumber">0</span> ) {
            <span class="synConditional">if</span> ( <span class="synIdentifier">$args-&gt;{</span><span class="synString">allow_tainted</span><span class="synIdentifier">}</span> ) {
                <span class="synStatement">warn</span> <span class="synString">&quot;WARNING: Reading tainted file '</span><span class="synIdentifier">$file</span><span class="synString">' due to user override.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
                <span class="synIdentifier">$rc_data</span> =~ <span class="synStatement">/</span><span class="synSpecial">(.+)</span><span class="synStatement">/s</span>; <span class="synComment"># very bad idea - god help you</span>
                <span class="synIdentifier">$rc_data</span> = <span class="synIdentifier">$1</span>;
            }
            <span class="synConditional">else</span> {
                <span class="synStatement">warn</span> <span class="synString">&quot;taint mode on: skipping rc file '</span><span class="synIdentifier">$file</span><span class="synString">'.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
                <span class="synStatement">return</span>;
            }
        }

        <span class="synStatement">my</span> <span class="synIdentifier">$config</span> = <span class="synStatement">eval</span> <span class="synIdentifier">$rc_data</span>;
        <span class="synConditional">if</span> ( <span class="synIdentifier">$@</span> ) {
            <span class="synStatement">warn</span> <span class="synString">&quot;Error loading </span><span class="synIdentifier">$file</span><span class="synString">: </span><span class="synIdentifier">$@</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        }
        <span class="synConditional">elsif</span> (!<span class="synOperator">ref</span> <span class="synIdentifier">$config</span> <span class="synOperator">or</span> <span class="synOperator">ref</span> <span class="synIdentifier">$config</span> <span class="synOperator">ne</span> <span class="synString">'HASH'</span>) {
            <span class="synStatement">warn</span> <span class="synString">&quot;Error loading </span><span class="synIdentifier">$file</span><span class="synString">: config file must return a hash reference</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        }
        <span class="synConditional">else</span> {
            <span class="synIdentifier">$properties</span> = _merge( <span class="synIdentifier">$config</span> );
        }
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">warn</span> <span class="synString">&quot;error opening '</span><span class="synIdentifier">$file</span><span class="synString">': </span><span class="synIdentifier">$!</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
    }
}


<span class="synNumber">1</span>;
<span class="synComment">__END__</span>

<span class="synStatement">=encoding</span><span class="synString"> utf8</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Data::Printer - colored pretty-print of Perl data structures and objects</span>

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synperlPOD">Want to see what's inside a variable in a complete, colored</span>
<span class="synperlPOD">and human-friendly way?</span>

<span class="synPreProc">  use Data::Printer;   # or just &quot;use DDP&quot; for short</span>
<span class="synPreProc">  </span>
<span class="synPreProc">  p @array;            # no need to pass references</span>

<span class="synperlPOD">Code above might output something like this (with colors!):</span>

<span class="synPreProc">   [</span>
<span class="synPreProc">       [0] &quot;a&quot;,</span>
<span class="synPreProc">       [1] &quot;b&quot;,</span>
<span class="synPreProc">       [2] undef,</span>
<span class="synPreProc">       [3] &quot;c&quot;,</span>
<span class="synPreProc">   ]</span>

<span class="synperlPOD">You can also inspect objects:</span>

<span class="synPreProc">    my $obj = SomeClass-&gt;new;</span>

<span class="synPreProc">    p($obj);</span>

<span class="synperlPOD">Which might give you something like:</span>

<span class="synPreProc">  \ SomeClass  {</span>
<span class="synPreProc">      Parents       Moose::Object</span>
<span class="synPreProc">      Linear @ISA   SomeClass, Moose::Object</span>
<span class="synPreProc">      public methods (3) : bar, foo, meta</span>
<span class="synPreProc">      private methods (0)</span>
<span class="synPreProc">      internals: {</span>
<span class="synPreProc">         _something =&gt; 42,</span>
<span class="synPreProc">      }</span>
<span class="synPreProc">  }</span>

<span class="synperlPOD">Data::Printer is fully customizable. If you want to change how things</span>
<span class="synperlPOD">are displayed, or even its standard behavior. Take a look at the</span>
<span class="synIdentifier">L&lt;&lt; available customizations|/&quot;CUSTOMIZATION&quot; &gt;&gt;</span><span class="synperlPOD">. Once you figure out</span>
<span class="synperlPOD">your own preferences, create a</span>
<span class="synIdentifier">L&lt;&lt; configuration file|/&quot;CONFIGURATION FILE (RUN CONTROL)&quot; &gt;&gt;</span><span class="synperlPOD"> for</span>
<span class="synperlPOD">yourself and Data::Printer will automatically use it!</span>

<span class="synperlPOD">B&lt;&lt; That's about it! Feel free to stop reading now and start dumping</span>
<span class="synperlPOD">your data structures! For more information, including feature set,</span>
<span class="synperlPOD">how to create filters, and general tips, just keep reading :) &gt;&gt;</span>

<span class="synperlPOD">Oh, if you are just experimenting and/or don't want to use a</span>
<span class="synperlPOD">configuration file, you can set all options during initialization,</span>
<span class="synperlPOD">including coloring, identation and filters!</span>

<span class="synPreProc">  use Data::Printer {</span>
<span class="synPreProc">      color =&gt; {</span>
<span class="synPreProc">         'regex' =&gt; 'blue',</span>
<span class="synPreProc">         'hash'  =&gt; 'yellow',</span>
<span class="synPreProc">      },</span>
<span class="synPreProc">      filters =&gt; {</span>
<span class="synPreProc">         'DateTime' =&gt; sub { $_[0]-&gt;ymd },</span>
<span class="synPreProc">         'SCALAR'   =&gt; sub { &quot;oh noes, I found a scalar! $_[0]&quot; },</span>
<span class="synPreProc">      },</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">The first </span><span class="synIdentifier">C&lt;{}&gt;</span><span class="synperlPOD"> block is just syntax sugar, you can safely ommit it</span>
<span class="synperlPOD">if it makes things easier to read:</span>

<span class="synPreProc">  use DDP colored =&gt; 1;</span>

<span class="synPreProc">  use Data::Printer  deparse =&gt; 1, sort_keys =&gt; 0;</span>


<span class="synStatement">=head1</span><span class="synString"> FEATURES</span>

<span class="synperlPOD">Here's what Data::Printer has to offer to Perl developers, out of the box:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> * Very sane defaults (I hope!)</span>

<span class="synStatement">=item</span><span class="synString"> * Highly customizable (in case you disagree with me :)</span>

<span class="synStatement">=item</span><span class="synString"> * Colored output by default</span>

<span class="synStatement">=item</span><span class="synString"> * Human-friendly output, with array index and custom separators</span>

<span class="synStatement">=item</span><span class="synString"> * Full object dumps including methods, inheritance and internals</span>

<span class="synStatement">=item</span><span class="synString"> * Exposes extra information such as tainted data and weak references</span>

<span class="synStatement">=item</span><span class="synString"> * Ability to easily create filters for objects and regular structures</span>

<span class="synStatement">=item</span><span class="synString"> * Ability to load settings from a </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synString"> file so you don't have to write anything other than &quot;use DDP;&quot; in your code!</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> RATIONALE</span>

<span class="synperlPOD">Data::Dumper is a fantastic tool, meant to stringify data structures</span>
<span class="synperlPOD">in a way they are suitable for being </span><span class="synIdentifier">C&lt;eval&gt;</span><span class="synperlPOD">'ed back in.</span>

<span class="synperlPOD">The thing is, a lot of people keep using it (and similar ones,</span>
<span class="synperlPOD">like Data::Dump) to print data structures and objects on screen</span>
<span class="synperlPOD">for inspection and debugging, and while you </span><span class="synIdentifier">B&lt;can&gt;</span><span class="synperlPOD"> use those</span>
<span class="synperlPOD">modules for that, it doesn't mean mean you </span><span class="synIdentifier">B&lt;should&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">This is where Data::Printer comes in. It is meant to do one thing</span>
<span class="synperlPOD">and one thing only:</span>

<span class="synperlPOD">I&lt;&lt; display Perl variables and objects on screen, properly</span>
<span class="synperlPOD">formatted &gt;&gt; (to be inspected by a human)</span>

<span class="synperlPOD">If you want to serialize/store/restore Perl data structures,</span>
<span class="synperlPOD">this module will NOT help you. Try </span><span class="synIdentifier">L&lt;Storable&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">L&lt;Data::Dumper&gt;</span><span class="synperlPOD">,</span>
<span class="synIdentifier">L&lt;JSON&gt;</span><span class="synperlPOD">, or whatever. CPAN is full of such solutions!</span>

<span class="synStatement">=head1</span><span class="synString"> THE p() FUNCTION</span>

<span class="synperlPOD">Once you load Data::Printer, the </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function will be imported</span>
<span class="synperlPOD">into your namespace and available to you. It will pretty-print</span>
<span class="synperlPOD">into STDERR (or any other output target) whatever variabe you pass to it.</span>

<span class="synStatement">=head2</span><span class="synString"> Changing output targets</span>

<span class="synperlPOD">By default, </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> will be set to use STDERR. As of version 0.27, you</span>
<span class="synperlPOD">can set up the 'output' property so Data::Printer outputs to</span>
<span class="synperlPOD">several different places:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;&lt; output =&gt; 'stderr' &gt;&gt;</span><span class="synString"> - Standard error. Same as *STDERR</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;&lt; output =&gt; 'stdout' &gt;&gt;</span><span class="synString"> - Standard output. Same as *STDOUT</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;&lt; output =&gt; $filename &gt;&gt;</span><span class="synString"> - Appends to filename.</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;&lt; output =&gt; $file_handle &gt;&gt;</span><span class="synString"> - Appends to opened handle</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;&lt; output =&gt; \$scalar &gt;&gt;</span><span class="synString"> - Appends to that variable's content</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Return Value</span>

<span class="synperlPOD">If for whatever reason you want to mangle with the output string</span>
<span class="synperlPOD">instead of printing it, you can simply ask for a return</span>
<span class="synperlPOD">value:</span>

<span class="synPreProc">  # move to a string</span>
<span class="synPreProc">  my $string = p @some_array;</span>

<span class="synPreProc">  # output to STDOUT instead of STDERR;</span>
<span class="synPreProc">  print p(%some_hash);</span>

<span class="synperlPOD">Note that, in this case, Data::Printer will not colorize the</span>
<span class="synperlPOD">returned string unless you explicitly set the </span><span class="synIdentifier">C&lt;colored&gt;</span><span class="synperlPOD"> option to 1:</span>

<span class="synPreProc">  print p(%some_hash, colored =&gt; 1); # now with colors!</span>

<span class="synperlPOD">You can - and should - of course, set this during you &quot;</span><span class="synIdentifier">C&lt;use&gt;</span><span class="synperlPOD">&quot; call:</span>

<span class="synPreProc">  use Data::Printer colored =&gt; 1;</span>
<span class="synPreProc">  print p( %some_hash );  # will be colored</span>

<span class="synperlPOD">Or by adding the setting to your </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> file.</span>

<span class="synperlPOD">As most of Data::Printer, the return value is also configurable. You</span>
<span class="synperlPOD">do this by setting the </span><span class="synIdentifier">C&lt;return_value&gt;</span><span class="synperlPOD"> option. There are three options</span>
<span class="synperlPOD">available:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;'dump'&gt;</span><span class="synString"> (default):</span>

<span class="synPreProc">    p %var;               # prints the dump to STDERR (void context)</span>
<span class="synPreProc">    my $string = p %var;  # returns the dump *without* printing</span>

<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;'void'&gt;</span><span class="synString">:</span>

<span class="synPreProc">    p %var;               # prints the dump to STDERR, never returns.</span>
<span class="synPreProc">    my $string = p %var;  # $string is undef. Data still printed in STDERR</span>


<span class="synStatement">=item</span><span class="synString"> * </span><span class="synIdentifier">C&lt;'pass'&gt;</span><span class="synString">:</span>

<span class="synPreProc">    p %var;               # prints the dump to STDERR, returns %var</span>
<span class="synPreProc">    my %copy = p %var;    # %copy = %var. Data still printed in STDERR</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> COLORS AND COLORIZATION</span>

<span class="synperlPOD">Below are all the available colorizations and their default values.</span>
<span class="synperlPOD">Note that both spellings ('color' and 'colour') will work.</span>

<span class="synPreProc">   use Data::Printer {</span>
<span class="synPreProc">     color =&gt; {</span>
<span class="synPreProc">        array       =&gt; 'bright_white',  # array index numbers</span>
<span class="synPreProc">        number      =&gt; 'bright_blue',   # numbers</span>
<span class="synPreProc">        string      =&gt; 'bright_yellow', # strings</span>
<span class="synPreProc">        class       =&gt; 'bright_green',  # class names</span>
<span class="synPreProc">        method      =&gt; 'bright_green',  # method names</span>
<span class="synPreProc">        undef       =&gt; 'bright_red',    # the 'undef' value</span>
<span class="synPreProc">        hash        =&gt; 'magenta',       # hash keys</span>
<span class="synPreProc">        regex       =&gt; 'yellow',        # regular expressions</span>
<span class="synPreProc">        code        =&gt; 'green',         # code references</span>
<span class="synPreProc">        glob        =&gt; 'bright_cyan',   # globs (usually file handles)</span>
<span class="synPreProc">        vstring     =&gt; 'bright_blue',   # version strings (v5.16.0, etc)</span>
<span class="synPreProc">        repeated    =&gt; 'white on_red',  # references to seen values</span>
<span class="synPreProc">        caller_info =&gt; 'bright_cyan',   # details on what's being printed</span>
<span class="synPreProc">        weak        =&gt; 'cyan',          # weak references</span>
<span class="synPreProc">        tainted     =&gt; 'red',           # tainted content</span>
<span class="synPreProc">        escaped     =&gt; 'bright_red',    # escaped characters (\t, \n, etc)</span>

<span class="synPreProc">        # potential new Perl datatypes, unknown to Data::Printer</span>
<span class="synPreProc">        unknown     =&gt; 'bright_yellow on_blue',</span>
<span class="synPreProc">     },</span>
<span class="synPreProc">   };</span>

<span class="synperlPOD">Don't fancy colors? Disable them with:</span>

<span class="synPreProc">  use Data::Printer colored =&gt; 0;</span>

<span class="synperlPOD">By default, 'colored' is set to </span><span class="synIdentifier">C&lt;&quot;auto&quot;&gt;</span><span class="synperlPOD">, which means Data::Printer</span>
<span class="synperlPOD">will colorize only when not being used to return the dump string,</span>
<span class="synperlPOD">nor when the output (default: STDERR) is being piped. If you're not</span>
<span class="synperlPOD">seeing colors, try forcing it with:</span>

<span class="synPreProc">  use Data::Printer colored =&gt; 1;</span>

<span class="synperlPOD">Also worth noticing that Data::Printer </span><span class="synIdentifier">I&lt;will&gt;</span><span class="synperlPOD"> honor the</span>
<span class="synIdentifier">C&lt;ANSI_COLORS_DISABLED&gt;</span><span class="synperlPOD"> environment variable unless you force a</span>
<span class="synperlPOD">colored output by setting 'colored' to 1.</span>

<span class="synperlPOD">Remember to put your preferred settings in the </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> file</span>
<span class="synperlPOD">so you never have to type them at all!</span>


<span class="synStatement">=head1</span><span class="synString"> ALIASING</span>

<span class="synperlPOD">Data::Printer provides the nice, short, </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function to dump your</span>
<span class="synperlPOD">data structures and objects. In case you rather use a more explicit</span>
<span class="synperlPOD">name, already have a </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function (why?) in your code and want</span>
<span class="synperlPOD">to avoid clashing, or are just used to other function names for that</span>
<span class="synperlPOD">purpose, you can easily rename it:</span>

<span class="synPreProc">  use Data::Printer alias =&gt; 'Dumper';</span>

<span class="synPreProc">  Dumper( %foo );</span>


<span class="synStatement">=head1</span><span class="synString"> CUSTOMIZATION</span>

<span class="synperlPOD">I tried to provide sane defaults for Data::Printer, so you'll never have</span>
<span class="synperlPOD">to worry about anything other than typing </span><span class="synIdentifier">C&lt;&lt; &quot;p( $var )&quot; &gt;&gt;</span><span class="synperlPOD"> in your code.</span>
<span class="synperlPOD">That said, and besides coloring and filtering, there are several other</span>
<span class="synperlPOD">customization options available, as shown below (with default values):</span>

<span class="synPreProc">  use Data::Printer {</span>
<span class="synPreProc">      name           =&gt; 'var',   # name to display on cyclic references</span>
<span class="synPreProc">      indent         =&gt; 4,       # how many spaces in each indent</span>
<span class="synPreProc">      hash_separator =&gt; '   ',   # what separates keys from values</span>
<span class="synPreProc">      colored        =&gt; 'auto',  # colorize output (1 for always, 0 for never)</span>
<span class="synPreProc">      index          =&gt; 1,       # display array indices</span>
<span class="synPreProc">      multiline      =&gt; 1,       # display in multiple lines (see note below)</span>
<span class="synPreProc">      max_depth      =&gt; 0,       # how deep to traverse the data (0 for all)</span>
<span class="synPreProc">      sort_keys      =&gt; 1,       # sort hash keys</span>
<span class="synPreProc">      deparse        =&gt; 0,       # use B::Deparse to expand (expose) subroutines</span>
<span class="synPreProc">      show_tied      =&gt; 1,       # expose tied variables</span>
<span class="synPreProc">      show_tainted   =&gt; 1,       # expose tainted variables</span>
<span class="synPreProc">      show_weak      =&gt; 1,       # expose weak references</span>
<span class="synPreProc">      show_readonly  =&gt; 0,       # expose scalar variables marked as read-only</span>
<span class="synPreProc">      show_lvalue    =&gt; 1,       # expose lvalue types</span>
<span class="synPreProc">      print_escapes  =&gt; 0,       # print non-printable chars as &quot;\n&quot;, &quot;\t&quot;, etc.</span>
<span class="synPreProc">      quote_keys     =&gt; 'auto',  # quote hash keys (1 for always, 0 for never).</span>
<span class="synPreProc">                                 # 'auto' will quote when key is empty/space-only.</span>
<span class="synPreProc">      separator      =&gt; ',',     # uses ',' to separate array/hash elements</span>
<span class="synPreProc">      end_separator  =&gt; 0,       # prints the separator after last element in array/hash.</span>
<span class="synPreProc">                                 # the default is 0 that means not to print</span>

<span class="synPreProc">      caller_info    =&gt; 0,       # include information on what's being printed</span>
<span class="synPreProc">      use_prototypes =&gt; 1,       # allow p(%foo), but prevent anonymous data</span>
<span class="synPreProc">      return_value   =&gt; 'dump',  # what should p() return? See 'Return Value' above.</span>
<span class="synPreProc">      output         =&gt; 'stderr',# where to print the output. See</span>
<span class="synPreProc">                                 # 'Changing output targets' above.</span>

<span class="synPreProc">      class_method   =&gt; '_data_printer', # make classes aware of Data::Printer</span>
<span class="synPreProc">                                         # and able to dump themselves.</span>

<span class="synPreProc">      class =&gt; {</span>
<span class="synPreProc">          internals  =&gt; 1,       # show internal data structures of classes</span>

<span class="synPreProc">          inherited  =&gt; 'none',  # show inherited methods,</span>
<span class="synPreProc">                                 # can also be 'all', 'private', or 'public'.</span>

<span class="synPreProc">          universal  =&gt; 1,       # include UNIVERSAL methods in inheritance list</span>

<span class="synPreProc">          parents    =&gt; 1,       # show parents, if there are any</span>
<span class="synPreProc">          linear_isa =&gt; 'auto',  # show the entire @ISA, linearized, whenever</span>
<span class="synPreProc">                                 # the object has more than one parent. Can</span>
<span class="synPreProc">                                 # also be set to 1 (always show) or 0 (never).</span>

<span class="synPreProc">          expand     =&gt; 1,       # how deep to traverse the object (in case</span>
<span class="synPreProc">                                 # it contains other objects). Defaults to</span>
<span class="synPreProc">                                 # 1, meaning expand only itself. Can be any</span>
<span class="synPreProc">                                 # number, 0 for no class expansion, and 'all'</span>
<span class="synPreProc">                                 # to expand everything.</span>

<span class="synPreProc">          sort_methods =&gt; 1,     # sort public and private methods</span>

<span class="synPreProc">          show_methods =&gt; 'all'  # method list. Also 'none', 'public', 'private'</span>
<span class="synPreProc">      },</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">Note: setting </span><span class="synIdentifier">C&lt;multiline&gt;</span><span class="synperlPOD"> to </span><span class="synIdentifier">C&lt;0&gt;</span><span class="synperlPOD"> will also set </span><span class="synIdentifier">C&lt;index&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;indent&gt;</span><span class="synperlPOD"> to </span><span class="synIdentifier">C&lt;0&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head1</span><span class="synString"> FILTERS</span>

<span class="synperlPOD">Data::Printer offers you the ability to use filters to override</span>
<span class="synperlPOD">any kind of data display. The filters are placed on a hash,</span>
<span class="synperlPOD">where keys are the types - or class names - and values</span>
<span class="synperlPOD">are anonymous subs that receive two arguments: the item itself</span>
<span class="synperlPOD">as first parameter, and the properties hashref (in case your</span>
<span class="synperlPOD">filter wants to read from it). This lets you quickly override</span>
<span class="synperlPOD">the way Data::Printer handles and displays data types and, in</span>
<span class="synperlPOD">particular, objects.</span>

<span class="synPreProc">  use Data::Printer filters =&gt; {</span>
<span class="synPreProc">            'DateTime'      =&gt; sub { $_[0]-&gt;ymd },</span>
<span class="synPreProc">            'HTTP::Request' =&gt; sub { $_[0]-&gt;uri },</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">Perl types are named as </span><span class="synIdentifier">C&lt;ref&gt;</span><span class="synperlPOD"> calls them: </span><span class="synIdentifier">I&lt;SCALAR&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">I&lt;ARRAY&gt;</span><span class="synperlPOD">,</span>
<span class="synIdentifier">I&lt;HASH&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">I&lt;REF&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">I&lt;CODE&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">I&lt;Regexp&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">I&lt;GLOB&gt;</span><span class="synperlPOD">. As for objects,</span>
<span class="synperlPOD">just use the class' name, as shown above.</span>

<span class="synperlPOD">As of version 0.13, you may also use the '-class' filter, which</span>
<span class="synperlPOD">will be called for all non-perl types (objects).</span>

<span class="synperlPOD">Your filters are supposed to return a defined value (usually, the</span>
<span class="synperlPOD">string you want to print). If you don't, Data::Printer will</span>
<span class="synperlPOD">let the next filter of that same type have a go, or just fallback</span>
<span class="synperlPOD">to the defaults. You can also use an array reference to pass more</span>
<span class="synperlPOD">than one filter for the same type or class.</span>

<span class="synIdentifier">B&lt;Note&gt;</span><span class="synperlPOD">: If you plan on calling </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> from </span><span class="synIdentifier">I&lt;within&gt;</span><span class="synperlPOD"> an inline</span>
<span class="synperlPOD">filter, please make sure you are passing only REFERENCES as</span>
<span class="synperlPOD">arguments. See </span><span class="synIdentifier">L&lt;/CAVEATS&gt;</span><span class="synperlPOD"> below.</span>

<span class="synperlPOD">You may also like to specify standalone filter modules. Please</span>
<span class="synperlPOD">see </span><span class="synIdentifier">L&lt;Data::Printer::Filter&gt;</span><span class="synperlPOD"> for further information on a more</span>
<span class="synperlPOD">powerful filter interface for Data::Printer, including useful</span>
<span class="synperlPOD">filters that are shipped as part of this distribution.</span>

<span class="synStatement">=head1</span><span class="synString"> MAKING YOUR CLASSES DDP-AWARE (WITHOUT ADDING ANY DEPS)</span>

<span class="synperlPOD">Whenever printing the contents of a class, Data::Printer first</span>
<span class="synperlPOD">checks to see if that class implements a sub called '_data_printer'</span>
<span class="synperlPOD">(or whatever you set the &quot;class_method&quot; option to in your settings,</span>
<span class="synperlPOD">see </span><span class="synIdentifier">L&lt;/CUSTOMIZATION&gt;</span><span class="synperlPOD"> below).</span>

<span class="synperlPOD">If a sub with that exact name is available in the target object,</span>
<span class="synperlPOD">Data::Printer will use it to get the string to print instead of</span>
<span class="synperlPOD">making a regular class dump.</span>

<span class="synperlPOD">This means you could have the following in one of your classes:</span>

<span class="synPreProc">  sub _data_printer {</span>
<span class="synPreProc">      my ($self, $properties) = @_;</span>
<span class="synPreProc">      return 'Hey, no peeking! But foo contains ' . $self-&gt;foo;</span>
<span class="synPreProc">  }</span>

<span class="synperlPOD">Notice you don't have to depend on Data::Printer at all, just</span>
<span class="synperlPOD">write your sub and it will use that to pretty-print your objects.</span>

<span class="synperlPOD">If you want to use colors and filter helpers, and still not</span>
<span class="synperlPOD">add Data::Printer to your dependencies, remember you can import</span>
<span class="synperlPOD">them during runtime:</span>

<span class="synPreProc">  sub _data_printer {</span>
<span class="synPreProc">      require Data::Printer::Filter;</span>
<span class="synPreProc">      Data::Printer::Filter-&gt;import;</span>

<span class="synPreProc">      # now we have 'indent', outdent', 'linebreak', 'p' and 'colored'</span>
<span class="synPreProc">      my ($self, $properties) = @_;</span>
<span class="synPreProc">      ...</span>
<span class="synPreProc">  }</span>

<span class="synperlPOD">Having a filter for that particular class will of course override</span>
<span class="synperlPOD">this setting.</span>


<span class="synStatement">=head1</span><span class="synString"> CONFIGURATION FILE (RUN CONTROL)</span>

<span class="synperlPOD">Data::Printer tries to let you easily customize as much as possible</span>
<span class="synperlPOD">regarding the visualization of your data structures and objects.</span>
<span class="synperlPOD">But we don't want you to keep repeating yourself every time you</span>
<span class="synperlPOD">want to use it!</span>

<span class="synperlPOD">To avoid this, you can simply create a file called </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> in</span>
<span class="synperlPOD">your home directory (usually </span><span class="synIdentifier">C&lt;/home/username&gt;</span><span class="synperlPOD"> in Linux), and put</span>
<span class="synperlPOD">your configuration hash reference in there.</span>

<span class="synperlPOD">This way, instead of doing something like:</span>

<span class="synPreProc">   use Data::Printer {</span>
<span class="synPreProc">     colour =&gt; {</span>
<span class="synPreProc">        array =&gt; 'bright_blue',</span>
<span class="synPreProc">     },</span>
<span class="synPreProc">     filters =&gt; {</span>
<span class="synPreProc">         'Catalyst::Request' =&gt; sub {</span>
<span class="synPreProc">             my $req = shift;</span>
<span class="synPreProc">             return &quot;Cookies: &quot; . p($req-&gt;cookies)</span>
<span class="synPreProc">         },</span>
<span class="synPreProc">     },</span>
<span class="synPreProc">   };</span>

<span class="synperlPOD">You can create a .dataprinter file that looks like this:</span>

<span class="synPreProc">   {</span>
<span class="synPreProc">     colour =&gt; {</span>
<span class="synPreProc">        array =&gt; 'bright_blue',</span>
<span class="synPreProc">     },</span>
<span class="synPreProc">     filters =&gt; {</span>
<span class="synPreProc">         'Catalyst::Request' =&gt; sub {</span>
<span class="synPreProc">             my $req = shift;</span>
<span class="synPreProc">             return &quot;Cookies: &quot; . p($req-&gt;cookies)</span>
<span class="synPreProc">         },</span>
<span class="synPreProc">     },</span>
<span class="synPreProc">   };</span>

<span class="synperlPOD">Note that all we did was remove the &quot;use Data::Printer&quot; bit when</span>
<span class="synperlPOD">writing the </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> file. From then on all you have to do</span>
<span class="synperlPOD">while debugging scripts is:</span>

<span class="synPreProc">  use Data::Printer;</span>

<span class="synperlPOD">and it will load your custom settings every time :)</span>

<span class="synStatement">=head2</span><span class="synString"> Loading RC files in custom locations</span>

<span class="synperlPOD">If your RC file is somewhere other than </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> in your home</span>
<span class="synperlPOD">dir, you can load whichever file you want via the </span><span class="synIdentifier">C&lt;'rc_file'&gt;</span><span class="synperlPOD"> parameter:</span>

<span class="synPreProc">  use Data::Printer rc_file =&gt; '/path/to/my/rcfile.conf';</span>

<span class="synperlPOD">You can even set this to undef or to a non-existing file to disable your</span>
<span class="synperlPOD">RC file at will.</span>

<span class="synperlPOD">The RC file location can also be specified with the </span><span class="synIdentifier">C&lt;DATAPRINTERRC&gt;</span>
<span class="synperlPOD">environment variable. Using </span><span class="synIdentifier">C&lt;rc_file&gt;</span><span class="synperlPOD"> in code will override the environment</span>
<span class="synperlPOD">variable.</span>

<span class="synStatement">=head2</span><span class="synString"> RC File Security</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> RC file is nothing but a Perl hash that</span>
<span class="synperlPOD">gets </span><span class="synIdentifier">C&lt;eval&gt;</span><span class="synperlPOD">'d back into the code. This means that whatever</span>
<span class="synperlPOD">is in your RC file </span><span class="synIdentifier">B&lt;WILL BE INTERPRETED BY PERL AT RUNTIME&gt;</span><span class="synperlPOD">.</span>
<span class="synperlPOD">This can be quite worrying if you're not the one in control</span>
<span class="synperlPOD">of the RC file.</span>

<span class="synperlPOD">For this reason, Data::Printer takes extra precaution before</span>
<span class="synperlPOD">loading the file:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> * The file has to be in your home directory unless you</span>
<span class="synperlPOD">specifically point elsewhere via the '</span><span class="synIdentifier">C&lt;rc_file&gt;</span><span class="synperlPOD">' property or</span>
<span class="synperlPOD">the DATAPRINTERRC environment variable;</span>

<span class="synStatement">=item</span><span class="synString"> * The file </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synString"> be a plain file, never a symbolic</span>
<span class="synperlPOD">link, named pipe or socket;</span>

<span class="synStatement">=item</span><span class="synString"> * The file </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synString"> be owned by you (i.e. the effective</span>
<span class="synperlPOD">user id that ran the script using Data::Printer);</span>

<span class="synStatement">=item</span><span class="synString"> * The file </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synString"> be read-only for everyone but your user.</span>
<span class="synperlPOD">This usually means permissions </span><span class="synIdentifier">C&lt;0644&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;0640&gt;</span><span class="synperlPOD"> or </span><span class="synIdentifier">C&lt;0600&gt;</span><span class="synperlPOD"> in</span>
<span class="synperlPOD">Unix-like systems. </span><span class="synIdentifier">B&lt;THIS IS NOT CHECKED IN WIN32&gt;</span><span class="synperlPOD">;</span>

<span class="synStatement">=item</span><span class="synString"> * The file will </span><span class="synIdentifier">B&lt;NOT&gt;</span><span class="synString"> be loaded in Taint mode, unless</span>
<span class="synperlPOD">you specifically load Data::Printer with the 'allow_tainted'</span>
<span class="synperlPOD">option set to true. And even if you do that, Data::Printer</span>
<span class="synperlPOD">will still issue a warning before loading the file. But</span>
<span class="synperlPOD">seriously, don't do that.</span>

<span class="synStatement">=back</span>

<span class="synperlPOD">Failure to comply with the security rules above will result in</span>
<span class="synperlPOD">the RC file not being loaded (likely with a warning on what went</span>
<span class="synperlPOD">wrong).</span>


<span class="synStatement">=head1</span><span class="synString"> THE &quot;DDP&quot; PACKAGE ALIAS</span>

<span class="synperlPOD">You're likely to add/remove Data::Printer from source code being</span>
<span class="synperlPOD">developed and debugged all the time, and typing it might feel too</span>
<span class="synperlPOD">long. Because of this, the 'DDP' package is provided as a shorter</span>
<span class="synperlPOD">alias to Data::Printer:</span>

<span class="synPreProc">   use DDP;</span>
<span class="synPreProc">   p %some_var;</span>

<span class="synStatement">=head1</span><span class="synString"> CALLER INFORMATION</span>

<span class="synperlPOD">If you set caller_info to a true value, Data::Printer will prepend</span>
<span class="synperlPOD">every call with an informational message. For example:</span>

<span class="synPreProc">  use Data::Printer caller_info =&gt; 1;</span>

<span class="synPreProc">  my $var = 42;</span>
<span class="synPreProc">  p $var;</span>

<span class="synperlPOD">will output something like:</span>

<span class="synPreProc">  Printing in line 4 of myapp.pl:</span>
<span class="synPreProc">  42</span>

<span class="synperlPOD">The default message is </span><span class="synIdentifier">C&lt;&lt; 'Printing in line __LINE__ of __FILENAME__:' &gt;&gt;</span><span class="synperlPOD">.</span>
<span class="synperlPOD">The special strings </span><span class="synIdentifier">C&lt;__LINE__&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;__FILENAME__&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;__PACKAGE__&gt;</span><span class="synperlPOD"> will</span>
<span class="synperlPOD">be interpolated into their according value so you can customize them at will:</span>

<span class="synPreProc">  use Data::Printer</span>
<span class="synPreProc">    caller_info =&gt; 1,</span>
<span class="synPreProc">    caller_message =&gt; &quot;Okay, __PACKAGE__, let's dance!&quot;</span>
<span class="synPreProc">    color =&gt; {</span>
<span class="synPreProc">        caller_info =&gt; 'bright_red',</span>
<span class="synPreProc">    };</span>

<span class="synperlPOD">As shown above, you may also set a color for &quot;caller_info&quot; in your color</span>
<span class="synperlPOD">hash. Default is cyan.</span>


<span class="synStatement">=head1</span><span class="synString"> EXPERIMENTAL FEATURES</span>

<span class="synperlPOD">The following are volatile parts of the API which are subject to</span>
<span class="synperlPOD">change at any given version. Use them at your own risk.</span>

<span class="synStatement">=head2</span><span class="synString"> Local Configuration (experimental!)</span>

<span class="synperlPOD">You can override global configurations by writing them as the second</span>
<span class="synperlPOD">parameter for </span><span class="synIdentifier">p()</span><span class="synperlPOD">. For example:</span>

<span class="synPreProc">  p( %var, color =&gt; { hash =&gt; 'green' } );</span>


<span class="synStatement">=head2</span><span class="synString"> Filter classes</span>

<span class="synperlPOD">As of Data::Printer 0.11, you can create complex filters as a separate</span>
<span class="synperlPOD">module. Those can even be uploaded to CPAN and used by other people!</span>
<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Data::Printer::Filter&gt;</span><span class="synperlPOD"> for further information.</span>

<span class="synStatement">=head1</span><span class="synString"> CAVEATS</span>

<span class="synperlPOD">You can't pass more than one variable at a time.</span>

<span class="synPreProc">   p($foo, $bar); # wrong</span>
<span class="synPreProc">   p($foo);       # right</span>
<span class="synPreProc">   p($bar);       # right</span>

<span class="synperlPOD">The default mode is to use prototypes, in which you are supposed to pass</span>
<span class="synperlPOD">variables, not anonymous structures:</span>

<span class="synPreProc">   p( { foo =&gt; 'bar' } ); # wrong</span>

<span class="synPreProc">   p %somehash;        # right</span>
<span class="synPreProc">   p $hash_ref;        # also right</span>

<span class="synperlPOD">To pass anonymous structures, set &quot;use_prototypes&quot; option to 0. But</span>
<span class="synperlPOD">remember you'll have to pass your variables as references:</span>

<span class="synPreProc">   use Data::Printer use_prototypes =&gt; 0;</span>

<span class="synPreProc">   p( { foo =&gt; 'bar' } ); # was wrong, now is right.</span>

<span class="synPreProc">   p( %foo  ); # was right, but fails without prototypes</span>
<span class="synPreProc">   p( \%foo ); # do this instead</span>

<span class="synperlPOD">If you are using inline filters, and calling </span><span class="synIdentifier">p()</span><span class="synperlPOD"> (or whatever name you</span>
<span class="synperlPOD">aliased it to) from inside those filters, you </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synperlPOD"> pass the arguments</span>
<span class="synperlPOD">to </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> as a reference:</span>

<span class="synPreProc">  use Data::Printer {</span>
<span class="synPreProc">      filters =&gt; {</span>
<span class="synPreProc">          ARRAY =&gt; sub {</span>
<span class="synPreProc">              my $listref = shift;</span>
<span class="synPreProc">              my $string = '';</span>
<span class="synPreProc">              foreach my $item (@$listref) {</span>
<span class="synPreProc">                  $string .= p( \$item );      # p( $item ) will not work!</span>
<span class="synPreProc">              }</span>
<span class="synPreProc">              return $string;</span>
<span class="synPreProc">          },</span>
<span class="synPreProc">      },</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">This happens because your filter function is compiled </span><span class="synIdentifier">I&lt;before&gt;</span><span class="synperlPOD"> Data::Printer</span>
<span class="synperlPOD">itself loads, so the filter does not see the function prototype. As a way</span>
<span class="synperlPOD">to avoid unpleasant surprises, if you forget to pass a reference, Data::Printer</span>
<span class="synperlPOD">will generate an exception for you with the following message:</span>

<span class="synPreProc">    'When calling p() without prototypes, please pass arguments as references'</span>

<span class="synperlPOD">Another way to avoid this is to use the much more complete </span><span class="synIdentifier">L&lt;Data::Printer::Filter&gt;</span>
<span class="synperlPOD">interface for standalone filters.</span>

<span class="synStatement">=head1</span><span class="synString"> EXTRA TIPS</span>

<span class="synStatement">=head2</span><span class="synString"> Circumventing prototypes</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function uses prototypes by default, allowing you to say:</span>

<span class="synPreProc">  p %var;</span>

<span class="synperlPOD">instead of always having to pass references, like:</span>

<span class="synPreProc">  p \%var;</span>

<span class="synperlPOD">There are cases, however, where you may want to pass anonymous</span>
<span class="synperlPOD">structures, like:</span>

<span class="synPreProc">  p { foo =&gt; $bar };   # this blows up, don't use</span>

<span class="synperlPOD">and because of prototypes, you can't. If this is your case, just</span>
<span class="synperlPOD">set &quot;use_prototypes&quot; option to 0. Note, with this option,</span>
<span class="synperlPOD">you </span><span class="synIdentifier">B&lt;will&gt;</span><span class="synperlPOD"> have to pass your variables as references:</span>

<span class="synPreProc">  use Data::Printer use_prototypes =&gt; 0;</span>

<span class="synPreProc">   p { foo =&gt; 'bar' }; # doesn't blow up anymore, works just fine.</span>

<span class="synPreProc">   p %var;  # but now this blows up...</span>
<span class="synPreProc">   p \%var; # ...so do this instead</span>

<span class="synPreProc">   p [ $foo, $bar, \@baz ]; # this way you can even pass</span>
<span class="synPreProc">                            # several variables at once</span>

<span class="synperlPOD">Versions prior to 0.17 don't have the &quot;use_prototypes&quot; option. If</span>
<span class="synperlPOD">you're stuck in an older version you can write </span><span class="synIdentifier">C&lt;&amp;p()&gt;</span><span class="synperlPOD"> instead of </span><span class="synIdentifier">C&lt;p()&gt;</span>
<span class="synperlPOD">to circumvent prototypes and pass elements (including anonymous variables)</span>
<span class="synperlPOD">as </span><span class="synIdentifier">B&lt;REFERENCES&gt;</span><span class="synperlPOD">. This notation, however, requires enclosing parentheses:</span>

<span class="synPreProc">  &amp;p( { foo =&gt; $bar } );        # this is ok, use at will</span>
<span class="synPreProc">  &amp;p( \&quot;DEBUGGING THIS BIT&quot; );  # this works too</span>

<span class="synperlPOD">Or you could just create a very simple wrapper function:</span>

<span class="synPreProc">  sub pp { p @_ };</span>

<span class="synperlPOD">And use it just as you use </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head2</span><span class="synString"> Minding the return value of p()</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Matt S. Trout (mst)) &gt;&gt;</span>

<span class="synperlPOD">There is a reason why explicit return statements are recommended unless</span>
<span class="synperlPOD">you know what you're doing. By default, Data::Printer's return value</span>
<span class="synperlPOD">depends on how it was called. When not in void context, it returns the</span>
<span class="synperlPOD">serialized form of the dump.</span>

<span class="synperlPOD">It's tempting to trust your own </span><span class="synIdentifier">p()</span><span class="synperlPOD"> calls with that approach, but if</span>
<span class="synperlPOD">this is your </span><span class="synIdentifier">I&lt;last&gt;</span><span class="synperlPOD"> statement in a function, you should keep in mind</span>
<span class="synperlPOD">your debugging code will behave differently depending on how your</span>
<span class="synperlPOD">function was called!</span>

<span class="synperlPOD">To prevent that, set the </span><span class="synIdentifier">C&lt;return_value&gt;</span><span class="synperlPOD"> property to either 'void'</span>
<span class="synperlPOD">or 'pass'. You won't be able to retrieve the dumped string but, hey,</span>
<span class="synperlPOD">who does that anyway :)</span>

<span class="synperlPOD">Assuming you have set the pass-through ('pass') property in your</span>
<span class="synIdentifier">C&lt;.dataprinter&gt;</span><span class="synperlPOD"> file, another stunningly useful thing you can do with it</span>
<span class="synperlPOD">is change code that says:</span>

<span class="synPreProc">   return $obj-&gt;foo;</span>

<span class="synperlPOD">with:</span>

<span class="synPreProc">   use DDP;</span>

<span class="synPreProc">   return p $obj-&gt;foo;</span>

<span class="synperlPOD">You can even add it to chained calls if you wish to see the dump of</span>
<span class="synperlPOD">a particular state, changing this:</span>

<span class="synPreProc">   $obj-&gt;foo-&gt;bar-&gt;baz;</span>

<span class="synperlPOD">to:</span>

<span class="synPreProc">   $obj-&gt;foo-&gt;DDP::p-&gt;bar-&gt;baz</span>

<span class="synperlPOD">And things will &quot;Just Work&quot;.</span>


<span class="synStatement">=head2</span><span class="synString"> Using p() in some/all of your loaded modules</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Matt S. Trout (mst)) &gt;&gt;</span>

<span class="synperlPOD">While debugging your software, you may want to use Data::Printer in</span>
<span class="synperlPOD">some or all loaded modules and not bother having to load it in</span>
<span class="synperlPOD">each and every one of them. To do this, in any module loaded by</span>
<span class="synIdentifier">C&lt;myapp.pl&gt;</span><span class="synperlPOD">, simply write:</span>

<span class="synPreProc">  ::p( @myvar );  # note the '::' in front of p()</span>

<span class="synperlPOD">Then call your program like:</span>

<span class="synPreProc">  perl -MDDP myapp.pl</span>

<span class="synperlPOD">This also has the great advantage that if you leave one </span><span class="synIdentifier">p()</span><span class="synperlPOD"> call</span>
<span class="synperlPOD">in by accident, it will fail without the -M, making it easier to spot :)</span>

<span class="synperlPOD">If you really want to have </span><span class="synIdentifier">p()</span><span class="synperlPOD"> imported into your loaded</span>
<span class="synperlPOD">modules, use the next tip instead.</span>

<span class="synStatement">=head2</span><span class="synString"> Adding p() to all your loaded modules</span>

<span class="synIdentifier">I&lt;&lt; (contributed by rpd Szsz) &gt;&gt;</span>

<span class="synperlPOD">If you wish to automatically add Data::Printer's </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function to</span>
<span class="synperlPOD">every loaded module in you app, you can do something like this to</span>
<span class="synperlPOD">your main program:</span>

<span class="synPreProc">    BEGIN {</span>
<span class="synPreProc">        {</span>
<span class="synPreProc">            no strict 'refs';</span>
<span class="synPreProc">            require Data::Printer;</span>
<span class="synPreProc">            my $alias = 'p';</span>
<span class="synPreProc">            foreach my $package ( keys %main:: ) {</span>
<span class="synPreProc">                if ( $package =~ m/::$/ ) {</span>
<span class="synPreProc">                    *{ $package . $alias } = \&amp;Data::Printer::p;</span>
<span class="synPreProc">                }</span>
<span class="synPreProc">            }</span>
<span class="synPreProc">        }</span>
<span class="synPreProc">    }</span>

<span class="synIdentifier">B&lt;WARNING&gt;</span><span class="synperlPOD"> This will override all locally defined subroutines/methods that</span>
<span class="synperlPOD">are named </span><span class="synIdentifier">C&lt;p&gt;</span><span class="synperlPOD">, if they exist, in every loaded module. If you already</span>
<span class="synperlPOD">have a subroutine named '</span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD">', be sure to change </span><span class="synIdentifier">C&lt;$alias&gt;</span><span class="synperlPOD"> to</span>
<span class="synperlPOD">something custom.</span>

<span class="synperlPOD">If you rather avoid namespace manipulation altogether, use the previous</span>
<span class="synperlPOD">tip instead.</span>

<span class="synStatement">=head2</span><span class="synString"> Using Data::Printer from the Perl debugger</span>

<span class="synIdentifier">I&lt;&lt; (contributed by rpd Szsz and Marcel Grnauer (hanekomu)) &gt;&gt;</span>

<span class="synperlPOD">With </span><span class="synIdentifier">L&lt;DB::Pluggable&gt;</span><span class="synperlPOD">, you can easily set the perl debugger to use</span>
<span class="synperlPOD">Data::Printer to print variable information, replacing the debugger's</span>
<span class="synperlPOD">standard </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function. All you have to do is add these lines to</span>
<span class="synperlPOD">your </span><span class="synIdentifier">C&lt;.perldb&gt;</span><span class="synperlPOD"> file:</span>

<span class="synPreProc">  use DB::Pluggable;</span>
<span class="synPreProc">  DB::Pluggable-&gt;run_with_config( \'[DataPrinter]' );  # note the '\'</span>

<span class="synperlPOD">Then call the perl debugger as you normally would:</span>

<span class="synPreProc">  perl -d myapp.pl</span>

<span class="synperlPOD">Now Data::Printer's </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> command will be used instead of the debugger's!</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;perldebug&gt;</span><span class="synperlPOD"> for more information on how to use the perl debugger, and</span>
<span class="synIdentifier">L&lt;DB::Pluggable&gt;</span><span class="synperlPOD"> for extra functionality and other plugins.</span>

<span class="synperlPOD">If you can't or don't wish to use DB::Pluggable, or simply want to keep</span>
<span class="synperlPOD">the debugger's </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function and add an extended version using</span>
<span class="synperlPOD">Data::Printer (let's call it </span><span class="synIdentifier">C&lt;px()&gt;</span><span class="synperlPOD"> for instance), you can add these</span>
<span class="synperlPOD">lines to your </span><span class="synIdentifier">C&lt;.perldb&gt;</span><span class="synperlPOD"> file instead:</span>

<span class="synPreProc">    $DB::alias{px} = 's/px/DB::px/';</span>
<span class="synPreProc">    sub px {</span>
<span class="synPreProc">        my $expr = shift;</span>
<span class="synPreProc">        require Data::Printer;</span>
<span class="synPreProc">        print Data::Printer::p($expr);</span>
<span class="synPreProc">    }</span>

<span class="synperlPOD">Now, inside the Perl debugger, you can pass as reference to </span><span class="synIdentifier">C&lt;px&gt;</span><span class="synperlPOD"> expressions</span>
<span class="synperlPOD">to be dumped using Data::Printer.</span>

<span class="synStatement">=head2</span><span class="synString"> Using Data::Printer in a perl shell (REPL)</span>

<span class="synperlPOD">Some people really enjoy using a REPL shell to quickly try Perl code. One</span>
<span class="synperlPOD">of the most famous ones out there is </span><span class="synIdentifier">L&lt;Devel::REPL&gt;</span><span class="synperlPOD">. If you use it, now</span>
<span class="synperlPOD">you can also see its output with Data::Printer!</span>

<span class="synperlPOD">Just install </span><span class="synIdentifier">L&lt;Devel::REPL::Plugin::DataPrinter&gt;</span><span class="synperlPOD"> and add the following</span>
<span class="synperlPOD">line to your re.pl configuration file (usually &quot;.re.pl/repl.rc&quot; in your</span>
<span class="synperlPOD">home dir):</span>

<span class="synPreProc">  load_plugin('DataPrinter');</span>

<span class="synperlPOD">The next time you run </span><span class="synIdentifier">C&lt;re.pl&gt;</span><span class="synperlPOD">, it should dump all your REPL using</span>
<span class="synperlPOD">Data::Printer!</span>

<span class="synStatement">=head2</span><span class="synString"> Easily rendering Data::Printer's output as HTML</span>

<span class="synperlPOD">To turn Data::Printer's output into HTML, you can do something like:</span>

<span class="synPreProc">  use HTML::FromANSI;</span>
<span class="synPreProc">  use Data::Printer;</span>
<span class="synPreProc">  </span>
<span class="synPreProc">  my $html_output = ansi2html( p($object, colored =&gt; 1) );</span>

<span class="synperlPOD">In the example above, the </span><span class="synIdentifier">C&lt;$html_output&gt;</span><span class="synperlPOD"> variable contains the</span>
<span class="synperlPOD">HTML escaped output of </span><span class="synIdentifier">C&lt;p($object)&gt;</span><span class="synperlPOD">, so you can print it for</span>
<span class="synperlPOD">later inspection or render it (if it's a web app).</span>

<span class="synStatement">=head2</span><span class="synString"> Using Data::Printer with Template Toolkit</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Stephen Thirlwall (sdt)) &gt;&gt;</span>

<span class="synperlPOD">If you use Template Toolkit and want to dump your variables using Data::Printer,</span>
<span class="synperlPOD">install the </span><span class="synIdentifier">L&lt;Template::Plugin::DataPrinter&gt;</span><span class="synperlPOD"> module and load it in your template:</span>

<span class="synPreProc">   [% USE DataPrinter %]</span>

<span class="synperlPOD">The provided methods match those of </span><span class="synIdentifier">C&lt;Template::Plugin::Dumper&gt;</span><span class="synperlPOD">:</span>

<span class="synPreProc">   ansi-colored dump of the data structure in &quot;myvar&quot;:</span>
<span class="synPreProc">   [% DataPrinter.dump( myvar ) %]</span>

<span class="synPreProc">   html-formatted, colored dump of the same data structure:</span>
<span class="synPreProc">   [% DataPrinter.dump_html( myvar ) %]</span>

<span class="synperlPOD">The module allows several customization options, even letting you load it as a</span>
<span class="synperlPOD">complete drop-in replacement for Template::Plugin::Dumper so you don't even have</span>
<span class="synperlPOD">to change your previous templates!</span>

<span class="synStatement">=head2</span><span class="synString"> Unified interface for Data::Printer and other debug formatters</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Kevin McGrath (catlgrep)) &gt;&gt;</span>

<span class="synperlPOD">If you are porting your code to use Data::Printer instead of</span>
<span class="synperlPOD">Data::Dumper or similar, you can just replace:</span>

<span class="synPreProc">  use Data::Dumper;</span>

<span class="synperlPOD">with:</span>

<span class="synPreProc">  use Data::Printer alias =&gt; 'Dumper';</span>
<span class="synPreProc">  # use Data::Dumper;</span>

<span class="synperlPOD">making sure to provide Data::Printer with the proper alias for the</span>
<span class="synperlPOD">previous dumping function.</span>

<span class="synperlPOD">If, however, you want a really unified approach where you can easily</span>
<span class="synperlPOD">flip between debugging outputs, use </span><span class="synIdentifier">L&lt;Any::Renderer&gt;</span><span class="synperlPOD"> and its plugins,</span>
<span class="synperlPOD">like </span><span class="synIdentifier">L&lt;Any::Renderer::Data::Printer&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head2</span><span class="synString"> Printing stack traces with arguments expanded using Data::Printer</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Sergey Aleynikov (randir)) &gt;&gt;</span>

<span class="synperlPOD">There are times where viewing the current state of a variable is not</span>
<span class="synperlPOD">enough, and you want/need to see a full stack trace of a function call.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">L&lt;Devel::PrettyTrace&gt;</span><span class="synperlPOD"> module uses Data::Printer to provide you just</span>
<span class="synperlPOD">that. It exports a </span><span class="synIdentifier">C&lt;bt()&gt;</span><span class="synperlPOD"> function that pretty-prints detailed information</span>
<span class="synperlPOD">on each function in your stack, making it easier to spot any issues!</span>

<span class="synStatement">=head2</span><span class="synString"> Troubleshooting apps in real time without changing a single line of your code</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Marcel Grnauer (hanekomu)) &gt;&gt;</span>

<span class="synIdentifier">L&lt;dip&gt;</span><span class="synperlPOD"> is a dynamic instrumentation framework for troubleshooting Perl</span>
<span class="synperlPOD">programs, similar to </span><span class="synIdentifier">L&lt;DTrace|http://opensolaris.org/os/community/dtrace/&gt;</span><span class="synperlPOD">.</span>
<span class="synperlPOD">In a nutshell, </span><span class="synIdentifier">C&lt;dip&gt;</span><span class="synperlPOD"> lets you create probes for certain conditions</span>
<span class="synperlPOD">in your application that, once met, will perform a specific action. Since</span>
<span class="synperlPOD">it uses Aspect-oriented programming, it's very lightweight and you only</span>
<span class="synperlPOD">pay for what you use.</span>

<span class="synIdentifier">C&lt;dip&gt;</span><span class="synperlPOD"> can be very useful since it allows you to debug your software</span>
<span class="synperlPOD">without changing a single line of your original code. And Data::Printer</span>
<span class="synperlPOD">comes bundled with it, so you can use the </span><span class="synIdentifier">C&lt;p()&gt;</span><span class="synperlPOD"> function to view your</span>
<span class="synperlPOD">data structures too!</span>

<span class="synPreProc">   # Print a stack trace every time the name is changed,</span>
<span class="synPreProc">   # except when reading from the database.</span>
<span class="synPreProc">   dip -e 'before { print longmess(p $_-&gt;{args}[1]) if $_-&gt;{args}[1] }</span>
<span class="synPreProc">     call &quot;MyObj::name&quot; &amp; !cflow(&quot;MyObj::read&quot;)' myapp.pl</span>

<span class="synperlPOD">You can check you </span><span class="synIdentifier">L&lt;dip&gt;</span><span class="synperlPOD">'s own documentation for more information and options.</span>

<span class="synStatement">=head2</span><span class="synString"> Sample output for color fine-tuning</span>

<span class="synIdentifier">I&lt;&lt; (contributed by Yanick Champoux (yanick)) &gt;&gt;</span>

<span class="synperlPOD">The &quot;examples/try_me.pl&quot; file included in this distribution has a sample</span>
<span class="synperlPOD">dump with a complex data structure to let you quickly test color schemes.</span>

<span class="synStatement">=head2</span><span class="synString"> creating fiddling filters</span>

<span class="synIdentifier">I&lt;&lt; (contributed by dirk) &gt;&gt;</span>

<span class="synperlPOD">Sometimes, you may want to take advantage of Data::Printer's original dump,</span>
<span class="synperlPOD">but add/change some of the original data to enhance your debugging ability.</span>
<span class="synperlPOD">Say, for example, you have an </span><span class="synIdentifier">C&lt;HTTP::Response&gt;</span><span class="synperlPOD"> object you want to print</span>
<span class="synperlPOD">but the content is encoded. The basic approach, of course, would be to</span>
<span class="synperlPOD">just dump the decoded content:</span>

<span class="synPreProc">  use DDP filter {</span>
<span class="synPreProc">    'HTTP::Response' =&gt; sub { p( \shift-&gt;decoded_content, %{shift} );</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">But what if you want to see the rest of the original object? Dumping it</span>
<span class="synperlPOD">would be a no-go, because you would just recurse forever in your own filter.</span>

<span class="synperlPOD">Never fear! When you create a filter in Data::Printer, you're not replacing</span>
<span class="synperlPOD">the original one, you're just stacking yours on top of it. To forward your data</span>
<span class="synperlPOD">to the original filter, all you have to do is return an undefined value. This</span>
<span class="synperlPOD">means you can rewrite your </span><span class="synIdentifier">C&lt;HTTP::Response&gt;</span><span class="synperlPOD"> filter like so, if you want:</span>

<span class="synPreProc">  use DDP filters =&gt; {</span>
<span class="synPreProc">    'HTTP::Response' =&gt; sub {</span>
<span class="synPreProc">      my ($res, $p) = @_;</span>

<span class="synPreProc">      # been here before? Switch to original handler</span>
<span class="synPreProc">      return if exists $res-&gt;{decoded_content};</span>

<span class="synPreProc">      # first timer? Come on in!</span>
<span class="synPreProc">      my $clone = $res-&gt;clone;</span>
<span class="synPreProc">      $clone-&gt;{decoded_content} = $clone-&gt;decoded_content;</span>
<span class="synPreProc">      return p($clone, %$p);</span>
<span class="synPreProc">    }</span>
<span class="synPreProc">  };</span>

<span class="synperlPOD">And voil! Your fiddling filter now works like a charm :)</span>

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

<span class="synperlPOD">If you find any, please file a bug report.</span>


<span class="synStatement">=head1</span><span class="synString"> SEE ALSO</span>

<span class="synIdentifier">L&lt;Data::Dumper&gt;</span>

<span class="synIdentifier">L&lt;Data::Dump&gt;</span>

<span class="synIdentifier">L&lt;Data::Dumper::Concise&gt;</span>

<span class="synIdentifier">L&lt;Data::Dump::Streamer&gt;</span>

<span class="synIdentifier">L&lt;Data::PrettyPrintObjects&gt;</span>

<span class="synIdentifier">L&lt;Data::TreeDumper&gt;</span>


<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

<span class="synperlPOD">Breno G. de Oliveira </span><span class="synIdentifier">C&lt;&lt; &lt;garu at cpan.org&gt; &gt;&gt;</span>

<span class="synStatement">=head1</span><span class="synString"> CONTRIBUTORS</span>

<span class="synperlPOD">Many thanks to everyone that helped design and develop this module</span>
<span class="synperlPOD">with patches, bug reports, wishlists, comments and tests. They are</span>
<span class="synperlPOD">(alphabetically):</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> * Allan Whiteford</span>

<span class="synStatement">=item</span><span class="synString"> * Andreas Knig</span>

<span class="synStatement">=item</span><span class="synString"> * Andy Bach</span>

<span class="synStatement">=item</span><span class="synString"> * rpd Szsz</span>

<span class="synStatement">=item</span><span class="synString"> * brian d foy</span>

<span class="synStatement">=item</span><span class="synString"> * Chris Prather (perigrin)</span>

<span class="synStatement">=item</span><span class="synString"> * David Golden (xdg)</span>

<span class="synStatement">=item</span><span class="synString"> * David Raab</span>

<span class="synStatement">=item</span><span class="synString"> * Damien Krotkine (dams)</span>

<span class="synStatement">=item</span><span class="synString"> * Denis Howe</span>

<span class="synStatement">=item</span><span class="synString"> * Dotan Dimet</span>

<span class="synStatement">=item</span><span class="synString"> * Eden Cardim (edenc)</span>

<span class="synStatement">=item</span><span class="synString"> * Elliot Shank (elliotjs)</span>

<span class="synStatement">=item</span><span class="synString"> * Fernando Corra (SmokeMachine)</span>

<span class="synStatement">=item</span><span class="synString"> * Fitz Elliott</span>

<span class="synStatement">=item</span><span class="synString"> * Ivan Bessarabov (bessarabv)</span>

<span class="synStatement">=item</span><span class="synString"> * J Mash</span>

<span class="synStatement">=item</span><span class="synString"> * Jesse Luehrs (doy)</span>

<span class="synStatement">=item</span><span class="synString"> * Joel Berger (jberger)</span>

<span class="synStatement">=item</span><span class="synString"> * Kartik Thakore (kthakore)</span>

<span class="synStatement">=item</span><span class="synString"> * Kevin Dawson (bowtie)</span>

<span class="synStatement">=item</span><span class="synString"> * Kevin McGrath (catlgrep)</span>

<span class="synStatement">=item</span><span class="synString"> * Kip Hampton (ubu)</span>

<span class="synStatement">=item</span><span class="synString"> * Marcel Grnauer (hanekomu)</span>

<span class="synStatement">=item</span><span class="synString"> * Matt S. Trout (mst)</span>

<span class="synStatement">=item</span><span class="synString"> * Maxim Vuets</span>

<span class="synStatement">=item</span><span class="synString"> * Mike Doherty (doherty)</span>

<span class="synStatement">=item</span><span class="synString"> * Paul Evans (LeoNerd)</span>

<span class="synStatement">=item</span><span class="synString"> * Przemysaw Wesoek (jest)</span>

<span class="synStatement">=item</span><span class="synString"> * Rebecca Turner (iarna)</span>

<span class="synStatement">=item</span><span class="synString"> * Rob Hoelz (hoelzro)</span>

<span class="synStatement">=item</span><span class="synString"> * Sebastian Willing (Sewi)</span>

<span class="synStatement">=item</span><span class="synString"> * Sergey Aleynikov (randir)</span>

<span class="synStatement">=item</span><span class="synString"> * Stanislaw Pusep (syp)</span>

<span class="synStatement">=item</span><span class="synString"> * Stephen Thirlwall (sdt)</span>

<span class="synStatement">=item</span><span class="synString"> * sugyan</span>

<span class="synStatement">=item</span><span class="synString"> * Tatsuhiko Miyagawa (miyagawa)</span>

<span class="synStatement">=item</span><span class="synString"> * Tim Heaney (oylenshpeegul)</span>

<span class="synStatement">=item</span><span class="synString"> * Torsten Raudssus (Getty)</span>

<span class="synStatement">=item</span><span class="synString"> * Wesley Dal`Col (blabos)</span>

<span class="synStatement">=item</span><span class="synString"> * Yanick Champoux (yanick)</span>

<span class="synStatement">=back</span>

<span class="synperlPOD">If I missed your name, please drop me a line!</span>


<span class="synStatement">=head1</span><span class="synString"> LICENSE AND COPYRIGHT</span>

<span class="synperlPOD">Copyright 2011 Breno G. de Oliveira </span><span class="synIdentifier">C&lt;&lt; &lt;garu at cpan.org&gt; &gt;&gt;</span><span class="synperlPOD">. All rights reserved.</span>

<span class="synperlPOD">This module is free software; you can redistribute it and/or modify it</span>
<span class="synperlPOD">under the same terms as Perl itself. See </span><span class="synIdentifier">L&lt;perlartistic&gt;</span><span class="synperlPOD">.</span>



<span class="synStatement">=head1</span><span class="synString"> DISCLAIMER OF WARRANTY</span>

<span class="synperlPOD">BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY</span>
<span class="synperlPOD">FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN</span>
<span class="synperlPOD">OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES</span>
<span class="synperlPOD">PROVIDE THE SOFTWARE &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER</span>
<span class="synperlPOD">EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="synperlPOD">WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE</span>
<span class="synperlPOD">ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH</span>
<span class="synperlPOD">YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL</span>
<span class="synperlPOD">NECESSARY SERVICING, REPAIR, OR CORRECTION.</span>

<span class="synperlPOD">IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING</span>
<span class="synperlPOD">WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR</span>
<span class="synperlPOD">REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE</span>
<span class="synperlPOD">LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,</span>
<span class="synperlPOD">OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE</span>
<span class="synperlPOD">THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING</span>
<span class="synperlPOD">RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A</span>
<span class="synperlPOD">FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF</span>
<span class="synperlPOD">SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF</span>
<span class="synperlPOD">SUCH DAMAGES.</span>



</pre>

 </body>
</html>
