<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre>
<span class="synStatement">package</span><span class="synType"> Moose::Util::TypeConstraints</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Moose::Util::TypeConstraints::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Moose::Util::TypeConstraints::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use </span>Carp ();
<span class="synStatement">use </span>List::MoreUtils <span class="synString">qw( all any )</span>;
<span class="synStatement">use </span>Scalar::Util <span class="synString">qw( blessed reftype )</span>;
<span class="synStatement">use </span>Moose::Exporter;

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment"># Prototyped subs must be predeclared because we have a</span>
<span class="synComment"># circular dependency with Moose::Meta::Attribute et. al.</span>
<span class="synComment"># so in case of us being use'd first the predeclaration</span>
<span class="synComment"># ensures the prototypes are in scope when consumers are</span>
<span class="synComment"># compiled.</span>

<span class="synComment"># dah sugah!</span>
<span class="synKeyword">sub </span><span class="synFunction">where </span><span class="synType">(&amp;)</span>;
<span class="synKeyword">sub </span><span class="synFunction">via </span><span class="synType">(&amp;)</span>;
<span class="synKeyword">sub </span><span class="synFunction">message </span><span class="synType">(&amp;)</span>;
<span class="synKeyword">sub </span><span class="synFunction">optimize_as </span><span class="synType">(&amp;)</span>;
<span class="synKeyword">sub </span><span class="synFunction">inline_as </span><span class="synType">(&amp;)</span>;

<span class="synComment">## --------------------------------------------------------</span>

<span class="synStatement">use </span>Moose::Deprecated;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Union;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Parameterized;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Parameterizable;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Class;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Role;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Enum;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::DuckType;
<span class="synStatement">use </span>Moose::Meta::TypeCoercion;
<span class="synStatement">use </span>Moose::Meta::TypeCoercion::Union;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint::Registry;

Moose::Exporter-&gt;setup_import_methods(
    <span class="synString">as_is</span> =&gt; [
        <span class="synString">qw(</span>
<span class="synString">            type subtype class_type role_type maybe_type duck_type</span>
<span class="synString">            as where message optimize_as inline_as</span>
<span class="synString">            coerce from via</span>
<span class="synString">            enum union</span>
<span class="synString">            find_type_constraint</span>
<span class="synString">            register_type_constraint</span>
<span class="synString">            match_on_type )</span>
    ],
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## type registry and some useful functions for it</span>
<span class="synComment">## --------------------------------------------------------</span>

<span class="synStatement">my</span> <span class="synIdentifier">$REGISTRY</span> = Moose::Meta::TypeConstraint::Registry-&gt;new;

<span class="synKeyword">sub </span><span class="synFunction">get_type_constraint_registry </span>{<span class="synIdentifier">$REGISTRY</span>}
<span class="synKeyword">sub </span><span class="synFunction">list_all_type_constraints    </span>{ <span class="synStatement">keys</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$REGISTRY-&gt;type_constraints</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> }

<span class="synKeyword">sub </span><span class="synFunction">export_type_constraints_as_functions </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$pkg</span> = <span class="synStatement">caller</span>();
    <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$REGISTRY-&gt;type_constraints</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$tc</span> = <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$constraint</span>)
            -&gt;_compiled_type_constraint;
        <span class="synIdentifier">*{</span><span class="synString">&quot;</span><span class="synIdentifier">${pkg}</span><span class="synString">::</span><span class="synIdentifier">${constraint}</span><span class="synString">&quot;</span><span class="synIdentifier">}</span>
            = <span class="synKeyword">sub </span>{ <span class="synIdentifier">$tc</span>-&gt;( <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> ) ? <span class="synNumber">1</span> : <span class="synOperator">undef</span> };    <span class="synComment"># the undef is for compat</span>
    }
}

<span class="synKeyword">sub </span><span class="synFunction">create_type_constraint_union </span>{
    _create_type_constraint_union(\<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">create_named_type_constraint_union </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synStatement">shift</span>;
    _create_type_constraint_union(<span class="synIdentifier">$name</span>, \<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_create_type_constraint_union </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span>;
    <span class="synIdentifier">$name</span> = <span class="synStatement">shift</span> <span class="synConditional">if</span> <span class="synIdentifier">@_</span> &gt; <span class="synNumber">1</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@tcs</span> = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synStatement">shift</span><span class="synperlVarBlock">() </span><span class="synIdentifier">}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@type_constraint_names</span>;

    <span class="synConditional">if</span> ( <span class="synStatement">scalar</span> <span class="synIdentifier">@tcs</span> == <span class="synNumber">1</span> &amp;&amp; _detect_type_constraint_union( <span class="synIdentifier">$tcs[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> ) ) {
        <span class="synIdentifier">@type_constraint_names</span> = _parse_type_constraint_union( <span class="synIdentifier">$tcs[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> );
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">@type_constraint_names</span> = <span class="synIdentifier">@tcs</span>;
    }

    ( <span class="synStatement">scalar</span> <span class="synIdentifier">@type_constraint_names</span> &gt;= <span class="synNumber">2</span> )
        || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
        <span class="synString">&quot;You must pass in at least 2 type names to make a union&quot;</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">@type_constraints</span> = <span class="synStatement">map</span> <span class="synStatement">{</span>
        find_or_parse_type_constraint(<span class="synIdentifier">$_</span>)
            || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
            <span class="synString">&quot;Could not locate type constraint (</span><span class="synIdentifier">$_</span><span class="synString">) for the union&quot;</span>);
    <span class="synStatement">}</span> <span class="synIdentifier">@type_constraint_names</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = (
      <span class="synString">type_constraints</span> =&gt; \<span class="synIdentifier">@type_constraints</span>
    );
    <span class="synIdentifier">$options{</span><span class="synString">name</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$name</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$name</span>;

    <span class="synStatement">return</span> Moose::Meta::TypeConstraint::Union-&gt;new(<span class="synIdentifier">%options</span>);
}


<span class="synKeyword">sub </span><span class="synFunction">create_parameterized_type_constraint </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$type_constraint_name</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$base_type</span>, <span class="synIdentifier">$type_parameter</span> )
        = _parse_parameterized_type_constraint(<span class="synIdentifier">$type_constraint_name</span>);

    ( <span class="synOperator">defined</span> <span class="synIdentifier">$base_type</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$type_parameter</span> )
        || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
        <span class="synString">&quot;Could not parse type name (</span><span class="synIdentifier">$type_constraint_name</span><span class="synString">) correctly&quot;</span>);

    <span class="synConditional">if</span> ( <span class="synIdentifier">$REGISTRY-&gt;has_type_constraint</span>(<span class="synIdentifier">$base_type</span>) ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$base_type_tc</span> = <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$base_type</span>);
        <span class="synStatement">return</span> _create_parameterized_type_constraint(
            <span class="synIdentifier">$base_type_tc</span>,
            <span class="synIdentifier">$type_parameter</span>
        );
    }
    <span class="synConditional">else</span> {
        <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
            <span class="synString">&quot;Could not locate the base type (</span><span class="synIdentifier">$base_type</span><span class="synString">)&quot;</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_create_parameterized_type_constraint </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$base_type_tc</span>, <span class="synIdentifier">$type_parameter</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synConditional">if</span> ( <span class="synIdentifier">$base_type_tc-&gt;can</span>(<span class="synString">'parameterize'</span>) ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$base_type_tc-&gt;parameterize</span>(<span class="synIdentifier">$type_parameter</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> Moose::Meta::TypeConstraint::Parameterized-&gt;new(
            <span class="synString">name</span>   =&gt; <span class="synIdentifier">$base_type_tc-&gt;name</span> . <span class="synString">'['</span> . <span class="synIdentifier">$type_parameter</span> . <span class="synString">']'</span>,
            <span class="synString">parent</span> =&gt; <span class="synIdentifier">$base_type_tc</span>,
            <span class="synString">type_parameter</span> =&gt;
                find_or_create_isa_type_constraint(<span class="synIdentifier">$type_parameter</span>),
        );
    }
}

<span class="synComment">#should we also support optimized checks?</span>
<span class="synKeyword">sub </span><span class="synFunction">create_class_type_constraint </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$class</span>, <span class="synIdentifier">$options</span> ) = <span class="synIdentifier">@_</span>;

<span class="synComment"># too early for this check</span>
<span class="synComment">#find_type_constraint(&quot;ClassName&quot;)-&gt;check($class)</span>
<span class="synComment">#    || __PACKAGE__-&gt;_throw_error(&quot;Can't create a class type constraint because '$class' is not a class name&quot;);</span>

    <span class="synStatement">my</span> <span class="synIdentifier">$pkg_defined_in</span> = <span class="synIdentifier">$options-&gt;{</span><span class="synString">package_defined_in</span><span class="synIdentifier">}</span> || <span class="synStatement">scalar</span>( <span class="synStatement">caller</span>(<span class="synNumber">1</span>) );

    <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$class</span>)) {
        <span class="synConditional">if</span> (!(<span class="synIdentifier">$type-&gt;isa</span>(<span class="synString">'Moose::Meta::TypeConstraint::Class'</span>) &amp;&amp; <span class="synIdentifier">$type-&gt;class</span> <span class="synOperator">eq</span> <span class="synIdentifier">$class</span>)) {
            _confess(
                <span class="synString">&quot;The type constraint '</span><span class="synIdentifier">$class</span><span class="synString">' has already been created in &quot;</span>
              . <span class="synIdentifier">$type-&gt;_package_defined_in</span>
              . <span class="synString">&quot; and cannot be created again in &quot;</span>
              . <span class="synIdentifier">$pkg_defined_in</span> )
        }
        <span class="synConditional">else</span> {
            <span class="synStatement">return</span> <span class="synIdentifier">$type</span>;
        }
    }

    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = (
        <span class="synString">class</span>              =&gt; <span class="synIdentifier">$class</span>,
        <span class="synString">name</span>               =&gt; <span class="synIdentifier">$class</span>,
        <span class="synString">package_defined_in</span> =&gt; <span class="synIdentifier">$pkg_defined_in</span>,
        <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$options</span><span class="synperlVarBlock2"> || {</span>}<span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>,
    );

    <span class="synIdentifier">$options{</span><span class="synString">name</span><span class="synIdentifier">}</span> ||= <span class="synString">&quot;__ANON__&quot;</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$tc</span> = Moose::Meta::TypeConstraint::Class-&gt;new(<span class="synIdentifier">%options</span>);
    <span class="synIdentifier">$REGISTRY-&gt;add_type_constraint</span>(<span class="synIdentifier">$tc</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$tc</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">create_role_type_constraint </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$role</span>, <span class="synIdentifier">$options</span> ) = <span class="synIdentifier">@_</span>;

<span class="synComment"># too early for this check</span>
<span class="synComment">#find_type_constraint(&quot;ClassName&quot;)-&gt;check($class)</span>
<span class="synComment">#    || __PACKAGE__-&gt;_throw_error(&quot;Can't create a class type constraint because '$class' is not a class name&quot;);</span>

    <span class="synStatement">my</span> <span class="synIdentifier">$pkg_defined_in</span> = <span class="synIdentifier">$options-&gt;{</span><span class="synString">package_defined_in</span><span class="synIdentifier">}</span> || <span class="synStatement">scalar</span>( <span class="synStatement">caller</span>(<span class="synNumber">1</span>) );

    <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$role</span>)) {
        <span class="synConditional">if</span> (!(<span class="synIdentifier">$type-&gt;isa</span>(<span class="synString">'Moose::Meta::TypeConstraint::Role'</span>) &amp;&amp; <span class="synIdentifier">$type-&gt;role</span> <span class="synOperator">eq</span> <span class="synIdentifier">$role</span>)) {
            _confess(
                <span class="synString">&quot;The type constraint '</span><span class="synIdentifier">$role</span><span class="synString">' has already been created in &quot;</span>
              . <span class="synIdentifier">$type-&gt;_package_defined_in</span>
              . <span class="synString">&quot; and cannot be created again in &quot;</span>
              . <span class="synIdentifier">$pkg_defined_in</span> )
        }
        <span class="synConditional">else</span> {
            <span class="synStatement">return</span> <span class="synIdentifier">$type</span>;
        }
    }

    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = (
        <span class="synString">role</span>               =&gt; <span class="synIdentifier">$role</span>,
        <span class="synString">name</span>               =&gt; <span class="synIdentifier">$role</span>,
        <span class="synString">package_defined_in</span> =&gt; <span class="synIdentifier">$pkg_defined_in</span>,
        <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$options</span><span class="synperlVarBlock2"> || {</span>}<span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>,
    );

    <span class="synIdentifier">$options{</span><span class="synString">name</span><span class="synIdentifier">}</span> ||= <span class="synString">&quot;__ANON__&quot;</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$tc</span> = Moose::Meta::TypeConstraint::Role-&gt;new(<span class="synIdentifier">%options</span>);
    <span class="synIdentifier">$REGISTRY-&gt;add_type_constraint</span>(<span class="synIdentifier">$tc</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$tc</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_or_create_type_constraint </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_constraint_name</span>, <span class="synIdentifier">$options_for_anon_type</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span>
        = find_or_parse_type_constraint(<span class="synIdentifier">$type_constraint_name</span>) ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$constraint</span>;
    }
    <span class="synConditional">elsif</span> ( <span class="synOperator">defined</span> <span class="synIdentifier">$options_for_anon_type</span> ) {

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># if there is no $options_for_anon_type</span>
        <span class="synComment"># specified, then we assume they don't</span>
        <span class="synComment"># want to create one, and return nothing.</span>

        <span class="synComment"># otherwise assume that we should create</span>
        <span class="synComment"># an ANON type with the $options_for_anon_type</span>
        <span class="synComment"># options which can be passed in. It should</span>
        <span class="synComment"># be noted that these don't get registered</span>
        <span class="synComment"># so we need to return it.</span>
        <span class="synComment"># - SL</span>
        <span class="synStatement">return</span> Moose::Meta::TypeConstraint-&gt;new(
            <span class="synString">name</span> =&gt; <span class="synString">'__ANON__'</span>,
            <span class="synIdentifier">%{$options_for_anon_type}</span>
        );
    }

    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_or_create_isa_type_constraint </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$type_constraint_name</span>, <span class="synIdentifier">$options</span>) = <span class="synIdentifier">@_</span>;
    find_or_parse_type_constraint(<span class="synIdentifier">$type_constraint_name</span>)
        || create_class_type_constraint(<span class="synIdentifier">$type_constraint_name</span>, <span class="synIdentifier">$options</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">find_or_create_does_type_constraint </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$type_constraint_name</span>, <span class="synIdentifier">$options</span>) = <span class="synIdentifier">@_</span>;
    find_or_parse_type_constraint(<span class="synIdentifier">$type_constraint_name</span>)
        || create_role_type_constraint(<span class="synIdentifier">$type_constraint_name</span>, <span class="synIdentifier">$options</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">find_or_parse_type_constraint </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$type_constraint_name</span> = normalize_type_constraint_name(<span class="synStatement">shift</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$constraint</span> = find_type_constraint(<span class="synIdentifier">$type_constraint_name</span>) ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$constraint</span>;
    }
    <span class="synConditional">elsif</span> ( _detect_type_constraint_union(<span class="synIdentifier">$type_constraint_name</span>) ) {
        <span class="synIdentifier">$constraint</span> = create_type_constraint_union(<span class="synIdentifier">$type_constraint_name</span>);
    }
    <span class="synConditional">elsif</span> ( _detect_parameterized_type_constraint(<span class="synIdentifier">$type_constraint_name</span>) ) {
        <span class="synIdentifier">$constraint</span>
            = create_parameterized_type_constraint(<span class="synIdentifier">$type_constraint_name</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span>;
    }

    <span class="synIdentifier">$REGISTRY-&gt;add_type_constraint</span>(<span class="synIdentifier">$constraint</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$constraint</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">normalize_type_constraint_name </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$type_constraint_name</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$type_constraint_name</span> =~ <span class="synStatement">s/</span><span class="synSpecial">\s</span><span class="synStatement">//g</span>;
    <span class="synStatement">return</span> <span class="synIdentifier">$type_constraint_name</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_confess </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$error</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">local</span> <span class="synIdentifier">$</span><span class="synType">Carp::</span><span class="synIdentifier">CarpLevel</span> = <span class="synIdentifier">$</span><span class="synType">Carp::</span><span class="synIdentifier">CarpLevel</span> + <span class="synNumber">1</span>;
    Carp::confess(<span class="synIdentifier">$error</span>);
}

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## exported functions ...</span>
<span class="synComment">## --------------------------------------------------------</span>

<span class="synKeyword">sub </span><span class="synFunction">find_type_constraint </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( blessed <span class="synIdentifier">$type</span> <span class="synOperator">and</span> <span class="synIdentifier">$type-&gt;isa</span>(<span class="synString">&quot;Moose::Meta::TypeConstraint&quot;</span>) ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$type</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$REGISTRY-&gt;has_type_constraint</span>(<span class="synIdentifier">$type</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$type</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">register_type_constraint </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span> = <span class="synStatement">shift</span>;
    <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;can't register an unnamed type constraint&quot;</span>)
        <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$constraint-&gt;name</span>;
    <span class="synIdentifier">$REGISTRY-&gt;add_type_constraint</span>(<span class="synIdentifier">$constraint</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$constraint</span>;
}

<span class="synComment"># type constructors</span>

<span class="synKeyword">sub </span><span class="synFunction">type </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%p</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">%{$_}</span> <span class="synStatement">}</span> <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> _create_type_constraint(
        <span class="synIdentifier">$name</span>, <span class="synOperator">undef</span>, <span class="synIdentifier">$p{</span><span class="synString">where</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$p{</span><span class="synString">message</span><span class="synIdentifier">}</span>,
        <span class="synIdentifier">$p{</span><span class="synString">optimize_as</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$p{</span><span class="synString">inline_as</span><span class="synIdentifier">}</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">subtype </span>{
    <span class="synConditional">if</span> ( <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> &amp;&amp; !<span class="synOperator">ref</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> ) {
        <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
            <span class="synString">'A subtype cannot consist solely of a name, it must have a parent'</span>
        );
    }

    <span class="synComment"># The blessed check is mostly to accommodate MooseX::Types, which</span>
    <span class="synComment"># uses an object which overloads stringification as a type name.</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> &amp;&amp; !blessed <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> ? <span class="synOperator">undef</span> : <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%p</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">%{$_}</span> <span class="synStatement">}</span> <span class="synIdentifier">@_</span>;

    <span class="synComment"># subtype Str =&gt; where { ... };</span>
    <span class="synConditional">if</span> ( !<span class="synStatement">exists</span> <span class="synIdentifier">$p{</span><span class="synString">as</span><span class="synIdentifier">}</span> ) {
        <span class="synIdentifier">$p{</span><span class="synString">as</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$name</span>;
        <span class="synIdentifier">$name</span> = <span class="synOperator">undef</span>;
    }

    <span class="synStatement">return</span> _create_type_constraint(
        <span class="synIdentifier">$name</span>, <span class="synIdentifier">$p{</span><span class="synString">as</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$p{</span><span class="synString">where</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$p{</span><span class="synString">message</span><span class="synIdentifier">}</span>,
        <span class="synIdentifier">$p{</span><span class="synString">optimize_as</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$p{</span><span class="synString">inline_as</span><span class="synIdentifier">}</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">class_type </span>{
    create_class_type_constraint(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">role_type </span><span class="synType">($;$) </span>{
    create_role_type_constraint(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">maybe_type </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$type_parameter</span>) = <span class="synIdentifier">@_</span>;

    register_type_constraint(
        <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synString">'Maybe'</span>)-&gt;parameterize(<span class="synIdentifier">$type_parameter</span>)
    );
}

<span class="synKeyword">sub </span><span class="synFunction">duck_type </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">@methods</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synConditional">if</span> ( <span class="synOperator">ref</span> <span class="synIdentifier">$type_name</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> &amp;&amp; !<span class="synIdentifier">@methods</span> ) {
        <span class="synIdentifier">@methods</span>   = <span class="synIdentifier">@$type_name</span>;
        <span class="synIdentifier">$type_name</span> = <span class="synOperator">undef</span>;
    }
    <span class="synConditional">if</span> ( <span class="synIdentifier">@methods</span> == <span class="synNumber">1</span> &amp;&amp; <span class="synOperator">ref</span> <span class="synIdentifier">$methods[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> ) {
        <span class="synIdentifier">@methods</span> = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$methods[</span><span class="synNumber">0</span><span class="synIdentifier">]</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
    }

    register_type_constraint(
        create_duck_type_constraint(
            <span class="synIdentifier">$type_name</span>,
            \<span class="synIdentifier">@methods</span>,
        )
    );
}

<span class="synKeyword">sub </span><span class="synFunction">coerce </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">@coercion_map</span> ) = <span class="synIdentifier">@_</span>;
    _install_type_coercions( <span class="synIdentifier">$type_name</span>, \<span class="synIdentifier">@coercion_map</span> );
}

<span class="synComment"># The trick of returning @_ lets us avoid having to specify a</span>
<span class="synComment"># prototype. Perl will parse this:</span>
<span class="synComment">#</span>
<span class="synComment"># subtype 'Foo'</span>
<span class="synComment">#     =&gt; as 'Str'</span>
<span class="synComment">#     =&gt; where { ... }</span>
<span class="synComment">#</span>
<span class="synComment"># as this:</span>
<span class="synComment">#</span>
<span class="synComment"># subtype( 'Foo', as( 'Str', where { ... } ) );</span>
<span class="synComment">#</span>
<span class="synComment"># If as() returns all its extra arguments, this just works, and</span>
<span class="synComment"># preserves backwards compatibility.</span>
<span class="synKeyword">sub </span><span class="synFunction">as </span>{ { <span class="synString">as</span> =&gt; <span class="synStatement">shift</span> }, <span class="synIdentifier">@_</span> }
<span class="synKeyword">sub </span><span class="synFunction">where </span><span class="synType">(&amp;)       </span>{ { <span class="synString">where</span>       =&gt; <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> } }
<span class="synKeyword">sub </span><span class="synFunction">message </span><span class="synType">(&amp;)     </span>{ { <span class="synString">message</span>     =&gt; <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> } }
<span class="synKeyword">sub </span><span class="synFunction">optimize_as </span><span class="synType">(&amp;) </span>{ { <span class="synString">optimize_as</span> =&gt; <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> } }
<span class="synKeyword">sub </span><span class="synFunction">inline_as </span><span class="synType">(&amp;)   </span>{ { <span class="synString">inline_as</span>   =&gt; <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> } }

<span class="synKeyword">sub </span><span class="synFunction">from    </span>{<span class="synIdentifier">@_</span>}
<span class="synKeyword">sub </span><span class="synFunction">via </span><span class="synType">(&amp;) </span>{ <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> }

<span class="synKeyword">sub </span><span class="synFunction">enum </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">@values</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># if only an array-ref is passed then</span>
    <span class="synComment"># you get an anon-enum</span>
    <span class="synComment"># - SL</span>
    <span class="synConditional">if</span> ( <span class="synOperator">ref</span> <span class="synIdentifier">$type_name</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> ) {
        <span class="synIdentifier">@values</span> == <span class="synNumber">0</span>
            || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;enum called with an array reference and additional arguments. Did you mean to parenthesize the enum call's parameters?&quot;</span>);

        <span class="synIdentifier">@values</span>    = <span class="synIdentifier">@$type_name</span>;
        <span class="synIdentifier">$type_name</span> = <span class="synOperator">undef</span>;
    }
    <span class="synConditional">if</span> ( <span class="synIdentifier">@values</span> == <span class="synNumber">1</span> &amp;&amp; <span class="synOperator">ref</span> <span class="synIdentifier">$values[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> ) {
        <span class="synIdentifier">@values</span> = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$values[</span><span class="synNumber">0</span><span class="synIdentifier">]</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
    }

    register_type_constraint(
        create_enum_type_constraint(
            <span class="synIdentifier">$type_name</span>,
            \<span class="synIdentifier">@values</span>,
        )
    );
}

<span class="synKeyword">sub </span><span class="synFunction">union </span>{
  <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">@constraints</span> ) = <span class="synIdentifier">@_</span>;
  <span class="synConditional">if</span> ( <span class="synOperator">ref</span> <span class="synIdentifier">$type_name</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> ) {
    <span class="synIdentifier">@constraints</span> == <span class="synNumber">0</span>
      || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;union called with an array reference and additional arguments.&quot;</span>);
    <span class="synIdentifier">@constraints</span> = <span class="synIdentifier">@$type_name</span>;
    <span class="synIdentifier">$type_name</span>   = <span class="synOperator">undef</span>;
  }
  <span class="synConditional">if</span> ( <span class="synIdentifier">@constraints</span> == <span class="synNumber">1</span> &amp;&amp; <span class="synOperator">ref</span> <span class="synIdentifier">$constraints[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> ) {
    <span class="synIdentifier">@constraints</span> = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$constraints[</span><span class="synNumber">0</span><span class="synIdentifier">]</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
  }
  <span class="synConditional">if</span> ( <span class="synOperator">defined</span> <span class="synIdentifier">$type_name</span> ) {
    <span class="synStatement">return</span> register_type_constraint(
      create_named_type_constraint_union( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">@constraints</span> )
    );
  }
  <span class="synStatement">return</span> create_type_constraint_union( <span class="synIdentifier">@constraints</span> );
}

<span class="synKeyword">sub </span><span class="synFunction">create_enum_type_constraint </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">$values</span> ) = <span class="synIdentifier">@_</span>;

    Moose::Meta::TypeConstraint::Enum-&gt;new(
        <span class="synString">name</span> =&gt; <span class="synIdentifier">$type_name</span> || <span class="synString">'__ANON__'</span>,
        <span class="synString">values</span> =&gt; <span class="synIdentifier">$values</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">create_duck_type_constraint </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">$methods</span> ) = <span class="synIdentifier">@_</span>;

    Moose::Meta::TypeConstraint::DuckType-&gt;new(
        <span class="synString">name</span> =&gt; <span class="synIdentifier">$type_name</span> || <span class="synString">'__ANON__'</span>,
        <span class="synString">methods</span> =&gt; <span class="synIdentifier">$methods</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">match_on_type </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$to_match</span>, <span class="synIdentifier">@cases</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$default</span>;
    <span class="synConditional">if</span> (<span class="synIdentifier">@cases</span> % <span class="synNumber">2</span> != <span class="synNumber">0</span>) {
        <span class="synIdentifier">$default</span> = <span class="synStatement">pop</span> <span class="synIdentifier">@cases</span>;
        (<span class="synOperator">ref</span> <span class="synIdentifier">$default</span> <span class="synOperator">eq</span> <span class="synString">'CODE'</span>)
            || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;Default case must be a CODE ref, not </span><span class="synIdentifier">$default</span><span class="synString">&quot;</span>);
    }
    <span class="synRepeat">while</span> (<span class="synIdentifier">@cases</span>) {
        <span class="synStatement">my</span> (<span class="synIdentifier">$type</span>, <span class="synIdentifier">$action</span>) = <span class="synStatement">splice</span> <span class="synIdentifier">@cases</span>, <span class="synNumber">0</span>, <span class="synNumber">2</span>;

        <span class="synConditional">unless</span> (blessed <span class="synIdentifier">$type</span> &amp;&amp; <span class="synIdentifier">$type-&gt;isa</span>(<span class="synString">'Moose::Meta::TypeConstraint'</span>)) {
            <span class="synIdentifier">$type</span> = find_or_parse_type_constraint(<span class="synIdentifier">$type</span>)
                 || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;Cannot find or parse the type '</span><span class="synIdentifier">$type</span><span class="synString">'&quot;</span>)
        }

        (<span class="synOperator">ref</span> <span class="synIdentifier">$action</span> <span class="synOperator">eq</span> <span class="synString">'CODE'</span>)
            || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;Match action must be a CODE ref, not </span><span class="synIdentifier">$action</span><span class="synString">&quot;</span>);

        <span class="synConditional">if</span> (<span class="synIdentifier">$type-&gt;check</span>(<span class="synIdentifier">$to_match</span>)) {
            <span class="synStatement">local</span> <span class="synIdentifier">$_</span> = <span class="synIdentifier">$to_match</span>;
            <span class="synStatement">return</span> <span class="synIdentifier">$action</span>-&gt;(<span class="synIdentifier">$to_match</span>);
        }
    }
    (<span class="synOperator">defined</span> <span class="synIdentifier">$default</span>)
        || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(<span class="synString">&quot;No cases matched for </span><span class="synIdentifier">$to_match</span><span class="synString">&quot;</span>);
    {
        <span class="synStatement">local</span> <span class="synIdentifier">$_</span> = <span class="synIdentifier">$to_match</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$default</span>-&gt;(<span class="synIdentifier">$to_match</span>);
    }
}


<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## desugaring functions ...</span>
<span class="synComment">## --------------------------------------------------------</span>

<span class="synKeyword">sub </span><span class="synFunction">_create_type_constraint </span><span class="synType">($$$;$$) </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span>      = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$parent</span>    = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$check</span>     = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$message</span>   = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$optimized</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$inlined</span>   = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$pkg_defined_in</span> = <span class="synStatement">scalar</span>( <span class="synStatement">caller</span>(<span class="synNumber">1</span>) );

    <span class="synConditional">if</span> ( <span class="synOperator">defined</span> <span class="synIdentifier">$name</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$name</span>);

        ( <span class="synIdentifier">$type-&gt;_package_defined_in</span> <span class="synOperator">eq</span> <span class="synIdentifier">$pkg_defined_in</span> )
            || _confess(
                  <span class="synString">&quot;The type constraint '</span><span class="synIdentifier">$name</span><span class="synString">' has already been created in &quot;</span>
                . <span class="synIdentifier">$type-&gt;_package_defined_in</span>
                . <span class="synString">&quot; and cannot be created again in &quot;</span>
                . <span class="synIdentifier">$pkg_defined_in</span> )
            <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$type</span>;

        <span class="synIdentifier">$name</span> =~ <span class="synStatement">/</span><span class="synString">^[</span><span class="synSpecial">\w</span><span class="synString">:</span><span class="synSpecial">\.</span><span class="synString">]</span><span class="synSpecial">+</span><span class="synString">$</span><span class="synStatement">/</span>
            <span class="synOperator">or</span> <span class="synStatement">die</span> <span class="synString">qq{</span><span class="synIdentifier">$name</span><span class="synString"> contains invalid characters for a type name.}</span>
            . <span class="synString">qq{ Names can contain alphanumeric character, &quot;:&quot;, and &quot;.&quot;</span><span class="synSpecial">\n</span><span class="synString">}</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">%opts</span> = (
        <span class="synString">name</span>               =&gt; <span class="synIdentifier">$name</span>,
        <span class="synString">package_defined_in</span> =&gt; <span class="synIdentifier">$pkg_defined_in</span>,

        ( <span class="synIdentifier">$check</span>     ? ( <span class="synString">constraint</span> =&gt; <span class="synIdentifier">$check</span> )     : () ),
        ( <span class="synIdentifier">$message</span>   ? ( <span class="synString">message</span>    =&gt; <span class="synIdentifier">$message</span> )   : () ),
        ( <span class="synIdentifier">$optimized</span> ? ( <span class="synString">optimized</span>  =&gt; <span class="synIdentifier">$optimized</span> ) : () ),
        ( <span class="synIdentifier">$inlined</span>   ? ( <span class="synString">inlined</span>    =&gt; <span class="synIdentifier">$inlined</span> )   : () ),
    );

    <span class="synStatement">my</span> <span class="synIdentifier">$constraint</span>;
    <span class="synConditional">if</span> (
        <span class="synOperator">defined</span> <span class="synIdentifier">$parent</span>
        <span class="synOperator">and</span> <span class="synIdentifier">$parent</span>
        = blessed <span class="synIdentifier">$parent</span>
        ? <span class="synIdentifier">$parent</span>
        : find_or_create_isa_type_constraint(<span class="synIdentifier">$parent</span>)
        ) {
        <span class="synIdentifier">$constraint</span> = <span class="synIdentifier">$parent-&gt;create_child_type</span>(<span class="synIdentifier">%opts</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$constraint</span> = Moose::Meta::TypeConstraint-&gt;new(<span class="synIdentifier">%opts</span>);
    }

    <span class="synIdentifier">$REGISTRY-&gt;add_type_constraint</span>(<span class="synIdentifier">$constraint</span>)
        <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$constraint</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_install_type_coercions </span><span class="synType">($$) </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$type_name</span>, <span class="synIdentifier">$coercion_map</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = find_type_constraint(<span class="synIdentifier">$type_name</span>);
    ( <span class="synOperator">defined</span> <span class="synIdentifier">$type</span> )
        || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
        <span class="synString">&quot;Cannot find type '</span><span class="synIdentifier">$type_name</span><span class="synString">', perhaps you forgot to load it&quot;</span>);
    <span class="synConditional">if</span> ( <span class="synIdentifier">$type-&gt;has_coercion</span> ) {
        <span class="synIdentifier">$type-&gt;coercion-&gt;add_type_coercions</span>(<span class="synIdentifier">@$coercion_map</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">my</span> <span class="synIdentifier">$type_coercion</span> = Moose::Meta::TypeCoercion-&gt;new(
            <span class="synString">type_coercion_map</span> =&gt; <span class="synIdentifier">$coercion_map</span>,
            <span class="synString">type_constraint</span>   =&gt; <span class="synIdentifier">$type</span>
        );
        <span class="synIdentifier">$type-&gt;coercion</span>(<span class="synIdentifier">$type_coercion</span>);
    }
}

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## type notation parsing ...</span>
<span class="synComment">## --------------------------------------------------------</span>

{

    <span class="synComment"># All I have to say is mugwump++ cause I know</span>
    <span class="synComment"># do not even have enough regexp-fu to be able</span>
    <span class="synComment"># to have written this (I can only barely</span>
    <span class="synComment"># understand it as it is)</span>
    <span class="synComment"># - SL</span>

    <span class="synStatement">use re</span> <span class="synString">&quot;eval&quot;</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$valid_chars</span> = <span class="synString">qr{[</span><span class="synSpecial">\w</span><span class="synString">:</span><span class="synSpecial">\.</span><span class="synString">]}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$type_atom</span>   = <span class="synString">qr{ </span><span class="synSpecial">(?</span><span class="synString">&gt;</span><span class="synIdentifier">$valid_chars</span><span class="synSpecial">+)</span><span class="synString"> }x</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$ws</span>          = <span class="synString">qr{ </span><span class="synSpecial">(?</span><span class="synString">&gt;</span><span class="synSpecial">\s*)</span><span class="synString"> }x</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$op_union</span>    = <span class="synString">qr{ </span><span class="synIdentifier">$ws</span><span class="synString"> </span><span class="synSpecial">\|</span><span class="synString"> </span><span class="synIdentifier">$ws</span><span class="synString"> }x</span>;

    <span class="synStatement">my</span> (<span class="synIdentifier">$type</span>, <span class="synIdentifier">$type_capture_parts</span>, <span class="synIdentifier">$type_with_parameter</span>, <span class="synIdentifier">$union</span>, <span class="synIdentifier">$any</span>);
    <span class="synConditional">if</span> (Class::MOP::IS_RUNNING_ON_5_10) {
        <span class="synStatement">my</span> <span class="synIdentifier">$type_pattern</span>
            = <span class="synString">q{  (?&amp;type_atom)  (?: \[ (?&amp;ws)  (?&amp;any)  (?&amp;ws) \] )? }</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$type_capture_parts_pattern</span>
            = <span class="synString">q{ ((?&amp;type_atom)) (?: \[ (?&amp;ws) ((?&amp;any)) (?&amp;ws) \] )? }</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$type_with_parameter_pattern</span>
            = <span class="synString">q{  (?&amp;type_atom)      \[ (?&amp;ws)  (?&amp;any)  (?&amp;ws) \]    }</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$union_pattern</span>
            = <span class="synString">q{ (?&amp;type) (?&gt; (?: (?&amp;op_union) (?&amp;type) )+ ) }</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$any_pattern</span>
            = <span class="synString">q{ (?&amp;type) | (?&amp;union) }</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$defines</span> = <span class="synString">qr{</span><span class="synSpecial">(?(</span><span class="synString">DEFINE</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;valid_chars&gt;         </span><span class="synIdentifier">$valid_chars</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;type_atom&gt;           </span><span class="synIdentifier">$type_atom</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;ws&gt;                  </span><span class="synIdentifier">$ws</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;op_union&gt;            </span><span class="synIdentifier">$op_union</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;type&gt;                </span><span class="synIdentifier">$type_pattern</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;type_capture_parts&gt;  </span><span class="synIdentifier">$type_capture_parts_pattern</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;type_with_parameter&gt; </span><span class="synIdentifier">$type_with_parameter_pattern</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;union&gt;               </span><span class="synIdentifier">$union_pattern</span><span class="synSpecial">)</span>
<span class="synString">            </span><span class="synSpecial">(?</span><span class="synString">&lt;any&gt;                 </span><span class="synIdentifier">$any_pattern</span><span class="synSpecial">)</span>
<span class="synString">        </span><span class="synSpecial">)</span><span class="synString">}x</span>;

        <span class="synIdentifier">$type</span>                = <span class="synString">qr{ </span><span class="synIdentifier">$type_pattern</span><span class="synString">                </span><span class="synIdentifier">$defines</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$type_capture_parts</span>  = <span class="synString">qr{ </span><span class="synIdentifier">$type_capture_parts_pattern</span><span class="synString">  </span><span class="synIdentifier">$defines</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$type_with_parameter</span> = <span class="synString">qr{ </span><span class="synIdentifier">$type_with_parameter_pattern</span><span class="synString"> </span><span class="synIdentifier">$defines</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$union</span>               = <span class="synString">qr{ </span><span class="synIdentifier">$union_pattern</span><span class="synString">               </span><span class="synIdentifier">$defines</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$any</span>                 = <span class="synString">qr{ </span><span class="synIdentifier">$any_pattern</span><span class="synString">                 </span><span class="synIdentifier">$defines</span><span class="synString"> }x</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$type</span>
            = <span class="synString">qr{  </span><span class="synIdentifier">$type_atom</span><span class="synString">  </span><span class="synSpecial">(?:</span><span class="synString"> </span><span class="synSpecial">\[</span><span class="synString"> </span><span class="synIdentifier">$ws</span><span class="synString">  </span><span class="synSpecial">(??</span><span class="synString">{</span><span class="synIdentifier">$any</span><span class="synString">}</span><span class="synSpecial">)</span><span class="synString">  </span><span class="synIdentifier">$ws</span><span class="synString"> </span><span class="synSpecial">\]</span><span class="synString"> </span><span class="synSpecial">)?</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$type_capture_parts</span>
            = <span class="synString">qr{ </span><span class="synSpecial">(</span><span class="synIdentifier">$type_atom</span><span class="synSpecial">)</span><span class="synString"> </span><span class="synSpecial">(?:</span><span class="synString"> </span><span class="synSpecial">\[</span><span class="synString"> </span><span class="synIdentifier">$ws</span><span class="synString"> </span><span class="synSpecial">((??</span><span class="synString">{</span><span class="synIdentifier">$any</span><span class="synString">}</span><span class="synSpecial">))</span><span class="synString"> </span><span class="synIdentifier">$ws</span><span class="synString"> </span><span class="synSpecial">\]</span><span class="synString"> </span><span class="synSpecial">)?</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$type_with_parameter</span>
            = <span class="synString">qr{  </span><span class="synIdentifier">$type_atom</span><span class="synString">      </span><span class="synSpecial">\[</span><span class="synString"> </span><span class="synIdentifier">$ws</span><span class="synString">  </span><span class="synSpecial">(??</span><span class="synString">{</span><span class="synIdentifier">$any</span><span class="synString">}</span><span class="synSpecial">)</span><span class="synString">  </span><span class="synIdentifier">$ws</span><span class="synString"> </span><span class="synSpecial">\]</span><span class="synString">    }x</span>;
        <span class="synIdentifier">$union</span>
            = <span class="synString">qr{ </span><span class="synIdentifier">$type</span><span class="synString"> </span><span class="synSpecial">(?</span><span class="synString">&gt; </span><span class="synSpecial">(?:</span><span class="synString"> </span><span class="synIdentifier">$op_union</span><span class="synString"> </span><span class="synIdentifier">$type</span><span class="synString"> </span><span class="synSpecial">)+</span><span class="synString"> </span><span class="synSpecial">)</span><span class="synString"> }x</span>;
        <span class="synIdentifier">$any</span>
            = <span class="synString">qr{ </span><span class="synIdentifier">$type</span><span class="synString"> | </span><span class="synIdentifier">$union</span><span class="synString"> }x</span>;
    }


    <span class="synKeyword">sub </span><span class="synFunction">_parse_parameterized_type_constraint </span>{
        { <span class="synStatement">no warnings</span> <span class="synString">'void'</span>; <span class="synIdentifier">$any</span>; }  <span class="synComment"># force capture of interpolated lexical</span>
        <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> =~ <span class="synStatement">m{</span><span class="synString"> </span><span class="synIdentifier">$type_capture_parts</span><span class="synString"> </span><span class="synStatement">}x</span>;
        <span class="synStatement">return</span> ( <span class="synIdentifier">$1</span>, <span class="synIdentifier">$2</span> );
    }

    <span class="synKeyword">sub </span><span class="synFunction">_detect_parameterized_type_constraint </span>{
        { <span class="synStatement">no warnings</span> <span class="synString">'void'</span>; <span class="synIdentifier">$any</span>; }  <span class="synComment"># force capture of interpolated lexical</span>
        <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> =~ <span class="synStatement">m{</span><span class="synString"> ^ </span><span class="synIdentifier">$type_with_parameter</span><span class="synString"> $ </span><span class="synStatement">}x</span>;
    }

    <span class="synKeyword">sub </span><span class="synFunction">_parse_type_constraint_union </span>{
        { <span class="synStatement">no warnings</span> <span class="synString">'void'</span>; <span class="synIdentifier">$any</span>; }  <span class="synComment"># force capture of interpolated lexical</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$given</span> = <span class="synStatement">shift</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">@rv</span>;
        <span class="synRepeat">while</span> ( <span class="synIdentifier">$given</span> =~ <span class="synStatement">m{</span><span class="synString"> </span><span class="synSpecial">\G</span><span class="synString"> </span><span class="synSpecial">(?:</span><span class="synString"> </span><span class="synIdentifier">$op_union</span><span class="synString"> </span><span class="synSpecial">)?</span><span class="synString"> </span><span class="synSpecial">(</span><span class="synIdentifier">$type</span><span class="synSpecial">)</span><span class="synString"> </span><span class="synStatement">}gcx</span> ) {
            <span class="synStatement">push</span> <span class="synIdentifier">@rv</span> =&gt; <span class="synIdentifier">$1</span>;
        }
        ( <span class="synStatement">pos</span>(<span class="synIdentifier">$given</span>) <span class="synOperator">eq</span> <span class="synStatement">length</span>(<span class="synIdentifier">$given</span>) )
            || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>( <span class="synString">&quot;'</span><span class="synIdentifier">$given</span><span class="synString">' didn't parse (parse-pos=&quot;</span>
                . <span class="synStatement">pos</span>(<span class="synIdentifier">$given</span>)
                . <span class="synString">&quot; and str-length=&quot;</span>
                . <span class="synStatement">length</span>(<span class="synIdentifier">$given</span>)
                . <span class="synString">&quot;)&quot;</span> );
        <span class="synIdentifier">@rv</span>;
    }

    <span class="synKeyword">sub </span><span class="synFunction">_detect_type_constraint_union </span>{
        { <span class="synStatement">no warnings</span> <span class="synString">'void'</span>; <span class="synIdentifier">$any</span>; }  <span class="synComment"># force capture of interpolated lexical</span>
        <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> =~ <span class="synStatement">m{</span><span class="synString">^ </span><span class="synIdentifier">$type</span><span class="synString"> </span><span class="synIdentifier">$op_union</span><span class="synString"> </span><span class="synIdentifier">$type</span><span class="synString"> </span><span class="synSpecial">(</span><span class="synString"> </span><span class="synIdentifier">$op_union</span><span class="synString"> </span><span class="synSpecial">.*</span><span class="synString"> </span><span class="synSpecial">)?</span><span class="synString"> $</span><span class="synStatement">}x</span>;
    }
}

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment"># define some basic built-in types</span>
<span class="synComment">## --------------------------------------------------------</span>

<span class="synComment"># By making these classes immutable before creating all the types in</span>
<span class="synComment"># Moose::Util::TypeConstraints::Builtin , we avoid repeatedly calling the slow</span>
<span class="synComment"># MOP-based accessors.</span>
<span class="synIdentifier">$_-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">1</span>,
    <span class="synString">constructor_name</span>   =&gt; <span class="synString">&quot;_new&quot;</span>,

    <span class="synComment"># these are Class::MOP accessors, so they need inlining</span>
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">1</span>
    ) <span class="synRepeat">for</span> <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;is_mutable</span> <span class="synStatement">}</span>
    <span class="synStatement">map</span> <span class="synStatement">{</span> Class::MOP::class_of(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span>
    <span class="synString">qw(</span>
<span class="synString">    Moose::Meta::TypeConstraint</span>
<span class="synString">    Moose::Meta::TypeConstraint::Union</span>
<span class="synString">    Moose::Meta::TypeConstraint::Parameterized</span>
<span class="synString">    Moose::Meta::TypeConstraint::Parameterizable</span>
<span class="synString">    Moose::Meta::TypeConstraint::Class</span>
<span class="synString">    Moose::Meta::TypeConstraint::Role</span>
<span class="synString">    Moose::Meta::TypeConstraint::Enum</span>
<span class="synString">    Moose::Meta::TypeConstraint::DuckType</span>
<span class="synString">    Moose::Meta::TypeConstraint::Registry</span>
<span class="synString">)</span>;

<span class="synStatement">require</span> Moose::Util::TypeConstraints::Builtins;
Moose::Util::TypeConstraints::Builtins::define_builtins(<span class="synIdentifier">$REGISTRY</span>);

<span class="synStatement">my</span> <span class="synIdentifier">@PARAMETERIZABLE_TYPES</span>
    = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$REGISTRY-&gt;get_type_constraint</span>(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synString">qw[ScalarRef ArrayRef HashRef Maybe]</span>;

<span class="synKeyword">sub </span><span class="synFunction">get_all_parameterizable_types </span>{<span class="synIdentifier">@PARAMETERIZABLE_TYPES</span>}

<span class="synKeyword">sub </span><span class="synFunction">add_parameterizable_type </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synStatement">shift</span>;
    ( blessed <span class="synIdentifier">$type</span>
            &amp;&amp; <span class="synIdentifier">$type-&gt;isa</span>(<span class="synString">'Moose::Meta::TypeConstraint::Parameterizable'</span>) )
        || <span class="synperlPackageConst">__PACKAGE__</span><span class="synIdentifier">-&gt;_throw_error</span>(
        <span class="synString">&quot;Type must be a Moose::Meta::TypeConstraint::Parameterizable not </span><span class="synIdentifier">$type</span><span class="synString">&quot;</span>
        );
    <span class="synStatement">push</span> <span class="synIdentifier">@PARAMETERIZABLE_TYPES</span> =&gt; <span class="synIdentifier">$type</span>;
}

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment"># end of built-in types ...</span>
<span class="synComment">## --------------------------------------------------------</span>

{
    <span class="synStatement">my</span> <span class="synIdentifier">@BUILTINS</span> = list_all_type_constraints();
    <span class="synKeyword">sub </span><span class="synFunction">list_all_builtin_type_constraints </span>{<span class="synIdentifier">@BUILTINS</span>}
}

<span class="synKeyword">sub </span><span class="synFunction">_throw_error </span>{
    <span class="synStatement">shift</span>;
    <span class="synStatement">require</span> Moose;
    <span class="synStatement">unshift</span> <span class="synIdentifier">@_</span>, <span class="synString">'Moose'</span>;
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Moose::</span><span class="synIdentifier">throw_error</span>;
}

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: Type constraint system for Moose</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Moose::Util::TypeConstraints - Type constraint system for Moose</span>

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

<span class="synperlPOD">version 2.1005</span>

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synPreProc">  use Moose::Util::TypeConstraints;</span>

<span class="synPreProc">  subtype 'Natural',</span>
<span class="synPreProc">      as 'Int',</span>
<span class="synPreProc">      where { $_ &gt; 0 };</span>

<span class="synPreProc">  subtype 'NaturalLessThanTen',</span>
<span class="synPreProc">      as 'Natural',</span>
<span class="synPreProc">      where { $_ &lt; 10 },</span>
<span class="synPreProc">      message { &quot;This number ($_) is not less than ten!&quot; };</span>

<span class="synPreProc">  coerce 'Num',</span>
<span class="synPreProc">      from 'Str',</span>
<span class="synPreProc">      via { 0+$_ };</span>

<span class="synPreProc">  class_type 'DateTimeClass', { class =&gt; 'DateTime' };</span>

<span class="synPreProc">  role_type 'Barks', { role =&gt; 'Some::Library::Role::Barks' };</span>

<span class="synPreProc">  enum 'RGBColors', [qw(red green blue)];</span>

<span class="synPreProc">  union 'StringOrArray', [qw( String Array )];</span>

<span class="synPreProc">  no Moose::Util::TypeConstraints;</span>

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

<span class="synperlPOD">This module provides Moose with the ability to create custom type</span>
<span class="synperlPOD">constraints to be used in attribute definition.</span>

<span class="synStatement">=head2</span><span class="synString"> Important Caveat</span>

<span class="synperlPOD">This is </span><span class="synIdentifier">B&lt;NOT&gt;</span><span class="synperlPOD"> a type system for Perl 5. These are type constraints,</span>
<span class="synperlPOD">and they are not used by Moose unless you tell it to. No type</span>
<span class="synperlPOD">inference is performed, expressions are not typed, etc. etc. etc.</span>

<span class="synperlPOD">A type constraint is at heart a small &quot;check if a value is valid&quot;</span>
<span class="synperlPOD">function. A constraint can be associated with an attribute. This</span>
<span class="synperlPOD">simplifies parameter validation, and makes your code clearer to read,</span>
<span class="synperlPOD">because you can refer to constraints by name.</span>

<span class="synStatement">=head2</span><span class="synString"> Slightly Less Important Caveat</span>

<span class="synperlPOD">It is </span><span class="synIdentifier">B&lt;always&gt;</span><span class="synperlPOD"> a good idea to quote your type names.</span>

<span class="synperlPOD">This prevents Perl from trying to execute the call as an indirect</span>
<span class="synperlPOD">object call. This can be an issue when you have a subtype with the</span>
<span class="synperlPOD">same name as a valid class.</span>

<span class="synperlPOD">For instance:</span>

<span class="synPreProc">  subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };</span>

<span class="synperlPOD">will </span><span class="synIdentifier">I&lt;just work&gt;</span><span class="synperlPOD">, while this:</span>

<span class="synPreProc">  use DateTime;</span>
<span class="synPreProc">  subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };</span>

<span class="synperlPOD">will fail silently and cause many headaches. The simple way to solve</span>
<span class="synperlPOD">this, as well as future proof your subtypes from classes which have</span>
<span class="synperlPOD">yet to have been created, is to quote the type name:</span>

<span class="synPreProc">  use DateTime;</span>
<span class="synPreProc">  subtype 'DateTime', as 'Object', where { $_-&gt;isa('DateTime') };</span>

<span class="synStatement">=head2</span><span class="synString"> Default Type Constraints</span>

<span class="synperlPOD">This module also provides a simple hierarchy for Perl 5 types, here is</span>
<span class="synperlPOD">that hierarchy represented visually.</span>

<span class="synPreProc">  Any</span>
<span class="synPreProc">      Item</span>
<span class="synPreProc">          Bool</span>
<span class="synPreProc">          Maybe[`a]</span>
<span class="synPreProc">          Undef</span>
<span class="synPreProc">          Defined</span>
<span class="synPreProc">              Value</span>
<span class="synPreProc">                  Str</span>
<span class="synPreProc">                      Num</span>
<span class="synPreProc">                          Int</span>
<span class="synPreProc">                      ClassName</span>
<span class="synPreProc">                      RoleName</span>
<span class="synPreProc">              Ref</span>
<span class="synPreProc">                  ScalarRef[`a]</span>
<span class="synPreProc">                  ArrayRef[`a]</span>
<span class="synPreProc">                  HashRef[`a]</span>
<span class="synPreProc">                  CodeRef</span>
<span class="synPreProc">                  RegexpRef</span>
<span class="synPreProc">                  GlobRef</span>
<span class="synPreProc">                  FileHandle</span>
<span class="synPreProc">                  Object</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> Any type followed by a type parameter </span><span class="synIdentifier">C&lt;[`a]&gt;</span><span class="synperlPOD"> can be</span>
<span class="synperlPOD">parameterized, this means you can say:</span>

<span class="synPreProc">  ArrayRef[Int]    # an array of integers</span>
<span class="synPreProc">  HashRef[CodeRef] # a hash of str to CODE ref mappings</span>
<span class="synPreProc">  ScalarRef[Int]   # a reference to an integer</span>
<span class="synPreProc">  Maybe[Str]       # value may be a string, may be undefined</span>

<span class="synperlPOD">If Moose finds a name in brackets that it does not recognize as an</span>
<span class="synperlPOD">existing type, it assumes that this is a class name, for example</span>
<span class="synIdentifier">C&lt;ArrayRef[DateTime]&gt;</span><span class="synperlPOD">.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> Unless you parameterize a type, then it is invalid to include</span>
<span class="synperlPOD">the square brackets. I.e. </span><span class="synIdentifier">C&lt;ArrayRef[]&gt;</span><span class="synperlPOD"> will be treated as a new type</span>
<span class="synperlPOD">name, </span><span class="synIdentifier">I&lt;not&gt;</span><span class="synperlPOD"> as a parameterization of </span><span class="synIdentifier">C&lt;ArrayRef&gt;</span><span class="synperlPOD">.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> The </span><span class="synIdentifier">C&lt;Undef&gt;</span><span class="synperlPOD"> type constraint for the most part works</span>
<span class="synperlPOD">correctly now, but edge cases may still exist, please use it</span>
<span class="synperlPOD">sparingly.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> The </span><span class="synIdentifier">C&lt;ClassName&gt;</span><span class="synperlPOD"> type constraint does a complex package</span>
<span class="synperlPOD">existence check. This means that your class </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synperlPOD"> be loaded for this</span>
<span class="synperlPOD">type constraint to pass.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> The </span><span class="synIdentifier">C&lt;RoleName&gt;</span><span class="synperlPOD"> constraint checks a string is a I&lt;package</span>
<span class="synperlPOD">name&gt; which is a role, like </span><span class="synIdentifier">C&lt;'MyApp::Role::Comparable'&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head2</span><span class="synString"> Type Constraint Naming</span>

<span class="synperlPOD">Type name declared via this module can only contain alphanumeric</span>
<span class="synperlPOD">characters, colons (:), and periods (.).</span>

<span class="synperlPOD">Since the types created by this module are global, it is suggested</span>
<span class="synperlPOD">that you namespace your types just as you would namespace your</span>
<span class="synperlPOD">modules. So instead of creating a </span><span class="synIdentifier">I&lt;Color&gt;</span><span class="synperlPOD"> type for your</span>
<span class="synIdentifier">B&lt;My::Graphics&gt;</span><span class="synperlPOD"> module, you would call the type</span>
<span class="synIdentifier">I&lt;My::Graphics::Types::Color&gt;</span><span class="synperlPOD"> instead.</span>

<span class="synStatement">=head2</span><span class="synString"> Use with Other Constraint Modules</span>

<span class="synperlPOD">This module can play nicely with other constraint modules with some</span>
<span class="synperlPOD">slight tweaking. The </span><span class="synIdentifier">C&lt;where&gt;</span><span class="synperlPOD"> clause in types is expected to be a</span>
<span class="synIdentifier">C&lt;CODE&gt;</span><span class="synperlPOD"> reference which checks its first argument and returns a</span>
<span class="synperlPOD">boolean. Since most constraint modules work in a similar way, it</span>
<span class="synperlPOD">should be simple to adapt them to work with Moose.</span>

<span class="synperlPOD">For instance, this is how you could use it with</span>
<span class="synIdentifier">L&lt;Declare::Constraints::Simple&gt;</span><span class="synperlPOD"> to declare a completely new type.</span>

<span class="synPreProc">  type 'HashOfArrayOfObjects',</span>
<span class="synPreProc">      where {</span>
<span class="synPreProc">          IsHashRef(</span>
<span class="synPreProc">              -keys   =&gt; HasLength,</span>
<span class="synPreProc">              -values =&gt; IsArrayRef(IsObject)</span>
<span class="synPreProc">          )-&gt;(@_);</span>
<span class="synPreProc">      };</span>

<span class="synperlPOD">For more examples see the </span><span class="synIdentifier">F&lt;t/examples/example_w_DCS.t&gt;</span><span class="synperlPOD"> test</span>
<span class="synperlPOD">file.</span>

<span class="synperlPOD">Here is an example of using </span><span class="synIdentifier">L&lt;Test::Deep&gt;</span><span class="synperlPOD"> and its non-test</span>
<span class="synperlPOD">related </span><span class="synIdentifier">C&lt;eq_deeply&gt;</span><span class="synperlPOD"> function.</span>

<span class="synPreProc">  type 'ArrayOfHashOfBarsAndRandomNumbers',</span>
<span class="synPreProc">      where {</span>
<span class="synPreProc">          eq_deeply($_,</span>
<span class="synPreProc">              array_each(subhashof({</span>
<span class="synPreProc">                  bar           =&gt; isa('Bar'),</span>
<span class="synPreProc">                  random_number =&gt; ignore()</span>
<span class="synPreProc">              })))</span>
<span class="synPreProc">        };</span>

<span class="synperlPOD">For a complete example see the</span>
<span class="synIdentifier">F&lt;t/examples/example_w_TestDeep.t&gt;</span><span class="synperlPOD"> test file.</span>

<span class="synStatement">=head2</span><span class="synString"> Error messages</span>

<span class="synperlPOD">Type constraints can also specify custom error messages, for when they fail to</span>
<span class="synperlPOD">validate. This is provided as just another coderef, which receives the invalid</span>
<span class="synperlPOD">value in </span><span class="synIdentifier">C&lt;$_&gt;</span><span class="synperlPOD">, as in:</span>

<span class="synPreProc">  subtype 'PositiveInt',</span>
<span class="synPreProc">       as 'Int',</span>
<span class="synPreProc">       where { $_ &gt; 0 },</span>
<span class="synPreProc">       message { &quot;$_ is not a positive integer!&quot; };</span>

<span class="synperlPOD">If no message is specified, a default message will be used, which indicates</span>
<span class="synperlPOD">which type constraint was being used and what value failed. If</span>
<span class="synIdentifier">L&lt;Devel::PartialDump&gt;</span><span class="synperlPOD"> (version 0.14 or higher) is installed, it will be used to</span>
<span class="synperlPOD">display the invalid value, otherwise it will just be printed as is.</span>

<span class="synStatement">=head1</span><span class="synString"> FUNCTIONS</span>

<span class="synStatement">=head2</span><span class="synString"> Type Constraint Constructors</span>

<span class="synperlPOD">The following functions are used to create type constraints.  They</span>
<span class="synperlPOD">will also register the type constraints your create in a global</span>
<span class="synperlPOD">registry that is used to look types up by name.</span>

<span class="synperlPOD">See the </span><span class="synIdentifier">L&lt;/SYNOPSIS&gt;</span><span class="synperlPOD"> for an example of how to use these.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; subtype 'Name', as 'Parent', where { } ... &gt;&gt;</span>

<span class="synperlPOD">This creates a named subtype.</span>

<span class="synperlPOD">If you provide a parent that Moose does not recognize, it will</span>
<span class="synperlPOD">automatically create a new class type constraint for this name.</span>

<span class="synperlPOD">When creating a named type, the </span><span class="synIdentifier">C&lt;subtype&gt;</span><span class="synperlPOD"> function should either be</span>
<span class="synperlPOD">called with the sugar helpers (</span><span class="synIdentifier">C&lt;where&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;message&gt;</span><span class="synperlPOD">, etc), or with a</span>
<span class="synperlPOD">name and a hashref of parameters:</span>

<span class="synPreProc"> subtype( 'Foo', { where =&gt; ..., message =&gt; ... } );</span>

<span class="synperlPOD">The valid hashref keys are </span><span class="synIdentifier">C&lt;as&gt;</span><span class="synperlPOD"> (the parent), </span><span class="synIdentifier">C&lt;where&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;message&gt;</span><span class="synperlPOD">,</span>
<span class="synperlPOD">and </span><span class="synIdentifier">C&lt;optimize_as&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; subtype as 'Parent', where { } ... &gt;&gt;</span>

<span class="synperlPOD">This creates an unnamed subtype and will return the type</span>
<span class="synperlPOD">constraint meta-object, which will be an instance of</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">When creating an anonymous type, the </span><span class="synIdentifier">C&lt;subtype&gt;</span><span class="synperlPOD"> function should either</span>
<span class="synperlPOD">be called with the sugar helpers (</span><span class="synIdentifier">C&lt;where&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;message&gt;</span><span class="synperlPOD">, etc), or with</span>
<span class="synperlPOD">just a hashref of parameters:</span>

<span class="synPreProc"> subtype( { where =&gt; ..., message =&gt; ... } );</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;class_type ($class, ?$options)&gt;</span>

<span class="synperlPOD">Creates a new subtype of </span><span class="synIdentifier">C&lt;Object&gt;</span><span class="synperlPOD"> with the name </span><span class="synIdentifier">C&lt;$class&gt;</span><span class="synperlPOD"> and the</span>
<span class="synperlPOD">metaclass </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Class&gt;</span><span class="synperlPOD">.</span>

<span class="synPreProc">  # Create a type called 'Box' which tests for objects which -&gt;isa('Box')</span>
<span class="synPreProc">  class_type 'Box';</span>

<span class="synperlPOD">By default, the name of the type and the name of the class are the same, but</span>
<span class="synperlPOD">you can specify both separately.</span>

<span class="synPreProc">  # Create a type called 'Box' which tests for objects which -&gt;isa('ObjectLibrary::Box');</span>
<span class="synPreProc">  class_type 'Box', { class =&gt; 'ObjectLibrary::Box' };</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;role_type ($role, ?$options)&gt;</span>

<span class="synperlPOD">Creates a </span><span class="synIdentifier">C&lt;Role&gt;</span><span class="synperlPOD"> type constraint with the name </span><span class="synIdentifier">C&lt;$role&gt;</span><span class="synperlPOD"> and the</span>
<span class="synperlPOD">metaclass </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Role&gt;</span><span class="synperlPOD">.</span>

<span class="synPreProc">  # Create a type called 'Walks' which tests for objects which -&gt;does('Walks')</span>
<span class="synPreProc">  role_type 'Walks';</span>

<span class="synperlPOD">By default, the name of the type and the name of the role are the same, but</span>
<span class="synperlPOD">you can specify both separately.</span>

<span class="synPreProc">  # Create a type called 'Walks' which tests for objects which -&gt;does('MooseX::Role::Walks');</span>
<span class="synPreProc">  role_type 'Walks', { role =&gt; 'MooseX::Role::Walks' };</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;maybe_type ($type)&gt;</span>

<span class="synperlPOD">Creates a type constraint for either </span><span class="synIdentifier">C&lt;undef&gt;</span><span class="synperlPOD"> or something of the</span>
<span class="synperlPOD">given type.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;duck_type ($name, \@methods)&gt;</span>

<span class="synperlPOD">This will create a subtype of Object and test to make sure the value</span>
<span class="synIdentifier">C&lt;can()&gt;</span><span class="synperlPOD"> do the methods in </span><span class="synIdentifier">C&lt;\@methods&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">This is intended as an easy way to accept non-Moose objects that</span>
<span class="synperlPOD">provide a certain interface. If you're using Moose classes, we</span>
<span class="synperlPOD">recommend that you use a </span><span class="synIdentifier">C&lt;requires&gt;</span><span class="synperlPOD">-only Role instead.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;duck_type (\@methods)&gt;</span>

<span class="synperlPOD">If passed an ARRAY reference as the only parameter instead of the</span>
<span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;\@methods&gt;</span><span class="synperlPOD"> pair, this will create an unnamed duck type.</span>
<span class="synperlPOD">This can be used in an attribute definition like so:</span>

<span class="synPreProc">  has 'cache' =&gt; (</span>
<span class="synPreProc">      is  =&gt; 'ro',</span>
<span class="synPreProc">      isa =&gt; duck_type( [qw( get_set )] ),</span>
<span class="synPreProc">  );</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;enum ($name, \@values)&gt;</span>

<span class="synperlPOD">This will create a basic subtype for a given set of strings.</span>
<span class="synperlPOD">The resulting constraint will be a subtype of </span><span class="synIdentifier">C&lt;Str&gt;</span><span class="synperlPOD"> and</span>
<span class="synperlPOD">will match any of the items in </span><span class="synIdentifier">C&lt;\@values&gt;</span><span class="synperlPOD">. It is case sensitive.</span>
<span class="synperlPOD">See the </span><span class="synIdentifier">L&lt;/SYNOPSIS&gt;</span><span class="synperlPOD"> for a simple example.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> This is not a true proper enum type, it is simply</span>
<span class="synperlPOD">a convenient constraint builder.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;enum (\@values)&gt;</span>

<span class="synperlPOD">If passed an ARRAY reference as the only parameter instead of the</span>
<span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;\@values&gt;</span><span class="synperlPOD"> pair, this will create an unnamed enum. This</span>
<span class="synperlPOD">can then be used in an attribute definition like so:</span>

<span class="synPreProc">  has 'sort_order' =&gt; (</span>
<span class="synPreProc">      is  =&gt; 'ro',</span>
<span class="synPreProc">      isa =&gt; enum([qw[ ascending descending ]]),</span>
<span class="synPreProc">  );</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;union ($name, \@constraints)&gt;</span>

<span class="synperlPOD">This will create a basic subtype where any of the provided constraints</span>
<span class="synperlPOD">may match in order to satisfy this constraint.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;union (\@constraints)&gt;</span>

<span class="synperlPOD">If passed an ARRAY reference as the only parameter instead of the</span>
<span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;\@constraints&gt;</span><span class="synperlPOD"> pair, this will create an unnamed union.</span>
<span class="synperlPOD">This can then be used in an attribute definition like so:</span>

<span class="synPreProc">  has 'items' =&gt; (</span>
<span class="synPreProc">      is =&gt; 'ro',</span>
<span class="synPreProc">      isa =&gt; union([qw[ Str ArrayRef ]]),</span>
<span class="synPreProc">  );</span>

<span class="synperlPOD">This is similar to the existing string union:</span>

<span class="synPreProc">  isa =&gt; 'Str|ArrayRef'</span>

<span class="synperlPOD">except that it supports anonymous elements as child constraints:</span>

<span class="synPreProc">  has 'color' =&gt; (</span>
<span class="synPreProc">    isa =&gt; 'ro',</span>
<span class="synPreProc">    isa =&gt; union([ 'Int',  enum([qw[ red green blue ]]) ]),</span>
<span class="synPreProc">  );</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;as 'Parent'&gt;</span>

<span class="synperlPOD">This is just sugar for the type constraint construction syntax.</span>

<span class="synperlPOD">It takes a single argument, which is the name of a parent type.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;where { ... }&gt;</span>

<span class="synperlPOD">This is just sugar for the type constraint construction syntax.</span>

<span class="synperlPOD">It takes a subroutine reference as an argument. When the type</span>
<span class="synperlPOD">constraint is tested, the reference is run with the value to be tested</span>
<span class="synperlPOD">in </span><span class="synIdentifier">C&lt;$_&gt;</span><span class="synperlPOD">. This reference should return true or false to indicate</span>
<span class="synperlPOD">whether or not the constraint check passed.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;message { ... }&gt;</span>

<span class="synperlPOD">This is just sugar for the type constraint construction syntax.</span>

<span class="synperlPOD">It takes a subroutine reference as an argument. When the type</span>
<span class="synperlPOD">constraint fails, then the code block is run with the value provided</span>
<span class="synperlPOD">in </span><span class="synIdentifier">C&lt;$_&gt;</span><span class="synperlPOD">. This reference should return a string, which will be used in</span>
<span class="synperlPOD">the text of the exception thrown.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;inline_as { ... }&gt;</span>

<span class="synperlPOD">This can be used to define a &quot;hand optimized&quot; inlinable version of your type</span>
<span class="synperlPOD">constraint.</span>

<span class="synperlPOD">You provide a subroutine which will be called </span><span class="synIdentifier">I&lt;as a method&gt;</span><span class="synperlPOD"> on a</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span><span class="synperlPOD"> object. It will receive a single parameter, the</span>
<span class="synperlPOD">name of the variable to check, typically something like </span><span class="synIdentifier">C&lt;&quot;$_&quot;&gt;</span><span class="synperlPOD"> or </span><span class="synIdentifier">C&lt;&quot;$_[0]&quot;&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">The subroutine should return a code string suitable for inlining. You can</span>
<span class="synperlPOD">assume that the check will be wrapped in parentheses when it is inlined.</span>

<span class="synperlPOD">The inlined code should include any checks that your type's parent types</span>
<span class="synperlPOD">do. If your parent type constraint defines its own inlining, you can simply use</span>
<span class="synperlPOD">that to avoid repeating code. For example, here is the inlining code for the</span>
<span class="synIdentifier">C&lt;Value&gt;</span><span class="synperlPOD"> type, which is a subtype of </span><span class="synIdentifier">C&lt;Defined&gt;</span><span class="synperlPOD">:</span>

<span class="synPreProc">    sub {</span>
<span class="synPreProc">        $_[0]-&gt;parent()-&gt;_inline_check($_[1])</span>
<span class="synPreProc">        . ' &amp;&amp; !ref(' . $_[1] . ')'</span>
<span class="synPreProc">    }</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;optimize_as { ... }&gt;</span>

<span class="synIdentifier">B&lt;This feature is deprecated, use C&lt;inline_as&gt; instead.&gt;</span>

<span class="synperlPOD">This can be used to define a &quot;hand optimized&quot; version of your</span>
<span class="synperlPOD">type constraint which can be used to avoid traversing a subtype</span>
<span class="synperlPOD">constraint hierarchy.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> You should only use this if you know what you are doing.</span>
<span class="synperlPOD">All the built in types use this, so your subtypes (assuming they</span>
<span class="synperlPOD">are shallow) will not likely need to use this.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; type 'Name', where { } ... &gt;&gt;</span>

<span class="synperlPOD">This creates a base type, which has no parent.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;type&gt;</span><span class="synperlPOD"> function should either be called with the sugar helpers</span>
<span class="synperlPOD">(</span><span class="synIdentifier">C&lt;where&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;message&gt;</span><span class="synperlPOD">, etc), or with a name and a hashref of</span>
<span class="synperlPOD">parameters:</span>

<span class="synPreProc">  type( 'Foo', { where =&gt; ..., message =&gt; ... } );</span>

<span class="synperlPOD">The valid hashref keys are </span><span class="synIdentifier">C&lt;where&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;message&gt;</span><span class="synperlPOD">, and </span><span class="synIdentifier">C&lt;inlined_as&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Type Constraint Utilities</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; match_on_type $value =&gt; ( $type =&gt; \&amp;action, ... ?\&amp;default ) &gt;&gt;</span>

<span class="synperlPOD">This is a utility function for doing simple type based dispatching similar to</span>
<span class="synperlPOD">match/case in OCaml and case/of in Haskell. It is not as featureful as those</span>
<span class="synperlPOD">languages, nor does not it support any kind of automatic destructuring</span>
<span class="synperlPOD">bind. Here is a simple Perl pretty printer dispatching over the core Moose</span>
<span class="synperlPOD">types.</span>

<span class="synPreProc">  sub ppprint {</span>
<span class="synPreProc">      my $x = shift;</span>
<span class="synPreProc">      match_on_type $x =&gt; (</span>
<span class="synPreProc">          HashRef =&gt; sub {</span>
<span class="synPreProc">              my $hash = shift;</span>
<span class="synPreProc">              '{ '</span>
<span class="synPreProc">                  . (</span>
<span class="synPreProc">                  join &quot;, &quot; =&gt; map { $_ . ' =&gt; ' . ppprint( $hash-&gt;{$_} ) }</span>
<span class="synPreProc">                      sort keys %$hash</span>
<span class="synPreProc">                  ) . ' }';</span>
<span class="synPreProc">          },</span>
<span class="synPreProc">          ArrayRef =&gt; sub {</span>
<span class="synPreProc">              my $array = shift;</span>
<span class="synPreProc">              '[ ' . ( join &quot;, &quot; =&gt; map { ppprint($_) } @$array ) . ' ]';</span>
<span class="synPreProc">          },</span>
<span class="synPreProc">          CodeRef   =&gt; sub {'sub { ... }'},</span>
<span class="synPreProc">          RegexpRef =&gt; sub { 'qr/' . $_ . '/' },</span>
<span class="synPreProc">          GlobRef   =&gt; sub { '*' . B::svref_2object($_)-&gt;NAME },</span>
<span class="synPreProc">          Object    =&gt; sub { $_-&gt;can('to_string') ? $_-&gt;to_string : $_ },</span>
<span class="synPreProc">          ScalarRef =&gt; sub { '\\' . ppprint( ${$_} ) },</span>
<span class="synPreProc">          Num       =&gt; sub {$_},</span>
<span class="synPreProc">          Str       =&gt; sub { '&quot;' . $_ . '&quot;' },</span>
<span class="synPreProc">          Undef     =&gt; sub {'undef'},</span>
<span class="synPreProc">          =&gt; sub { die &quot;I don't know what $_ is&quot; }</span>
<span class="synPreProc">      );</span>
<span class="synPreProc">  }</span>

<span class="synperlPOD">Or a simple JSON serializer:</span>

<span class="synPreProc">  sub to_json {</span>
<span class="synPreProc">      my $x = shift;</span>
<span class="synPreProc">      match_on_type $x =&gt; (</span>
<span class="synPreProc">          HashRef =&gt; sub {</span>
<span class="synPreProc">              my $hash = shift;</span>
<span class="synPreProc">              '{ '</span>
<span class="synPreProc">                  . (</span>
<span class="synPreProc">                  join &quot;, &quot; =&gt;</span>
<span class="synPreProc">                      map { '&quot;' . $_ . '&quot; : ' . to_json( $hash-&gt;{$_} ) }</span>
<span class="synPreProc">                      sort keys %$hash</span>
<span class="synPreProc">                  ) . ' }';</span>
<span class="synPreProc">          },</span>
<span class="synPreProc">          ArrayRef =&gt; sub {</span>
<span class="synPreProc">              my $array = shift;</span>
<span class="synPreProc">              '[ ' . ( join &quot;, &quot; =&gt; map { to_json($_) } @$array ) . ' ]';</span>
<span class="synPreProc">          },</span>
<span class="synPreProc">          Num   =&gt; sub {$_},</span>
<span class="synPreProc">          Str   =&gt; sub { '&quot;' . $_ . '&quot;' },</span>
<span class="synPreProc">          Undef =&gt; sub {'null'},</span>
<span class="synPreProc">          =&gt; sub { die &quot;$_ is not acceptable json type&quot; }</span>
<span class="synPreProc">      );</span>
<span class="synPreProc">  }</span>

<span class="synperlPOD">The matcher is done by mapping a </span><span class="synIdentifier">C&lt;$type&gt;</span><span class="synperlPOD"> to an </span><span class="synIdentifier">C&lt;\&amp;action&gt;</span><span class="synperlPOD">. The </span><span class="synIdentifier">C&lt;$type&gt;</span><span class="synperlPOD"> can</span>
<span class="synperlPOD">be either a string type or a </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span><span class="synperlPOD"> object, and</span>
<span class="synIdentifier">C&lt;\&amp;action&gt;</span><span class="synperlPOD"> is a subroutine reference. This function will dispatch on the</span>
<span class="synperlPOD">first match for </span><span class="synIdentifier">C&lt;$value&gt;</span><span class="synperlPOD">. It is possible to have a catch-all by providing an</span>
<span class="synperlPOD">additional subroutine reference as the final argument to </span><span class="synIdentifier">C&lt;match_on_type&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Type Coercion Constructors</span>

<span class="synperlPOD">You can define coercions for type constraints, which allow you to</span>
<span class="synperlPOD">automatically transform values to something valid for the type</span>
<span class="synperlPOD">constraint. If you ask your accessor to coerce, then Moose will run</span>
<span class="synperlPOD">the type-coercion code first, followed by the type constraint</span>
<span class="synperlPOD">check. This feature should be used carefully as it is very powerful</span>
<span class="synperlPOD">and could easily take off a limb if you are not careful.</span>

<span class="synperlPOD">See the </span><span class="synIdentifier">L&lt;/SYNOPSIS&gt;</span><span class="synperlPOD"> for an example of how to use these.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; coerce 'Name', from 'OtherName', via { ... }  &gt;&gt;</span>

<span class="synperlPOD">This defines a coercion from one type to another. The </span><span class="synIdentifier">C&lt;Name&gt;</span><span class="synperlPOD"> argument</span>
<span class="synperlPOD">is the type you are coercing </span><span class="synIdentifier">I&lt;to&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">To define multiple coercions, supply more sets of from/via pairs:</span>

<span class="synPreProc">  coerce 'Name',</span>
<span class="synPreProc">    from 'OtherName', via { ... },</span>
<span class="synPreProc">    from 'ThirdName', via { ... };</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;from 'OtherName'&gt;</span>

<span class="synperlPOD">This is just sugar for the type coercion construction syntax.</span>

<span class="synperlPOD">It takes a single type name (or type object), which is the type being</span>
<span class="synperlPOD">coerced </span><span class="synIdentifier">I&lt;from&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;via { ... }&gt;</span>

<span class="synperlPOD">This is just sugar for the type coercion construction syntax.</span>

<span class="synperlPOD">It takes a subroutine reference. This reference will be called with</span>
<span class="synperlPOD">the value to be coerced in </span><span class="synIdentifier">C&lt;$_&gt;</span><span class="synperlPOD">. It is expected to return a new value</span>
<span class="synperlPOD">of the proper type for the coercion.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Creating and Finding Type Constraints</span>

<span class="synperlPOD">These are additional functions for creating and finding type</span>
<span class="synperlPOD">constraints. Most of these functions are not available for</span>
<span class="synperlPOD">importing. The ones that are importable as specified.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;find_type_constraint($type_name)&gt;</span>

<span class="synperlPOD">This function can be used to locate the </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span>
<span class="synperlPOD">object for a named type.</span>

<span class="synperlPOD">This function is importable.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;register_type_constraint($type_object)&gt;</span>

<span class="synperlPOD">This function will register a </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint&gt;</span><span class="synperlPOD"> with the</span>
<span class="synperlPOD">global type registry.</span>

<span class="synperlPOD">This function is importable.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;normalize_type_constraint_name($type_constraint_name)&gt;</span>

<span class="synperlPOD">This method takes a type constraint name and returns the normalized</span>
<span class="synperlPOD">form. This removes any whitespace in the string.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_type_constraint_union($pipe_separated_types | @type_constraint_names)&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)&gt;</span>

<span class="synperlPOD">This can take a union type specification like </span><span class="synIdentifier">C&lt;'Int|ArrayRef[Int]'&gt;</span><span class="synperlPOD">,</span>
<span class="synperlPOD">or a list of names. It returns a new</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Union&gt;</span><span class="synperlPOD"> object.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_parameterized_type_constraint($type_name)&gt;</span>

<span class="synperlPOD">Given a </span><span class="synIdentifier">C&lt;$type_name&gt;</span><span class="synperlPOD"> in the form of </span><span class="synIdentifier">C&lt;'BaseType[ContainerType]'&gt;</span><span class="synperlPOD">,</span>
<span class="synperlPOD">this will create a new </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Parameterized&gt;</span>
<span class="synperlPOD">object. The </span><span class="synIdentifier">C&lt;BaseType&gt;</span><span class="synperlPOD"> must exist already exist as a parameterizable</span>
<span class="synperlPOD">type.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_class_type_constraint($class, $options)&gt;</span>

<span class="synperlPOD">Given a class name this function will create a new</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Class&gt;</span><span class="synperlPOD"> object for that class name.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;$options&gt;</span><span class="synperlPOD"> is a hash reference that will be passed to the</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Class&gt;</span><span class="synperlPOD"> constructor (as a hash).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_role_type_constraint($role, $options)&gt;</span>

<span class="synperlPOD">Given a role name this function will create a new</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Role&gt;</span><span class="synperlPOD"> object for that role name.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;$options&gt;</span><span class="synperlPOD"> is a hash reference that will be passed to the</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Role&gt;</span><span class="synperlPOD"> constructor (as a hash).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_enum_type_constraint($name, $values)&gt;</span>

<span class="synperlPOD">Given a enum name this function will create a new</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Enum&gt;</span><span class="synperlPOD"> object for that enum name.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;create_duck_type_constraint($name, $methods)&gt;</span>

<span class="synperlPOD">Given a duck type name this function will create a new</span>
<span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::DuckType&gt;</span><span class="synperlPOD"> object for that enum name.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;find_or_parse_type_constraint($type_name)&gt;</span>

<span class="synperlPOD">Given a type name, this first attempts to find a matching constraint</span>
<span class="synperlPOD">in the global registry.</span>

<span class="synperlPOD">If the type name is a union or parameterized type, it will create a</span>
<span class="synperlPOD">new object of the appropriate, but if given a &quot;regular&quot; type that does</span>
<span class="synperlPOD">not yet exist, it simply returns false.</span>

<span class="synperlPOD">When given a union or parameterized type, the member or base type must</span>
<span class="synperlPOD">already exist.</span>

<span class="synperlPOD">If it creates a new union or parameterized type, it will add it to the</span>
<span class="synperlPOD">global registry.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;find_or_create_isa_type_constraint($type_name)&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;find_or_create_does_type_constraint($type_name)&gt;</span>

<span class="synperlPOD">These functions will first call </span><span class="synIdentifier">C&lt;find_or_parse_type_constraint&gt;</span><span class="synperlPOD">. If</span>
<span class="synperlPOD">that function does not return a type, a new type object will</span>
<span class="synperlPOD">be created.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;isa&gt;</span><span class="synperlPOD"> variant will use </span><span class="synIdentifier">C&lt;create_class_type_constraint&gt;</span><span class="synperlPOD"> and the</span>
<span class="synIdentifier">C&lt;does&gt;</span><span class="synperlPOD"> variant will use </span><span class="synIdentifier">C&lt;create_role_type_constraint&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;get_type_constraint_registry&gt;</span>

<span class="synperlPOD">Returns the </span><span class="synIdentifier">L&lt;Moose::Meta::TypeConstraint::Registry&gt;</span><span class="synperlPOD"> object which</span>
<span class="synperlPOD">keeps track of all type constraints.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;list_all_type_constraints&gt;</span>

<span class="synperlPOD">This will return a list of type constraint names in the global</span>
<span class="synperlPOD">registry. You can then fetch the actual type object using</span>
<span class="synIdentifier">C&lt;find_type_constraint($type_name)&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;list_all_builtin_type_constraints&gt;</span>

<span class="synperlPOD">This will return a list of builtin type constraints, meaning those</span>
<span class="synperlPOD">which are defined in this module. See the </span><span class="synIdentifier">L&lt;Default Type Constraints&gt;</span>
<span class="synperlPOD">section for a complete list.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;export_type_constraints_as_functions&gt;</span>

<span class="synperlPOD">This will export all the current type constraints as functions into</span>
<span class="synperlPOD">the caller's namespace (</span><span class="synIdentifier">C&lt;Int()&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;Str()&gt;</span><span class="synperlPOD">, etc). Right now, this is</span>
<span class="synperlPOD">mostly used for testing, but it might prove useful to others.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;get_all_parameterizable_types&gt;</span>

<span class="synperlPOD">This returns all the parameterizable types that have been registered,</span>
<span class="synperlPOD">as a list of type objects.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;add_parameterizable_type($type)&gt;</span>

<span class="synperlPOD">Adds </span><span class="synIdentifier">C&lt;$type&gt;</span><span class="synperlPOD"> to the list of parameterizable types</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Moose/BUGS&gt;</span><span class="synperlPOD"> for details on reporting bugs.</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

<span class="synperlPOD">Moose is maintained by the Moose Cabal, along with the help of many contributors. See </span><span class="synIdentifier">L&lt;Moose/CABAL&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span><span class="synperlPOD"> for details.</span>

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

<span class="synperlPOD">This software is copyright (c) 2013 by Infinity Interactive, Inc..</span>

<span class="synperlPOD">This is free software; you can redistribute it and/or modify it under</span>
<span class="synperlPOD">the same terms as the Perl 5 programming language system itself.</span>

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
