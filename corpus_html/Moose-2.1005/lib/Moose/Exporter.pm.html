<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre><span class="synStatement">package</span><span class="synType"> Moose::Exporter</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Moose::Exporter::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Moose::Exporter::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;

<span class="synStatement">use </span>Class::Load <span class="synString">qw(is_class_loaded)</span>;
<span class="synStatement">use </span>Class::MOP;
<span class="synStatement">use </span>List::MoreUtils <span class="synString">qw( first_index uniq )</span>;
<span class="synStatement">use </span>Moose::Util::MetaRole;
<span class="synStatement">use </span>Scalar::Util <span class="synString">qw(reftype)</span>;
<span class="synStatement">use </span>Sub::Exporter <span class="synFloat">0.980</span>;
<span class="synStatement">use </span>Sub::Name <span class="synString">qw(subname)</span>;

<span class="synStatement">my</span> <span class="synIdentifier">%EXPORT_SPEC</span>;

<span class="synKeyword">sub </span><span class="synFunction">setup_import_methods </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$class</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$args{</span><span class="synString">exporting_package</span><span class="synIdentifier">}</span> ||= <span class="synStatement">caller</span>();

    <span class="synIdentifier">$class-&gt;build_import_methods</span>(
        <span class="synIdentifier">%args</span>,
        <span class="synString">install</span> =&gt; [<span class="synString">qw(import unimport init_meta)</span>]
    );
}

<span class="synComment"># A reminder to intrepid Moose hackers</span>
<span class="synComment"># there may be more than one level of exporter</span>
<span class="synComment"># don't make doy cry. -- perigrin</span>

<span class="synKeyword">sub </span><span class="synFunction">build_import_methods </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$class</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$exporting_package</span> = <span class="synIdentifier">$args{</span><span class="synString">exporting_package</span><span class="synIdentifier">}</span> ||= <span class="synStatement">caller</span>();

    <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup</span> = <span class="synIdentifier">$args{</span><span class="synString">meta_lookup</span><span class="synIdentifier">}</span> || <span class="synKeyword">sub </span>{ Class::MOP::class_of(<span class="synStatement">shift</span>) };

    <span class="synIdentifier">$EXPORT_SPEC{$exporting_package}</span> = \<span class="synIdentifier">%args</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@exports_from</span> = <span class="synIdentifier">$class-&gt;_follow_also</span>(<span class="synIdentifier">$exporting_package</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$export_recorder</span> = {};
    <span class="synStatement">my</span> <span class="synIdentifier">$is_reexport</span>     = {};

    <span class="synStatement">my</span> <span class="synIdentifier">$exports</span> = <span class="synIdentifier">$class-&gt;_make_sub_exporter_params</span>(
        [ <span class="synIdentifier">$exporting_package</span>, <span class="synIdentifier">@exports_from</span> ],
        <span class="synIdentifier">$export_recorder</span>,
        <span class="synIdentifier">$is_reexport</span>,
        <span class="synIdentifier">$args{</span><span class="synString">meta_lookup</span><span class="synIdentifier">}</span>, <span class="synComment"># so that we don't pass through the default</span>
    );

    <span class="synStatement">my</span> <span class="synIdentifier">$exporter</span> = <span class="synIdentifier">$class-&gt;_make_exporter</span>(
        <span class="synIdentifier">$exports</span>,
        <span class="synIdentifier">$is_reexport</span>,
        <span class="synIdentifier">$meta_lookup</span>,
    );

    <span class="synStatement">my</span> <span class="synIdentifier">%methods</span>;
    <span class="synIdentifier">$methods{</span><span class="synString">import</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$class-&gt;_make_import_sub</span>(
        <span class="synIdentifier">$exporting_package</span>,
        <span class="synIdentifier">$exporter</span>,
        \<span class="synIdentifier">@exports_from</span>,
        <span class="synIdentifier">$is_reexport</span>,
        <span class="synIdentifier">$meta_lookup</span>,
    );

    <span class="synIdentifier">$methods{</span><span class="synString">unimport</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$class-&gt;_make_unimport_sub</span>(
        <span class="synIdentifier">$exporting_package</span>,
        <span class="synIdentifier">$exports</span>,
        <span class="synIdentifier">$export_recorder</span>,
        <span class="synIdentifier">$is_reexport</span>,
        <span class="synIdentifier">$meta_lookup</span>,
    );

    <span class="synIdentifier">$methods{</span><span class="synString">init_meta</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$class-&gt;_make_init_meta</span>(
        <span class="synIdentifier">$exporting_package</span>,
        \<span class="synIdentifier">%args</span>,
        <span class="synIdentifier">$meta_lookup</span>,
    );

    <span class="synStatement">my</span> <span class="synIdentifier">$package</span> = Class::MOP::Package-&gt;initialize(<span class="synIdentifier">$exporting_package</span>);
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$to_install</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$args{</span><span class="synString">install</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> || [] </span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$symbol</span> = <span class="synString">'&amp;'</span> . <span class="synIdentifier">$to_install</span>;
        <span class="synStatement">next</span>
            <span class="synConditional">unless</span> <span class="synIdentifier">$methods{$to_install}</span>
                &amp;&amp; !<span class="synIdentifier">$package-&gt;has_package_symbol</span>(<span class="synIdentifier">$symbol</span>);
        <span class="synIdentifier">$package-&gt;add_package_symbol</span>( <span class="synIdentifier">$symbol</span>, <span class="synIdentifier">$methods{$to_install}</span> );
    }

    <span class="synStatement">return</span> ( <span class="synIdentifier">$methods{</span><span class="synString">import</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$methods{</span><span class="synString">unimport</span><span class="synIdentifier">}</span>, <span class="synIdentifier">$methods{</span><span class="synString">init_meta</span><span class="synIdentifier">}</span> );
}

<span class="synKeyword">sub </span><span class="synFunction">_make_exporter </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>, <span class="synIdentifier">$exports</span>, <span class="synIdentifier">$is_reexport</span>, <span class="synIdentifier">$meta_lookup</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> Sub::Exporter::build_exporter(
        {
            <span class="synString">exports</span>   =&gt; <span class="synIdentifier">$exports</span>,
            <span class="synString">groups</span>    =&gt; { <span class="synString">default</span> =&gt; [<span class="synString">':all'</span>] },
            <span class="synString">installer</span> =&gt; <span class="synKeyword">sub </span>{
                <span class="synStatement">my</span> (<span class="synIdentifier">$arg</span>, <span class="synIdentifier">$to_export</span>) = <span class="synIdentifier">@_</span>;
                <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$meta_lookup</span>-&gt;(<span class="synIdentifier">$arg-&gt;{</span><span class="synString">into</span><span class="synIdentifier">}</span>);

                <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Sub::Exporter::</span><span class="synIdentifier">default_installer</span> <span class="synConditional">unless</span> <span class="synIdentifier">$meta</span>;

                <span class="synComment"># don't overwrite existing symbols with our magically flagged</span>
                <span class="synComment"># version of it if we would install the same sub that's already</span>
                <span class="synComment"># in the importer</span>

                <span class="synStatement">my</span> <span class="synIdentifier">@filtered_to_export</span>;
                <span class="synStatement">my</span> <span class="synIdentifier">%installed</span>;
                <span class="synRepeat">for</span> (<span class="synStatement">my</span> <span class="synIdentifier">$i</span> = <span class="synNumber">0</span>; <span class="synIdentifier">$i</span> &lt; <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$to_export</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>; <span class="synIdentifier">$i</span> += <span class="synNumber">2</span>) {
                    <span class="synStatement">my</span> (<span class="synIdentifier">$as</span>, <span class="synIdentifier">$cv</span>) = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$to_export</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}[$i</span><span class="synperlVarMember">, </span><span class="synIdentifier">$i</span><span class="synperlVarMember"> + </span><span class="synNumber">1</span><span class="synIdentifier">]</span>;

                    <span class="synStatement">next</span> <span class="synConditional">if</span> !<span class="synOperator">ref</span>(<span class="synIdentifier">$as</span>)
                         &amp;&amp; <span class="synIdentifier">$meta-&gt;has_package_symbol</span>(<span class="synString">'&amp;'</span> . <span class="synIdentifier">$as</span>)
                         &amp;&amp; <span class="synIdentifier">$meta-&gt;get_package_symbol</span>(<span class="synString">'&amp;'</span> . <span class="synIdentifier">$as</span>) == <span class="synIdentifier">$cv</span>;

                    <span class="synStatement">push</span> <span class="synIdentifier">@filtered_to_export</span>, <span class="synIdentifier">$as</span>, <span class="synIdentifier">$cv</span>;
                    <span class="synIdentifier">$installed{$as}</span> = <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synOperator">ref</span> <span class="synIdentifier">$as</span>;
                }

                Sub::Exporter::default_installer(<span class="synIdentifier">$arg</span>, \<span class="synIdentifier">@filtered_to_export</span>);

                <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$name</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%{$is_reexport}</span> ) {
                    <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;
                    <span class="synStatement">no warnings</span> <span class="synString">'once'</span>;
                    <span class="synStatement">next</span> <span class="synConditional">unless</span> <span class="synStatement">exists</span> <span class="synIdentifier">$installed{$name}</span>;
                    _flag_as_reexport( \<span class="synIdentifier">*{</span><span class="synperlVarBlock2"> </span><span class="synStatement">join</span><span class="synperlVarBlock2"> </span><span class="synString">q{::}</span><span class="synperlVarBlock2">, </span><span class="synIdentifier">$arg-&gt;{</span><span class="synString">into</span><span class="synIdentifier">}</span><span class="synperlVarBlock2">, </span><span class="synIdentifier">$name</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> );
                }
            },
        }
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_follow_also </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>             = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$exporting_package</span> = <span class="synStatement">shift</span>;

    _die_if_cycle_found_in_also_list_for_package(<span class="synIdentifier">$exporting_package</span>);

    <span class="synStatement">return</span> uniq( _follow_also_real(<span class="synIdentifier">$exporting_package</span>) );
}

<span class="synKeyword">sub </span><span class="synFunction">_follow_also_real </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$exporting_package</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@also</span>              = _also_list_for_package(<span class="synIdentifier">$exporting_package</span>);

    <span class="synStatement">return</span> <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_</span>, _follow_also_real(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">@also</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_also_list_for_package </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$package</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( !<span class="synStatement">exists</span> <span class="synIdentifier">$EXPORT_SPEC{$package}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$loaded</span> = is_class_loaded(<span class="synIdentifier">$package</span>);

        <span class="synStatement">die</span> <span class="synString">&quot;Package in also (</span><span class="synIdentifier">$package</span><span class="synString">) does not seem to &quot;</span>
            . <span class="synString">&quot;use Moose::Exporter&quot;</span>
            . ( <span class="synIdentifier">$loaded</span> ? <span class="synString">&quot;&quot;</span> : <span class="synString">&quot; (is it loaded?)&quot;</span> );
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$also</span> = <span class="synIdentifier">$EXPORT_SPEC{$package}{</span><span class="synString">also</span><span class="synIdentifier">}</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$also</span>;

    <span class="synStatement">return</span> <span class="synOperator">ref</span> <span class="synIdentifier">$also</span> ? <span class="synIdentifier">@$also</span> : <span class="synIdentifier">$also</span>;
}

<span class="synComment"># this is no Tarjan algorithm, but for the list sizes expected,</span>
<span class="synComment"># brute force will probably be fine (and more maintainable)</span>
<span class="synKeyword">sub </span><span class="synFunction">_die_if_cycle_found_in_also_list_for_package </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$package</span> = <span class="synStatement">shift</span>;
    _die_if_also_list_cycles_back_to_existing_stack(
        [ _also_list_for_package(<span class="synIdentifier">$package</span>) ],
        [<span class="synIdentifier">$package</span>],
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_die_if_also_list_cycles_back_to_existing_stack </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$also_list</span>, <span class="synIdentifier">$existing_stack</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">@$also_list</span> &amp;&amp; <span class="synIdentifier">@$existing_stack</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$also_member</span> (<span class="synIdentifier">@$also_list</span>) {
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$stack_member</span> (<span class="synIdentifier">@$existing_stack</span>) {
            <span class="synStatement">next</span> <span class="synConditional">unless</span> <span class="synIdentifier">$also_member</span> <span class="synOperator">eq</span> <span class="synIdentifier">$stack_member</span>;

            <span class="synStatement">die</span>
                <span class="synString">&quot;Circular reference in 'also' parameter to Moose::Exporter between &quot;</span>
                . <span class="synStatement">join</span>(
                <span class="synString">', '</span>,
                <span class="synIdentifier">@$existing_stack</span>
                ) . <span class="synString">&quot; and </span><span class="synIdentifier">$also_member</span><span class="synString">&quot;</span>;
        }

        _die_if_also_list_cycles_back_to_existing_stack(
            [ _also_list_for_package(<span class="synIdentifier">$also_member</span>) ],
            [ <span class="synIdentifier">$also_member</span>, <span class="synIdentifier">@$existing_stack</span> ],
        );
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_parse_trait_aliases </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>   = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$package</span>, <span class="synIdentifier">$aliases</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@ret</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$alias</span> (<span class="synIdentifier">@$aliases</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$name</span>;
        <span class="synConditional">if</span> (<span class="synOperator">ref</span>(<span class="synIdentifier">$alias</span>)) {
            reftype(<span class="synIdentifier">$alias</span>) <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span>
                <span class="synOperator">or</span> Moose-&gt;throw_error(reftype(<span class="synIdentifier">$alias</span>) . <span class="synString">&quot; references are not &quot;</span>
                                    . <span class="synString">&quot;valid arguments to the 'trait_aliases' &quot;</span>
                                    . <span class="synString">&quot;option&quot;</span>);

            (<span class="synIdentifier">$alias</span>, <span class="synIdentifier">$name</span>) = <span class="synIdentifier">@$alias</span>;
        }
        <span class="synConditional">else</span> {
            (<span class="synIdentifier">$name</span> = <span class="synIdentifier">$alias</span>) =~ <span class="synStatement">s/</span><span class="synSpecial">.*</span><span class="synString">::</span><span class="synStatement">//</span>;
        }
        <span class="synStatement">push</span> <span class="synIdentifier">@ret</span>, subname <span class="synString">&quot;</span><span class="synIdentifier">${package}</span><span class="synString">::</span><span class="synIdentifier">${name}</span><span class="synString">&quot;</span> =&gt; <span class="synKeyword">sub </span><span class="synType">() </span>{ <span class="synIdentifier">$alias</span> };
    }

    <span class="synStatement">return</span> <span class="synIdentifier">@ret</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_make_sub_exporter_params </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>                = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$packages</span>             = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$export_recorder</span>      = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$is_reexport</span>          = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup_override</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%exports</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$current_meta_lookup</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$package</span> ( <span class="synIdentifier">@{$packages}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$args</span> = <span class="synIdentifier">$EXPORT_SPEC{$package}</span>
            <span class="synOperator">or</span> <span class="synStatement">die</span> <span class="synString">&quot;The </span><span class="synIdentifier">$package</span><span class="synString"> package does not use Moose::Exporter</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;

        <span class="synIdentifier">$current_meta_lookup</span> = <span class="synIdentifier">$meta_lookup_override</span> || <span class="synIdentifier">$args-&gt;{</span><span class="synString">meta_lookup</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$meta_lookup_override</span> = <span class="synIdentifier">$current_meta_lookup</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup</span> = <span class="synIdentifier">$current_meta_lookup</span>
                       || <span class="synKeyword">sub </span>{ Class::MOP::class_of(<span class="synStatement">shift</span>) };

        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$name</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$args-&gt;{</span><span class="synString">with_meta</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span> ) {
            <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = <span class="synIdentifier">$class-&gt;_sub_from_package</span>( <span class="synIdentifier">$package</span>, <span class="synIdentifier">$name</span> )
                <span class="synOperator">or</span> <span class="synStatement">next</span>;

            <span class="synStatement">my</span> <span class="synIdentifier">$fq_name</span> = <span class="synIdentifier">$package</span> . <span class="synString">'::'</span> . <span class="synIdentifier">$name</span>;

            <span class="synIdentifier">$exports{$name}</span> = <span class="synIdentifier">$class-&gt;_make_wrapped_sub_with_meta</span>(
                <span class="synIdentifier">$fq_name</span>,
                <span class="synIdentifier">$sub</span>,
                <span class="synIdentifier">$export_recorder</span>,
                <span class="synIdentifier">$meta_lookup</span>,
            ) <span class="synConditional">unless</span> <span class="synStatement">exists</span> <span class="synIdentifier">$exports{$name}</span>;
        }

        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$name</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$args-&gt;{</span><span class="synString">with_caller</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span> ) {
            <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = <span class="synIdentifier">$class-&gt;_sub_from_package</span>( <span class="synIdentifier">$package</span>, <span class="synIdentifier">$name</span> )
                <span class="synOperator">or</span> <span class="synStatement">next</span>;

            <span class="synStatement">my</span> <span class="synIdentifier">$fq_name</span> = <span class="synIdentifier">$package</span> . <span class="synString">'::'</span> . <span class="synIdentifier">$name</span>;

            <span class="synIdentifier">$exports{$name}</span> = <span class="synIdentifier">$class-&gt;_make_wrapped_sub</span>(
                <span class="synIdentifier">$fq_name</span>,
                <span class="synIdentifier">$sub</span>,
                <span class="synIdentifier">$export_recorder</span>,
            ) <span class="synConditional">unless</span> <span class="synStatement">exists</span> <span class="synIdentifier">$exports{$name}</span>;
        }

        <span class="synStatement">my</span> <span class="synIdentifier">@extra_exports</span> = <span class="synIdentifier">$class-&gt;_parse_trait_aliases</span>(
            <span class="synIdentifier">$package</span>, <span class="synIdentifier">$args-&gt;{</span><span class="synString">trait_aliases</span><span class="synIdentifier">}</span>,
        );
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$name</span> ( <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$args-&gt;{</span><span class="synString">as_is</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>, <span class="synIdentifier">@extra_exports</span> ) {
            <span class="synStatement">my</span> ( <span class="synIdentifier">$sub</span>, <span class="synIdentifier">$coderef_name</span> );

            <span class="synConditional">if</span> ( <span class="synOperator">ref</span> <span class="synIdentifier">$name</span> ) {
                <span class="synIdentifier">$sub</span> = <span class="synIdentifier">$name</span>;

                <span class="synStatement">my</span> <span class="synIdentifier">$coderef_pkg</span>;
                ( <span class="synIdentifier">$coderef_pkg</span>, <span class="synIdentifier">$coderef_name</span> )
                    = Class::MOP::get_code_info(<span class="synIdentifier">$name</span>);

                <span class="synConditional">if</span> ( <span class="synIdentifier">$coderef_pkg</span> <span class="synOperator">ne</span> <span class="synIdentifier">$package</span> ) {
                    <span class="synIdentifier">$is_reexport-&gt;{$coderef_name}</span> = <span class="synNumber">1</span>;
                }
            }
            <span class="synConditional">else</span> {
                <span class="synIdentifier">$sub</span> = <span class="synIdentifier">$class-&gt;_sub_from_package</span>( <span class="synIdentifier">$package</span>, <span class="synIdentifier">$name</span> )
                    <span class="synOperator">or</span> <span class="synStatement">next</span>;

                <span class="synIdentifier">$coderef_name</span> = <span class="synIdentifier">$name</span>;
            }

            <span class="synIdentifier">$export_recorder-&gt;{$sub}</span> = <span class="synNumber">1</span>;

            <span class="synIdentifier">$exports{$coderef_name}</span> = <span class="synKeyword">sub </span>{ <span class="synIdentifier">$sub</span> }
                <span class="synConditional">unless</span> <span class="synStatement">exists</span> <span class="synIdentifier">$exports{$coderef_name}</span>;
        }
    }

    <span class="synStatement">return</span> \<span class="synIdentifier">%exports</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_sub_from_package </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$sclass</span>  = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$package</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span>    = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = <span class="synOperator">do</span> {
        <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;
        \<span class="synIdentifier">&amp;{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$package</span><span class="synperlVarBlock2"> . </span><span class="synString">'::'</span><span class="synperlVarBlock2"> . </span><span class="synIdentifier">$name</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>;
    };

    <span class="synStatement">return</span> <span class="synIdentifier">$sub</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">&amp;$sub</span>;

    Carp::cluck <span class="synString">&quot;Trying to export undefined sub </span><span class="synIdentifier">${package}</span><span class="synString">::</span><span class="synIdentifier">${name}</span><span class="synString">&quot;</span>;

    <span class="synStatement">return</span>;
}

<span class="synStatement">our</span> <span class="synIdentifier">$CALLER</span>;

<span class="synKeyword">sub </span><span class="synFunction">_make_wrapped_sub </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>            = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$fq_name</span>         = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$sub</span>             = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$export_recorder</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># We need to set the package at import time, so that when</span>
    <span class="synComment"># package Foo imports has(), we capture &quot;Foo&quot; as the</span>
    <span class="synComment"># package. This lets other packages call Foo::has() and get</span>
    <span class="synComment"># the right package. This is done for backwards compatibility</span>
    <span class="synComment"># with existing production code, not because this is a good</span>
    <span class="synComment"># idea ;)</span>
    <span class="synStatement">return</span> <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> <span class="synIdentifier">$caller</span> = <span class="synIdentifier">$CALLER</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$wrapper</span> = <span class="synIdentifier">$self-&gt;_curry_wrapper</span>( <span class="synIdentifier">$sub</span>, <span class="synIdentifier">$fq_name</span>, <span class="synIdentifier">$caller</span> );

        <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = subname( <span class="synIdentifier">$fq_name</span> =&gt; <span class="synIdentifier">$wrapper</span> );

        <span class="synIdentifier">$export_recorder-&gt;{$sub}</span> = <span class="synNumber">1</span>;

        <span class="synStatement">return</span> <span class="synIdentifier">$sub</span>;
    };
}

<span class="synKeyword">sub </span><span class="synFunction">_make_wrapped_sub_with_meta </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>            = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$fq_name</span>         = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$sub</span>             = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$export_recorder</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup</span>     = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> <span class="synIdentifier">$caller</span> = <span class="synIdentifier">$CALLER</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$wrapper</span> = <span class="synIdentifier">$self-&gt;_late_curry_wrapper</span>(
            <span class="synIdentifier">$sub</span>, <span class="synIdentifier">$fq_name</span>,
            <span class="synIdentifier">$meta_lookup</span> =&gt; <span class="synIdentifier">$caller</span>
        );

        <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = subname( <span class="synIdentifier">$fq_name</span> =&gt; <span class="synIdentifier">$wrapper</span> );

        <span class="synIdentifier">$export_recorder-&gt;{$sub}</span> = <span class="synNumber">1</span>;

        <span class="synStatement">return</span> <span class="synIdentifier">$sub</span>;
    };
}

<span class="synKeyword">sub </span><span class="synFunction">_curry_wrapper </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>   = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$sub</span>     = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$fq_name</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@extra</span>   = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$wrapper</span> = <span class="synKeyword">sub </span>{ <span class="synIdentifier">$sub</span>-&gt;( <span class="synIdentifier">@extra</span>, <span class="synIdentifier">@_</span> ) };
    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$proto</span> = <span class="synStatement">prototype</span> <span class="synIdentifier">$sub</span> ) {

        <span class="synComment"># </span><span class="synTodo">XXX</span><span class="synComment"> - Perl's prototype sucks. Use &amp; to make set_prototype</span>
        <span class="synComment"># ignore the fact that we're passing &quot;private variables&quot;</span>
        <span class="synIdentifier">&amp;</span><span class="synType">Scalar::Util::</span><span class="synIdentifier">set_prototype</span>( <span class="synIdentifier">$wrapper</span>, <span class="synIdentifier">$proto</span> );
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$wrapper</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_late_curry_wrapper </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>   = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$sub</span>     = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$fq_name</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$extra</span>   = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@ex_args</span> = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$wrapper</span> = <span class="synKeyword">sub </span>{

        <span class="synComment"># resolve curried arguments at runtime via this closure</span>
        <span class="synStatement">my</span> <span class="synIdentifier">@curry</span> = ( <span class="synIdentifier">$extra</span>-&gt;(<span class="synIdentifier">@ex_args</span>) );
        <span class="synStatement">return</span> <span class="synIdentifier">$sub</span>-&gt;( <span class="synIdentifier">@curry</span>, <span class="synIdentifier">@_</span> );
    };

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$proto</span> = <span class="synStatement">prototype</span> <span class="synIdentifier">$sub</span> ) {

        <span class="synComment"># </span><span class="synTodo">XXX</span><span class="synComment"> - Perl's prototype sucks. Use &amp; to make set_prototype</span>
        <span class="synComment"># ignore the fact that we're passing &quot;private variables&quot;</span>
        <span class="synIdentifier">&amp;</span><span class="synType">Scalar::Util::</span><span class="synIdentifier">set_prototype</span>( <span class="synIdentifier">$wrapper</span>, <span class="synIdentifier">$proto</span> );
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$wrapper</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_make_import_sub </span>{
    <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$exporting_package</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$exporter</span>          = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$exports_from</span>      = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$is_reexport</span>       = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup</span>       = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synKeyword">sub </span>{

        <span class="synComment"># I think we could use Sub::Exporter's collector feature</span>
        <span class="synComment"># to do this, but that would be rather gross, since that</span>
        <span class="synComment"># feature isn't really designed to return a value to the</span>
        <span class="synComment"># caller of the exporter sub.</span>
        <span class="synComment">#</span>
        <span class="synComment"># Also, this makes sure we preserve backwards compat for</span>
        <span class="synComment"># _get_caller, so it always sees the arguments in the</span>
        <span class="synComment"># expected order.</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$traits</span>;
        ( <span class="synIdentifier">$traits</span>, <span class="synIdentifier">@_</span> ) = _strip_traits(<span class="synIdentifier">@_</span>);

        <span class="synStatement">my</span> <span class="synIdentifier">$metaclass</span>;
        ( <span class="synIdentifier">$metaclass</span>, <span class="synIdentifier">@_</span> ) = _strip_metaclass(<span class="synIdentifier">@_</span>);
        <span class="synIdentifier">$metaclass</span>
            = Moose::Util::resolve_metaclass_alias( <span class="synString">'Class'</span> =&gt; <span class="synIdentifier">$metaclass</span> )
            <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$metaclass</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$metaclass</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span>;
        ( <span class="synIdentifier">$meta_name</span>, <span class="synIdentifier">@_</span> ) = _strip_meta_name(<span class="synIdentifier">@_</span>);

        <span class="synComment"># Normally we could look at $_[0], but in some weird cases</span>
        <span class="synComment"># (involving goto &amp;Moose::import), $_[0] ends as something</span>
        <span class="synComment"># else (like Squirrel).</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$exporting_package</span>;

        <span class="synIdentifier">$CALLER</span> = _get_caller(<span class="synIdentifier">@_</span>);

        <span class="synComment"># this works because both pragmas set $^H (see perldoc</span>
        <span class="synComment"># perlvar) which affects the current compilation -</span>
        <span class="synComment"># i.e. the file who use'd us - which is why we don't need</span>
        <span class="synComment"># to do anything special to make it affect that file</span>
        <span class="synComment"># rather than this one (which is already compiled)</span>

        strict-&gt;<span class="synStatement">import</span>;
        warnings-&gt;<span class="synStatement">import</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$did_init_meta</span>;
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$c</span> ( <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;can</span>(<span class="synString">'init_meta'</span>) <span class="synStatement">}</span> <span class="synIdentifier">$class</span>, <span class="synIdentifier">@{$exports_from}</span> ) {

            <span class="synComment"># init_meta can apply a role, which when loaded uses</span>
            <span class="synComment"># Moose::Exporter, which in turn sets $CALLER, so we need</span>
            <span class="synComment"># to protect against that.</span>
            <span class="synStatement">local</span> <span class="synIdentifier">$CALLER</span> = <span class="synIdentifier">$CALLER</span>;
            <span class="synIdentifier">$c-&gt;init_meta</span>(
                <span class="synString">for_class</span> =&gt; <span class="synIdentifier">$CALLER</span>,
                <span class="synString">metaclass</span> =&gt; <span class="synIdentifier">$metaclass</span>,
                <span class="synString">meta_name</span> =&gt; <span class="synIdentifier">$meta_name</span>,
            );
            <span class="synIdentifier">$did_init_meta</span> = <span class="synNumber">1</span>;
        }

        {
            <span class="synComment"># The metaroles will use Moose::Role, which in turn uses</span>
            <span class="synComment"># Moose::Exporter, which in turn sets $CALLER, so we need</span>
            <span class="synComment"># to protect against that.</span>
            <span class="synStatement">local</span> <span class="synIdentifier">$CALLER</span> = <span class="synIdentifier">$CALLER</span>;
            _apply_metaroles(
                <span class="synIdentifier">$CALLER</span>,
                [<span class="synIdentifier">$class</span>, <span class="synIdentifier">@$exports_from</span>],
                <span class="synIdentifier">$meta_lookup</span>
            );
        }

        <span class="synConditional">if</span> ( <span class="synIdentifier">$did_init_meta</span> &amp;&amp; <span class="synIdentifier">@{$traits}</span> ) {

            <span class="synComment"># The traits will use Moose::Role, which in turn uses</span>
            <span class="synComment"># Moose::Exporter, which in turn sets $CALLER, so we need</span>
            <span class="synComment"># to protect against that.</span>
            <span class="synStatement">local</span> <span class="synIdentifier">$CALLER</span> = <span class="synIdentifier">$CALLER</span>;
            _apply_meta_traits( <span class="synIdentifier">$CALLER</span>, <span class="synIdentifier">$traits</span>, <span class="synIdentifier">$meta_lookup</span> );
        }
        <span class="synConditional">elsif</span> ( <span class="synIdentifier">@{$traits}</span> ) {
            <span class="synStatement">require</span> Moose;
            Moose-&gt;throw_error(
                <span class="synString">&quot;Cannot provide traits when </span><span class="synIdentifier">$class</span><span class="synString"> does not have an init_meta() method&quot;</span>
            );
        }

        <span class="synStatement">my</span> ( <span class="synOperator">undef</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$extra</span> = <span class="synStatement">shift</span> <span class="synIdentifier">@args</span> <span class="synConditional">if</span> <span class="synOperator">ref</span> <span class="synIdentifier">$args[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> <span class="synOperator">eq</span> <span class="synString">'HASH'</span>;

        <span class="synIdentifier">$extra</span> ||= {};
        <span class="synConditional">if</span> ( !<span class="synIdentifier">$extra-&gt;{</span><span class="synString">into</span><span class="synIdentifier">}</span> ) {
            <span class="synIdentifier">$extra-&gt;{</span><span class="synString">into_level</span><span class="synIdentifier">}</span> ||= <span class="synNumber">0</span>;
            <span class="synIdentifier">$extra-&gt;{</span><span class="synString">into_level</span><span class="synIdentifier">}</span>++;
        }

        <span class="synIdentifier">$class-&gt;$exporter</span>( <span class="synIdentifier">$extra</span>, <span class="synIdentifier">@args</span> );
    };
}

<span class="synKeyword">sub </span><span class="synFunction">_strip_traits </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$idx</span> = first_index { ( <span class="synIdentifier">$_</span> || <span class="synString">''</span> ) <span class="synOperator">eq</span> <span class="synString">'-traits'</span> } <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> ( [], <span class="synIdentifier">@_</span> ) <span class="synConditional">unless</span> <span class="synIdentifier">$idx</span> &gt;= <span class="synNumber">0</span> &amp;&amp; <span class="synIdentifier">$#_</span> &gt;= <span class="synIdentifier">$idx</span> + <span class="synNumber">1</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$traits</span> = <span class="synIdentifier">$_[</span><span class="synperlVarMember"> </span><span class="synIdentifier">$idx</span><span class="synperlVarMember"> + </span><span class="synNumber">1</span><span class="synperlVarMember"> </span><span class="synIdentifier">]</span>;

    <span class="synStatement">splice</span> <span class="synIdentifier">@_</span>, <span class="synIdentifier">$idx</span>, <span class="synNumber">2</span>;

    <span class="synIdentifier">$traits</span> = [<span class="synIdentifier">$traits</span>] <span class="synConditional">unless</span> <span class="synOperator">ref</span> <span class="synIdentifier">$traits</span>;

    <span class="synStatement">return</span> ( <span class="synIdentifier">$traits</span>, <span class="synIdentifier">@_</span> );
}

<span class="synKeyword">sub </span><span class="synFunction">_strip_metaclass </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$idx</span> = first_index { ( <span class="synIdentifier">$_</span> || <span class="synString">''</span> ) <span class="synOperator">eq</span> <span class="synString">'-metaclass'</span> } <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> ( <span class="synOperator">undef</span>, <span class="synIdentifier">@_</span> ) <span class="synConditional">unless</span> <span class="synIdentifier">$idx</span> &gt;= <span class="synNumber">0</span> &amp;&amp; <span class="synIdentifier">$#_</span> &gt;= <span class="synIdentifier">$idx</span> + <span class="synNumber">1</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$metaclass</span> = <span class="synIdentifier">$_[</span><span class="synperlVarMember"> </span><span class="synIdentifier">$idx</span><span class="synperlVarMember"> + </span><span class="synNumber">1</span><span class="synperlVarMember"> </span><span class="synIdentifier">]</span>;

    <span class="synStatement">splice</span> <span class="synIdentifier">@_</span>, <span class="synIdentifier">$idx</span>, <span class="synNumber">2</span>;

    <span class="synStatement">return</span> ( <span class="synIdentifier">$metaclass</span>, <span class="synIdentifier">@_</span> );
}

<span class="synKeyword">sub </span><span class="synFunction">_strip_meta_name </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$idx</span> = first_index { ( <span class="synIdentifier">$_</span> || <span class="synString">''</span> ) <span class="synOperator">eq</span> <span class="synString">'-meta_name'</span> } <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> ( <span class="synString">'meta'</span>, <span class="synIdentifier">@_</span> ) <span class="synConditional">unless</span> <span class="synIdentifier">$idx</span> &gt;= <span class="synNumber">0</span> &amp;&amp; <span class="synIdentifier">$#_</span> &gt;= <span class="synIdentifier">$idx</span> + <span class="synNumber">1</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span> = <span class="synIdentifier">$_[</span><span class="synperlVarMember"> </span><span class="synIdentifier">$idx</span><span class="synperlVarMember"> + </span><span class="synNumber">1</span><span class="synperlVarMember"> </span><span class="synIdentifier">]</span>;

    <span class="synStatement">splice</span> <span class="synIdentifier">@_</span>, <span class="synIdentifier">$idx</span>, <span class="synNumber">2</span>;

    <span class="synStatement">return</span> ( <span class="synIdentifier">$meta_name</span>, <span class="synIdentifier">@_</span> );
}

<span class="synKeyword">sub </span><span class="synFunction">_apply_metaroles </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>, <span class="synIdentifier">$exports_from</span>, <span class="synIdentifier">$meta_lookup</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$metaroles</span> = _collect_metaroles(<span class="synIdentifier">$exports_from</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$base_class_roles</span> = <span class="synStatement">delete</span> <span class="synIdentifier">$metaroles-&gt;{</span><span class="synString">base_class_roles</span><span class="synIdentifier">}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$meta_lookup</span>-&gt;(<span class="synIdentifier">$class</span>);
    <span class="synComment"># for instance, Moose.pm uses Moose::Util::TypeConstraints</span>
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$meta</span>;

    Moose::Util::MetaRole::apply_metaroles(
        <span class="synString">for</span> =&gt; <span class="synIdentifier">$meta</span>,
        <span class="synIdentifier">%$metaroles</span>,
    ) <span class="synConditional">if</span> <span class="synStatement">keys</span> <span class="synIdentifier">%$metaroles</span>;

    Moose::Util::MetaRole::apply_base_class_roles(
        <span class="synString">for</span>   =&gt; <span class="synIdentifier">$meta</span>,
        <span class="synString">roles</span> =&gt; <span class="synIdentifier">$base_class_roles</span>,
    ) <span class="synConditional">if</span> <span class="synIdentifier">$meta-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>)
      &amp;&amp; <span class="synIdentifier">$base_class_roles</span> &amp;&amp; <span class="synIdentifier">@$base_class_roles</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_collect_metaroles </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$exports_from</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@old_style_role_types</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synString">&quot;</span><span class="synIdentifier">${_}</span><span class="synString">_roles&quot;</span> <span class="synStatement">}</span> <span class="synString">qw(</span>
<span class="synString">        metaclass</span>
<span class="synString">        attribute_metaclass</span>
<span class="synString">        method_metaclass</span>
<span class="synString">        wrapped_method_metaclass</span>
<span class="synString">        instance_metaclass</span>
<span class="synString">        constructor_class</span>
<span class="synString">        destructor_class</span>
<span class="synString">        error_class</span>
<span class="synString">    )</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%class_metaroles</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%role_metaroles</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@base_class_roles</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%old_style_roles</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$exporter</span> (<span class="synIdentifier">@$exports_from</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$data</span> = <span class="synIdentifier">$EXPORT_SPEC{$exporter}</span>;

        <span class="synConditional">if</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$data-&gt;{</span><span class="synString">class_metaroles</span><span class="synIdentifier">}</span>) {
            <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$type</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$data-&gt;{</span><span class="synString">class_metaroles</span><span class="synIdentifier">}</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>) {
                <span class="synStatement">push</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$class_metaroles{$type}</span><span class="synperlVarBlock"> ||= [] </span><span class="synIdentifier">}</span>,
                     <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$data-&gt;{</span><span class="synString">class_metaroles</span><span class="synIdentifier">}{$type}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
            }
        }

        <span class="synConditional">if</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$data-&gt;{</span><span class="synString">role_metaroles</span><span class="synIdentifier">}</span>) {
            <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$type</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$data-&gt;{</span><span class="synString">role_metaroles</span><span class="synIdentifier">}</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>) {
                <span class="synStatement">push</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$role_metaroles{$type}</span><span class="synperlVarBlock"> ||= [] </span><span class="synIdentifier">}</span>,
                     <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$data-&gt;{</span><span class="synString">role_metaroles</span><span class="synIdentifier">}{$type}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
            }
        }

        <span class="synConditional">if</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$data-&gt;{</span><span class="synString">base_class_roles</span><span class="synIdentifier">}</span>) {
            <span class="synStatement">push</span> <span class="synIdentifier">@base_class_roles</span>, <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$data-&gt;{</span><span class="synString">base_class_roles</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
        }

        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$type</span> (<span class="synIdentifier">@old_style_role_types</span>) {
            <span class="synConditional">if</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$data-&gt;{$type}</span>) {
                <span class="synStatement">push</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$old_style_roles{$type}</span><span class="synperlVarBlock"> ||= [] </span><span class="synIdentifier">}</span>,
                     <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$data-&gt;{$type}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
            }
        }
    }

    <span class="synStatement">return</span> {
        (<span class="synStatement">keys</span>(<span class="synIdentifier">%class_metaroles</span>)
            ? (<span class="synString">class_metaroles</span>  =&gt; \<span class="synIdentifier">%class_metaroles</span>)
            : ()),
        (<span class="synStatement">keys</span>(<span class="synIdentifier">%role_metaroles</span>)
            ? (<span class="synString">role_metaroles</span>   =&gt; \<span class="synIdentifier">%role_metaroles</span>)
            : ()),
        (<span class="synIdentifier">@base_class_roles</span>
            ? (<span class="synString">base_class_roles</span> =&gt; \<span class="synIdentifier">@base_class_roles</span>)
            : ()),
        <span class="synIdentifier">%old_style_roles</span>,
    };
}

<span class="synKeyword">sub </span><span class="synFunction">_apply_meta_traits </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$class</span>, <span class="synIdentifier">$traits</span>, <span class="synIdentifier">$meta_lookup</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">@{$traits}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$meta_lookup</span>-&gt;(<span class="synIdentifier">$class</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$type</span> = <span class="synIdentifier">$meta-&gt;isa</span>(<span class="synString">'Moose::Meta::Role'</span>) ? <span class="synString">'Role'</span>
             : <span class="synIdentifier">$meta-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>) ? <span class="synString">'Class'</span>
             : Moose-&gt;throw_error(<span class="synString">'Cannot determine metaclass type for '</span>
                                . <span class="synString">'trait application. Meta isa '</span>
                                . <span class="synOperator">ref</span> <span class="synIdentifier">$meta</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">@resolved_traits</span> = <span class="synStatement">map</span> <span class="synStatement">{</span>
        <span class="synOperator">ref</span> <span class="synIdentifier">$_</span>
            ? <span class="synIdentifier">$_</span>
            : Moose::Util::resolve_metatrait_alias( <span class="synIdentifier">$type</span> =&gt; <span class="synIdentifier">$_</span> )
    <span class="synStatement">}</span> <span class="synIdentifier">@$traits</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">@resolved_traits</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%args</span> = ( <span class="synString">for</span> =&gt; <span class="synIdentifier">$class</span> );

    <span class="synConditional">if</span> ( <span class="synIdentifier">$meta-&gt;isa</span>(<span class="synString">'Moose::Meta::Role'</span>) ) {
        <span class="synIdentifier">$args{</span><span class="synString">role_metaroles</span><span class="synIdentifier">}</span> = { <span class="synString">role</span> =&gt; \<span class="synIdentifier">@resolved_traits</span> };
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$args{</span><span class="synString">class_metaroles</span><span class="synIdentifier">}</span> = { <span class="synString">class</span> =&gt; \<span class="synIdentifier">@resolved_traits</span> };
    }

    Moose::Util::MetaRole::apply_metaroles(<span class="synIdentifier">%args</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_get_caller </span>{

    <span class="synComment"># 1 extra level because it's called by import so there's a layer</span>
    <span class="synComment"># of indirection</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$offset</span> = <span class="synNumber">1</span>;

    <span class="synStatement">return</span>
          ( <span class="synOperator">ref</span> <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]-&gt;{</span><span class="synString">into</span><span class="synIdentifier">}</span> ) ? <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]-&gt;{</span><span class="synString">into</span><span class="synIdentifier">}</span>
        : ( <span class="synOperator">ref</span> <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]-&gt;{</span><span class="synString">into_level</span><span class="synIdentifier">}</span> )
        ? <span class="synStatement">caller</span>( <span class="synIdentifier">$offset</span> + <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]-&gt;{</span><span class="synString">into_level</span><span class="synIdentifier">}</span> )
        : <span class="synStatement">caller</span>(<span class="synIdentifier">$offset</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_make_unimport_sub </span>{
    <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$exporting_package</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$exports</span>           = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$export_recorder</span>   = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$is_reexport</span>       = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup</span>       = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> <span class="synIdentifier">$caller</span> = <span class="synStatement">scalar</span> <span class="synStatement">caller</span>();
        Moose::Exporter-&gt;_remove_keywords(
            <span class="synIdentifier">$caller</span>,
            [ <span class="synStatement">keys</span> <span class="synIdentifier">%{$exports}</span> ],
            <span class="synIdentifier">$export_recorder</span>,
            <span class="synIdentifier">$is_reexport</span>,
        );
    };
}

<span class="synKeyword">sub </span><span class="synFunction">_remove_keywords </span>{
    <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$package</span>          = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$keywords</span>         = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$recorded_exports</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$is_reexport</span>      = <span class="synStatement">shift</span>;

    <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$name</span> ( <span class="synIdentifier">@{$keywords}</span> ) {
        <span class="synConditional">if</span> ( <span class="synOperator">defined</span> <span class="synIdentifier">&amp;{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$package</span><span class="synperlVarBlock2"> . </span><span class="synString">'::'</span><span class="synperlVarBlock2"> . </span><span class="synIdentifier">$name</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> ) {
            <span class="synStatement">my</span> <span class="synIdentifier">$sub</span> = \<span class="synIdentifier">&amp;{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$package</span><span class="synperlVarBlock2"> . </span><span class="synString">'::'</span><span class="synperlVarBlock2"> . </span><span class="synIdentifier">$name</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span>;

            <span class="synComment"># make sure it is from us</span>
            <span class="synStatement">next</span> <span class="synConditional">unless</span> <span class="synIdentifier">$recorded_exports-&gt;{$sub}</span>;

            <span class="synConditional">if</span> ( <span class="synIdentifier">$is_reexport-&gt;{$name}</span> ) {
                <span class="synStatement">no strict</span> <span class="synString">'refs'</span>;
                <span class="synStatement">next</span>
                    <span class="synConditional">unless</span> _export_is_flagged(
                            \<span class="synIdentifier">*{</span><span class="synperlVarBlock2"> </span><span class="synStatement">join</span><span class="synperlVarBlock2"> </span><span class="synString">q{::}</span><span class="synperlVarBlock2"> =&gt; </span><span class="synIdentifier">$package</span><span class="synperlVarBlock2">, </span><span class="synIdentifier">$name</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> );
            }

            <span class="synComment"># and if it is from us, then undef the slot</span>
            <span class="synStatement">delete</span> <span class="synIdentifier">${</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$package</span><span class="synperlVarBlock"> . </span><span class="synString">'::'</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}{$name}</span>;
        }
    }
}

<span class="synComment"># maintain this for now for backcompat</span>
<span class="synComment"># make sure to return a sub to install in the same circumstances as previously</span>
<span class="synComment"># but this functionality now happens at the end of -&gt;import</span>
<span class="synKeyword">sub </span><span class="synFunction">_make_init_meta </span>{
    <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>          = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$args</span>           = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_lookup</span>    = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%old_style_roles</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$role</span> (
        <span class="synStatement">map</span> <span class="synStatement">{</span><span class="synString">&quot;</span><span class="synIdentifier">${_}</span><span class="synString">_roles&quot;</span><span class="synStatement">}</span>
        <span class="synString">qw(</span>
<span class="synString">        metaclass</span>
<span class="synString">        attribute_metaclass</span>
<span class="synString">        method_metaclass</span>
<span class="synString">        wrapped_method_metaclass</span>
<span class="synString">        instance_metaclass</span>
<span class="synString">        constructor_class</span>
<span class="synString">        destructor_class</span>
<span class="synString">        error_class</span>
<span class="synString">        )</span>
        ) {
        <span class="synIdentifier">$old_style_roles{$role}</span> = <span class="synIdentifier">$args-&gt;{$role}</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$args-&gt;{$role}</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">%base_class_roles</span>;
    <span class="synIdentifier">%base_class_roles</span> = ( <span class="synString">roles</span> =&gt; <span class="synIdentifier">$args-&gt;{</span><span class="synString">base_class_roles</span><span class="synIdentifier">}</span> )
        <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$args-&gt;{</span><span class="synString">base_class_roles</span><span class="synIdentifier">}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%new_style_roles</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_</span> =&gt; <span class="synIdentifier">$args-&gt;{$_}</span> <span class="synStatement">}</span>
        <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synStatement">exists</span> <span class="synIdentifier">$args-&gt;{$_}</span> <span class="synStatement">}</span> <span class="synString">qw( class_metaroles role_metaroles )</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">%new_style_roles</span> || <span class="synIdentifier">%old_style_roles</span> || <span class="synIdentifier">%base_class_roles</span>;

    <span class="synStatement">return</span> <span class="synKeyword">sub </span>{
        <span class="synStatement">shift</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">%opts</span> = <span class="synIdentifier">@_</span>;
        <span class="synIdentifier">$meta_lookup</span>-&gt;(<span class="synIdentifier">$opts{</span><span class="synString">for_class</span><span class="synIdentifier">}</span>);
    };
}

<span class="synKeyword">sub </span><span class="synFunction">import </span>{
    strict-&gt;<span class="synStatement">import</span>;
    warnings-&gt;<span class="synStatement">import</span>;
}

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: make an import() and unimport() just like Moose.pm</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Moose::Exporter - make an </span><span class="synIdentifier">import()</span><span class="synperlPOD"> and </span><span class="synIdentifier">unimport()</span><span class="synperlPOD"> just like Moose.pm</span>

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

<span class="synperlPOD">version 2.1005</span>

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synPreProc">  package MyApp::Moose;</span>

<span class="synPreProc">  use Moose ();</span>
<span class="synPreProc">  use Moose::Exporter;</span>

<span class="synPreProc">  Moose::Exporter-&gt;setup_import_methods(</span>
<span class="synPreProc">      with_meta =&gt; [ 'has_rw', 'sugar2' ],</span>
<span class="synPreProc">      as_is     =&gt; [ 'sugar3', \&amp;Some::Random::thing ],</span>
<span class="synPreProc">      also      =&gt; 'Moose',</span>
<span class="synPreProc">  );</span>

<span class="synPreProc">  sub has_rw {</span>
<span class="synPreProc">      my ( $meta, $name, %options ) = @_;</span>
<span class="synPreProc">      $meta-&gt;add_attribute(</span>
<span class="synPreProc">          $name,</span>
<span class="synPreProc">          is =&gt; 'rw',</span>
<span class="synPreProc">          %options,</span>
<span class="synPreProc">      );</span>
<span class="synPreProc">  }</span>

<span class="synPreProc">  # then later ...</span>
<span class="synPreProc">  package MyApp::User;</span>

<span class="synPreProc">  use MyApp::Moose;</span>

<span class="synPreProc">  has 'name';</span>
<span class="synPreProc">  has_rw 'size';</span>
<span class="synPreProc">  thing;</span>

<span class="synPreProc">  no MyApp::Moose;</span>

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

<span class="synperlPOD">This module encapsulates the exporting of sugar functions in a</span>
<span class="synIdentifier">C&lt;Moose.pm&gt;</span><span class="synperlPOD">-like manner. It does this by building custom </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD"> methods for your module, based on a spec you provide.</span>

<span class="synperlPOD">It also lets you &quot;stack&quot; Moose-alike modules so you can export Moose's sugar</span>
<span class="synperlPOD">as well as your own, along with sugar from any random </span><span class="synIdentifier">C&lt;MooseX&gt;</span><span class="synperlPOD"> module, as</span>
<span class="synperlPOD">long as they all use </span><span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD">. This feature exists to let you bundle</span>
<span class="synperlPOD">a set of MooseX modules into a policy module that developers can use directly</span>
<span class="synperlPOD">instead of using Moose itself.</span>

<span class="synperlPOD">To simplify writing exporter modules, </span><span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD"> also imports</span>
<span class="synIdentifier">C&lt;strict&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;warnings&gt;</span><span class="synperlPOD"> into your exporter module, as well as into</span>
<span class="synperlPOD">modules that use it.</span>

<span class="synStatement">=head1</span><span class="synString"> METHODS</span>

<span class="synperlPOD">This module provides two public methods:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Moose::Exporter-&gt;setup_import_methods(...) &gt;&gt;</span>

<span class="synperlPOD">When you call this method, </span><span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD"> builds custom </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD"> methods for your module. The </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> method</span>
<span class="synperlPOD">will export the functions you specify, and can also re-export functions</span>
<span class="synperlPOD">exported by some other module (like </span><span class="synIdentifier">C&lt;Moose.pm&gt;</span><span class="synperlPOD">). If you pass any parameters</span>
<span class="synperlPOD">for </span><span class="synIdentifier">L&lt;Moose::Util::MetaRole&gt;</span><span class="synperlPOD">, the </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> method will also call</span>
<span class="synIdentifier">C&lt;Moose::Util::MetaRole::apply_metaroles&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">C&lt;Moose::Util::MetaRole::apply_base_class_roles&gt;</span><span class="synperlPOD"> as needed, after making</span>
<span class="synperlPOD">sure the metaclass is initialized.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD"> method cleans the caller's namespace of all the exported</span>
<span class="synperlPOD">functions. This includes any functions you re-export from other</span>
<span class="synperlPOD">packages. However, if the consumer of your package also imports those</span>
<span class="synperlPOD">functions from the original package, they will </span><span class="synIdentifier">I&lt;not&gt;</span><span class="synperlPOD"> be cleaned.</span>

<span class="synperlPOD">Note that if any of these methods already exist, they will not be</span>
<span class="synperlPOD">overridden, you will have to use </span><span class="synIdentifier">C&lt;build_import_methods&gt;</span><span class="synperlPOD"> to get the</span>
<span class="synperlPOD">coderef that would be installed.</span>

<span class="synperlPOD">This method accepts the following parameters:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">8</span>

<span class="synStatement">=item</span><span class="synString"> * with_meta =&gt; [ ... ]</span>

<span class="synperlPOD">This list of function </span><span class="synIdentifier">I&lt;names only&gt;</span><span class="synperlPOD"> will be wrapped and then exported. The</span>
<span class="synperlPOD">wrapper will pass the metaclass object for the caller as its first argument.</span>

<span class="synperlPOD">Many sugar functions will need to use this metaclass object to do something to</span>
<span class="synperlPOD">the calling package.</span>

<span class="synStatement">=item</span><span class="synString"> * as_is =&gt; [ ... ]</span>

<span class="synperlPOD">This list of function names or sub references will be exported as-is. You can</span>
<span class="synperlPOD">identify a subroutine by reference, which is handy to re-export some other</span>
<span class="synperlPOD">module's functions directly by reference (</span><span class="synIdentifier">C&lt;\&amp;Some::Package::function&gt;</span><span class="synperlPOD">).</span>

<span class="synperlPOD">If you do export some other package's function, this function will never be</span>
<span class="synperlPOD">removed by the </span><span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD"> method. The reason for this is we cannot know if</span>
<span class="synperlPOD">the caller </span><span class="synIdentifier">I&lt;also&gt;</span><span class="synperlPOD"> explicitly imported the sub themselves, and therefore wants</span>
<span class="synperlPOD">to keep it.</span>

<span class="synStatement">=item</span><span class="synString"> * trait_aliases =&gt; [ ... ]</span>

<span class="synperlPOD">This is a list of package names which should have shortened aliases exported,</span>
<span class="synperlPOD">similar to the functionality of </span><span class="synIdentifier">L&lt;aliased&gt;</span><span class="synperlPOD">. Each element in the list can be</span>
<span class="synperlPOD">either a package name, in which case the export will be named as the last</span>
<span class="synperlPOD">namespace component of the package, or an arrayref, whose first element is the</span>
<span class="synperlPOD">package to alias to, and second element is the alias to export.</span>

<span class="synStatement">=item</span><span class="synString"> * also =&gt; $name or \@names</span>

<span class="synperlPOD">This is a list of modules which contain functions that the caller</span>
<span class="synperlPOD">wants to export. These modules must also use </span><span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD">. The</span>
<span class="synperlPOD">most common use case will be to export the functions from </span><span class="synIdentifier">C&lt;Moose.pm&gt;</span><span class="synperlPOD">.</span>
<span class="synperlPOD">Functions specified by </span><span class="synIdentifier">C&lt;with_meta&gt;</span><span class="synperlPOD"> or </span><span class="synIdentifier">C&lt;as_is&gt;</span><span class="synperlPOD"> take precedence over</span>
<span class="synperlPOD">functions exported by modules specified by </span><span class="synIdentifier">C&lt;also&gt;</span><span class="synperlPOD">, so that a module</span>
<span class="synperlPOD">can selectively override functions exported by another module.</span>

<span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD"> also makes sure all these functions get removed</span>
<span class="synperlPOD">when </span><span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD"> is called.</span>

<span class="synStatement">=item</span><span class="synString"> * meta_lookup =&gt; sub { ... }</span>

<span class="synperlPOD">This is a function which will be called to provide the metaclass</span>
<span class="synperlPOD">to be operated upon by the exporter. This is an advanced feature</span>
<span class="synperlPOD">intended for use by package generator modules in the vein of</span>
<span class="synIdentifier">L&lt;MooseX::Role::Parameterized&gt;</span><span class="synperlPOD"> in order to simplify reusing sugar</span>
<span class="synperlPOD">from other modules that use </span><span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD">. This function is</span>
<span class="synperlPOD">used, for example, to select the metaclass to bind to functions</span>
<span class="synperlPOD">that are exported using the </span><span class="synIdentifier">C&lt;with_meta&gt;</span><span class="synperlPOD"> option.</span>

<span class="synperlPOD">This function will receive one parameter: the class name into which</span>
<span class="synperlPOD">the sugar is being exported. The default implementation is:</span>

<span class="synPreProc">    sub { Class::MOP::class_of(shift) }</span>

<span class="synperlPOD">Accordingly, this function is expected to return a metaclass.</span>

<span class="synStatement">=back</span>

<span class="synperlPOD">You can also provide parameters for </span><span class="synIdentifier">C&lt;Moose::Util::MetaRole::apply_metaroles&gt;</span>
<span class="synperlPOD">and </span><span class="synIdentifier">C&lt;Moose::Util::MetaRole::base_class_roles&gt;</span><span class="synperlPOD">. Specifically, valid parameters</span>
<span class="synperlPOD">are &quot;class_metaroles&quot;, &quot;role_metaroles&quot;, and &quot;base_class_roles&quot;.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Moose::Exporter-&gt;build_import_methods(...) &gt;&gt;</span>

<span class="synperlPOD">Returns two code refs, one for </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> and one for </span><span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Accepts the additional </span><span class="synIdentifier">C&lt;install&gt;</span><span class="synperlPOD"> option, which accepts an arrayref of method</span>
<span class="synperlPOD">names to install into your exporting package. The valid options are </span><span class="synIdentifier">C&lt;import&gt;</span>
<span class="synperlPOD">and </span><span class="synIdentifier">C&lt;unimport&gt;</span><span class="synperlPOD">. Calling </span><span class="synIdentifier">C&lt;setup_import_methods&gt;</span><span class="synperlPOD"> is equivalent</span>
<span class="synperlPOD">to calling </span><span class="synIdentifier">C&lt;build_import_methods&gt;</span><span class="synperlPOD"> with </span><span class="synIdentifier">C&lt;&lt; install =&gt; [qw(import unimport)] &gt;&gt;</span>
<span class="synperlPOD">except that it doesn't also return the methods.</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> method is built using </span><span class="synIdentifier">L&lt;Sub::Exporter&gt;</span><span class="synperlPOD">. This means that it can</span>
<span class="synperlPOD">take a hashref of the form </span><span class="synIdentifier">C&lt;&lt; { into =&gt; $package } &gt;&gt;</span><span class="synperlPOD"> to specify the package</span>
<span class="synperlPOD">it operates on.</span>

<span class="synperlPOD">Used by </span><span class="synIdentifier">C&lt;setup_import_methods&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> IMPORTING AND init_meta</span>

<span class="synperlPOD">If you want to set an alternative base object class or metaclass class, see</span>
<span class="synperlPOD">above for details on how this module can call </span><span class="synIdentifier">L&lt;Moose::Util::MetaRole&gt;</span><span class="synperlPOD"> for</span>
<span class="synperlPOD">you.</span>

<span class="synperlPOD">If you want to do something that is not supported by this module, simply</span>
<span class="synperlPOD">define an </span><span class="synIdentifier">C&lt;init_meta&gt;</span><span class="synperlPOD"> method in your class. The </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> method that</span>
<span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD"> generates for you will call this method (if it exists). It</span>
<span class="synperlPOD">will always pass the caller to this method via the </span><span class="synIdentifier">C&lt;for_class&gt;</span><span class="synperlPOD"> parameter.</span>

<span class="synperlPOD">Most of the time, your </span><span class="synIdentifier">C&lt;init_meta&gt;</span><span class="synperlPOD"> method will probably just call C&lt;&lt;</span>
<span class="synperlPOD">Moose-&gt;init_meta &gt;&gt; to do the real work:</span>

<span class="synPreProc">  sub init_meta {</span>
<span class="synPreProc">      shift; # our class name</span>
<span class="synPreProc">      return Moose-&gt;init_meta( @_, metaclass =&gt; 'My::Metaclass' );</span>
<span class="synPreProc">  }</span>

<span class="synStatement">=head1</span><span class="synString"> METACLASS TRAITS</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;import&gt;</span><span class="synperlPOD"> method generated by </span><span class="synIdentifier">C&lt;Moose::Exporter&gt;</span><span class="synperlPOD"> will allow the</span>
<span class="synperlPOD">user of your module to specify metaclass traits in a </span><span class="synIdentifier">C&lt;-traits&gt;</span>
<span class="synperlPOD">parameter passed as part of the import:</span>

<span class="synPreProc">  use Moose -traits =&gt; 'My::Meta::Trait';</span>

<span class="synPreProc">  use Moose -traits =&gt; [ 'My::Meta::Trait', 'My::Other::Trait' ];</span>

<span class="synperlPOD">These traits will be applied to the caller's metaclass</span>
<span class="synperlPOD">instance. Providing traits for an exporting class that does not create</span>
<span class="synperlPOD">a metaclass for the caller is an error.</span>

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Moose/BUGS&gt;</span><span class="synperlPOD"> for details on reporting bugs.</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

<span class="synperlPOD">Moose is maintained by the Moose Cabal, along with the help of many contributors. See </span><span class="synIdentifier">L&lt;Moose/CABAL&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span><span class="synperlPOD"> for details.</span>

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

<span class="synperlPOD">This software is copyright (c) 2013 by Infinity Interactive, Inc..</span>

<span class="synperlPOD">This is free software; you can redistribute it and/or modify it under</span>
<span class="synperlPOD">the same terms as the Perl 5 programming language system itself.</span>

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
