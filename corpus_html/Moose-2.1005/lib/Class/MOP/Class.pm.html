<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre>
<span class="synStatement">package</span><span class="synType"> Class::MOP::Class</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;

<span class="synStatement">use </span>Class::MOP::Instance;
<span class="synStatement">use </span>Class::MOP::Method::Wrapped;
<span class="synStatement">use </span>Class::MOP::Method::Accessor;
<span class="synStatement">use </span>Class::MOP::Method::Constructor;
<span class="synStatement">use </span>Class::MOP::MiniTrait;

<span class="synStatement">use </span>Carp         <span class="synString">'confess'</span>;
<span class="synStatement">use </span>Class::Load  <span class="synString">'is_class_loaded'</span>, <span class="synString">'load_class'</span>;
<span class="synStatement">use </span>Scalar::Util <span class="synString">'blessed'</span>, <span class="synString">'reftype'</span>, <span class="synString">'weaken'</span>;
<span class="synStatement">use </span>Sub::Name    <span class="synString">'subname'</span>;
<span class="synStatement">use </span>Try::Tiny;
<span class="synStatement">use </span>List::MoreUtils <span class="synString">'all'</span>;

<span class="synStatement">use base</span> <span class="synString">'Class::MOP::Module'</span>,
         <span class="synString">'Class::MOP::Mixin::HasAttributes'</span>,
         <span class="synString">'Class::MOP::Mixin::HasMethods'</span>;

<span class="synComment"># Creation</span>

<span class="synKeyword">sub </span><span class="synFunction">initialize </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$package_name</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">@_</span> % <span class="synNumber">2</span> ) {
        <span class="synIdentifier">$package_name</span> = <span class="synStatement">shift</span>;
    } <span class="synConditional">else</span> {
        <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@_</span>;
        <span class="synIdentifier">$package_name</span> = <span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>;
    }

    (<span class="synIdentifier">$package_name</span> &amp;&amp; !<span class="synOperator">ref</span>(<span class="synIdentifier">$package_name</span>))
        || confess <span class="synString">&quot;You must pass a package name and it cannot be blessed&quot;</span>;

    <span class="synStatement">return</span> Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$package_name</span>)
        || <span class="synIdentifier">$class-&gt;_construct_class_instance</span>(<span class="synString">package</span> =&gt; <span class="synIdentifier">$package_name</span>, <span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">reinitialize </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$class</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">unshift</span> <span class="synIdentifier">@args</span>, <span class="synString">&quot;package&quot;</span> <span class="synConditional">if</span> <span class="synIdentifier">@args</span> % <span class="synNumber">2</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@args</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = blessed(<span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>)
        ? <span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>
        : Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>);
    <span class="synIdentifier">$options{</span><span class="synString">weaken</span><span class="synIdentifier">}</span> = Class::MOP::metaclass_is_weak(<span class="synIdentifier">$old_metaclass-&gt;name</span>)
        <span class="synConditional">if</span> !<span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">weaken</span><span class="synIdentifier">}</span>
        &amp;&amp; blessed(<span class="synIdentifier">$old_metaclass</span>)
        &amp;&amp; <span class="synIdentifier">$old_metaclass-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synIdentifier">$old_metaclass-&gt;_remove_generated_metaobjects</span>
        <span class="synConditional">if</span> <span class="synIdentifier">$old_metaclass</span> &amp;&amp; <span class="synIdentifier">$old_metaclass-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$new_metaclass</span> = <span class="synIdentifier">$class-&gt;SUPER</span>::reinitialize(<span class="synIdentifier">%options</span>);
    <span class="synIdentifier">$new_metaclass-&gt;_restore_metaobjects_from</span>(<span class="synIdentifier">$old_metaclass</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$old_metaclass</span> &amp;&amp; <span class="synIdentifier">$old_metaclass-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$new_metaclass</span>;
}

<span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> (meta-circularity)</span>
<span class="synComment"># this is a special form of _construct_instance</span>
<span class="synComment"># (see below), which is used to construct class</span>
<span class="synComment"># meta-object instances for any Class::MOP::*</span>
<span class="synComment"># class. All other classes will use the more</span>
<span class="synComment"># normal &amp;construct_instance.</span>
<span class="synKeyword">sub </span><span class="synFunction">_construct_class_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>        = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$options</span>      = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> : {<span class="synIdentifier">@_</span>};
    <span class="synStatement">my</span> <span class="synIdentifier">$package_name</span> = <span class="synIdentifier">$options-&gt;{</span><span class="synString">package</span><span class="synIdentifier">}</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$package_name</span> &amp;&amp; <span class="synIdentifier">$package_name</span>)
        || confess <span class="synString">&quot;You must pass a package name&quot;</span>;
    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># return the metaclass if we have it cached,</span>
    <span class="synComment"># and it is still defined (it has not been</span>
    <span class="synComment"># reaped by DESTROY yet, which can happen</span>
    <span class="synComment"># annoyingly enough during global destruction)</span>

    <span class="synConditional">if</span> (<span class="synOperator">defined</span>(<span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$package_name</span>))) {
        <span class="synStatement">return</span> <span class="synIdentifier">$meta</span>;
    }

    <span class="synIdentifier">$class</span>
        = <span class="synOperator">ref</span> <span class="synIdentifier">$class</span>
        ? <span class="synIdentifier">$class-&gt;_real_ref_name</span>
        : <span class="synIdentifier">$class</span>;

    <span class="synComment"># now create the metaclass</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span>;
    <span class="synConditional">if</span> (<span class="synIdentifier">$class</span> <span class="synOperator">eq</span> <span class="synString">'Class::MOP::Class'</span>) {
        <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$class-&gt;_new</span>(<span class="synIdentifier">$options</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># it is safe to use meta here because</span>
        <span class="synComment"># class will always be a subclass of</span>
        <span class="synComment"># Class::MOP::Class, which defines meta</span>
        <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$class-&gt;meta-&gt;_construct_instance</span>(<span class="synIdentifier">$options</span>)
    }

    <span class="synComment"># and check the metaclass compatibility</span>
    <span class="synIdentifier">$meta-&gt;_check_metaclass_compatibility</span>();

    Class::MOP::store_metaclass_by_name(<span class="synIdentifier">$package_name</span>, <span class="synIdentifier">$meta</span>);

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># we need to weaken any anon classes</span>
    <span class="synComment"># so that they can call DESTROY properly</span>
    Class::MOP::weaken_metaclass(<span class="synIdentifier">$package_name</span>) <span class="synConditional">if</span> <span class="synIdentifier">$options-&gt;{</span><span class="synString">weaken</span><span class="synIdentifier">}</span>;

    <span class="synIdentifier">$meta</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_real_ref_name </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to deal with the possibility of class immutability here,</span>
    <span class="synComment"># and then get the name of the class appropriately</span>
    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;is_immutable</span>
        ? <span class="synIdentifier">$self-&gt;_get_mutable_metaclass_name</span>()
        : <span class="synOperator">ref</span> <span class="synIdentifier">$self</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_new </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>)-&gt;new_object(<span class="synIdentifier">@_</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$class</span> <span class="synOperator">ne</span> <span class="synperlPackageConst">__PACKAGE__</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$options</span> = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> : {<span class="synIdentifier">@_</span>};

    <span class="synStatement">return</span> <span class="synOperator">bless</span> {
        <span class="synComment"># inherited from Class::MOP::Package</span>
        <span class="synString">'package'</span> =&gt; <span class="synIdentifier">$options-&gt;{</span><span class="synString">package</span><span class="synIdentifier">}</span>,

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># since the following attributes will</span>
        <span class="synComment"># actually be loaded from the symbol</span>
        <span class="synComment"># table, and actually bypass the instance</span>
        <span class="synComment"># entirely, we can just leave these things</span>
        <span class="synComment"># listed here for reference, because they</span>
        <span class="synComment"># should not actually have a value associated</span>
        <span class="synComment"># with the slot.</span>
        <span class="synString">'namespace'</span> =&gt; \<span class="synOperator">undef</span>,
        <span class="synString">'methods'</span>   =&gt; {},

        <span class="synComment"># inherited from Class::MOP::Module</span>
        <span class="synString">'version'</span>   =&gt; \<span class="synOperator">undef</span>,
        <span class="synString">'authority'</span> =&gt; \<span class="synOperator">undef</span>,

        <span class="synComment"># defined in Class::MOP::Class</span>
        <span class="synString">'superclasses'</span> =&gt; \<span class="synOperator">undef</span>,

        <span class="synString">'attributes'</span> =&gt; {},
        <span class="synString">'attribute_metaclass'</span> =&gt;
            ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">'attribute_metaclass'</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Attribute'</span> ),
        <span class="synString">'method_metaclass'</span> =&gt;
            ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">'method_metaclass'</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Method'</span> ),
        <span class="synString">'wrapped_method_metaclass'</span> =&gt; (
            <span class="synIdentifier">$options-&gt;{</span><span class="synString">'wrapped_method_metaclass'</span><span class="synIdentifier">}</span>
                || <span class="synString">'Class::MOP::Method::Wrapped'</span>
        ),
        <span class="synString">'instance_metaclass'</span> =&gt;
            ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">'instance_metaclass'</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Instance'</span> ),
        <span class="synString">'immutable_trait'</span> =&gt; (
            <span class="synIdentifier">$options-&gt;{</span><span class="synString">'immutable_trait'</span><span class="synIdentifier">}</span>
                || <span class="synString">'Class::MOP::Class::Immutable::Trait'</span>
        ),
        <span class="synString">'constructor_name'</span> =&gt; ( <span class="synIdentifier">$options-&gt;{</span><span class="synString">constructor_name</span><span class="synIdentifier">}</span> || <span class="synString">'new'</span> ),
        <span class="synString">'constructor_class'</span> =&gt; (
            <span class="synIdentifier">$options-&gt;{</span><span class="synString">constructor_class</span><span class="synIdentifier">}</span> || <span class="synString">'Class::MOP::Method::Constructor'</span>
        ),
        <span class="synString">'destructor_class'</span> =&gt; <span class="synIdentifier">$options-&gt;{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span>,
    }, <span class="synIdentifier">$class</span>;
}

<span class="synComment">## Metaclass compatibility</span>
{
    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = (
        <span class="synString">attribute_metaclass</span>      =&gt; <span class="synString">'Class::MOP::Attribute'</span>,
        <span class="synString">method_metaclass</span>         =&gt; <span class="synString">'Class::MOP::Method'</span>,
        <span class="synString">wrapped_method_metaclass</span> =&gt; <span class="synString">'Class::MOP::Method::Wrapped'</span>,
        <span class="synString">instance_metaclass</span>       =&gt; <span class="synString">'Class::MOP::Instance'</span>,
        <span class="synString">constructor_class</span>        =&gt; <span class="synString">'Class::MOP::Method::Constructor'</span>,
        <span class="synString">destructor_class</span>         =&gt; <span class="synString">'Class::MOP::Method::Destructor'</span>,
    );

    <span class="synKeyword">sub </span><span class="synFunction">_base_metaclasses </span>{ <span class="synIdentifier">%base_metaclass</span> }
}

<span class="synKeyword">sub </span><span class="synFunction">_check_metaclass_compatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@superclasses</span> = <span class="synIdentifier">$self-&gt;superclasses</span>
        <span class="synOperator">or</span> <span class="synStatement">return</span>;

    <span class="synIdentifier">$self-&gt;_fix_metaclass_incompatibility</span>(<span class="synIdentifier">@superclasses</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = <span class="synIdentifier">$self-&gt;_base_metaclasses</span>;

    <span class="synComment"># this is always okay ...</span>
    <span class="synStatement">return</span>
        <span class="synConditional">if</span> <span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>) <span class="synOperator">eq</span> <span class="synString">'Class::MOP::Class'</span>
            &amp;&amp; all {
                <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$self-&gt;$_</span>;
                !<span class="synOperator">defined</span>(<span class="synIdentifier">$meta</span>) || <span class="synIdentifier">$meta</span> <span class="synOperator">eq</span> <span class="synIdentifier">$base_metaclass{$_}</span>;
        }
        <span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$superclass</span> (<span class="synIdentifier">@superclasses</span>) {
        <span class="synIdentifier">$self-&gt;_check_class_metaclass_compatibility</span>(<span class="synIdentifier">$superclass</span>);
    }

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type</span> ( <span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span> ) {
        <span class="synStatement">next</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$self-&gt;$metaclass_type</span>;
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$superclass</span> (<span class="synIdentifier">@superclasses</span>) {
            <span class="synIdentifier">$self-&gt;_check_single_metaclass_compatibility</span>( <span class="synIdentifier">$metaclass_type</span>,
                <span class="synIdentifier">$superclass</span> );
        }
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_check_class_metaclass_compatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_class_metaclass_is_compatible</span>(<span class="synIdentifier">$superclass_name</span>)) {
        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>);

        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta_type</span> = <span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>;

        confess <span class="synString">&quot;The metaclass of &quot;</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot; (&quot;</span>
              . (<span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>)) . <span class="synString">&quot;)&quot;</span> .  <span class="synString">&quot; is not compatible with &quot;</span>
              . <span class="synString">&quot;the metaclass of its superclass, &quot;</span>
              . <span class="synIdentifier">$superclass_name</span> . <span class="synString">&quot; (&quot;</span> . (<span class="synIdentifier">$super_meta_type</span>) . <span class="synString">&quot;)&quot;</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_class_metaclass_is_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>)
        || <span class="synStatement">return</span> <span class="synNumber">1</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$super_meta_name</span> = <span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;_is_compatible_with</span>(<span class="synIdentifier">$super_meta_name</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_check_single_metaclass_compatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_single_metaclass_is_compatible</span>(<span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$superclass_name</span>)) {
        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>);
        <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type_name</span> = <span class="synIdentifier">$metaclass_type</span>;
        <span class="synIdentifier">$metaclass_type_name</span> =~ <span class="synStatement">s/</span><span class="synString">_</span><span class="synSpecial">(?:</span><span class="synString">meta</span><span class="synSpecial">)?</span><span class="synString">class$</span><span class="synStatement">//</span>;
        <span class="synIdentifier">$metaclass_type_name</span> =~ <span class="synStatement">s/</span><span class="synString">_</span><span class="synStatement">/</span><span class="synString"> </span><span class="synStatement">/g</span>;
        confess <span class="synString">&quot;The </span><span class="synIdentifier">$metaclass_type_name</span><span class="synString"> metaclass for &quot;</span>
              . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot; (&quot;</span> . (<span class="synIdentifier">$self-&gt;$metaclass_type</span>)
              . <span class="synString">&quot;)&quot;</span> . <span class="synString">&quot; is not compatible with the &quot;</span>
              . <span class="synString">&quot;</span><span class="synIdentifier">$metaclass_type_name</span><span class="synString"> metaclass of its &quot;</span>
              . <span class="synString">&quot;superclass, </span><span class="synIdentifier">$superclass_name</span><span class="synString"> (&quot;</span>
              . (<span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>) . <span class="synString">&quot;)&quot;</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_single_metaclass_is_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$superclass_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$super_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$superclass_name</span>)
        || <span class="synStatement">return</span> <span class="synNumber">1</span>;

    <span class="synComment"># for instance, Moose::Meta::Class has a error_class attribute, but</span>
    <span class="synComment"># Class::MOP::Class doesn't - this shouldn't be an error</span>
    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synIdentifier">$super_meta-&gt;can</span>(<span class="synIdentifier">$metaclass_type</span>);
    <span class="synComment"># for instance, Moose::Meta::Class has a destructor_class, but</span>
    <span class="synComment"># Class::MOP::Class doesn't - this shouldn't be an error</span>
    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>;
    <span class="synComment"># if metaclass is defined in superclass but not here, it's not compatible</span>
    <span class="synComment"># this is a really odd case</span>
    <span class="synStatement">return</span> <span class="synNumber">0</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$self-&gt;$metaclass_type</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;$metaclass_type-&gt;_is_compatible_with</span>(<span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_fix_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@supers</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$necessary</span> = <span class="synNumber">0</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$super</span> (<span class="synIdentifier">@supers</span>) {
        <span class="synIdentifier">$necessary</span> = <span class="synNumber">1</span>
            <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;_can_fix_metaclass_incompatibility</span>(<span class="synIdentifier">$super</span>);
    }
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$necessary</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$super</span> (<span class="synIdentifier">@supers</span>) {
        <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_class_metaclass_is_compatible</span>(<span class="synIdentifier">$super-&gt;name</span>)) {
            <span class="synIdentifier">$self-&gt;_fix_class_metaclass_incompatibility</span>(<span class="synIdentifier">$super</span>);
        }
    }

    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = <span class="synIdentifier">$self-&gt;_base_metaclasses</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span>) {
        <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$super</span> (<span class="synIdentifier">@supers</span>) {
            <span class="synConditional">if</span> (!<span class="synIdentifier">$self-&gt;_single_metaclass_is_compatible</span>(<span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$super-&gt;name</span>)) {
                <span class="synIdentifier">$self-&gt;_fix_single_metaclass_incompatibility</span>(
                    <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$super</span>
                );
            }
        }
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_can_fix_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$super_meta</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;_class_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">%base_metaclass</span> = <span class="synIdentifier">$self-&gt;_base_metaclasses</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$metaclass_type</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%base_metaclass</span>) {
        <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;_single_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>, <span class="synIdentifier">$metaclass_type</span>);
    }

    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_class_metaclass_can_be_made_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$super_meta</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;_can_be_made_compatible_with</span>(<span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_single_metaclass_can_be_made_compatible </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$super_meta</span>, <span class="synIdentifier">$metaclass_type</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$specific_meta</span> = <span class="synIdentifier">$self-&gt;$metaclass_type</span>;

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$super_meta-&gt;can</span>(<span class="synIdentifier">$metaclass_type</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$super_specific_meta</span> = <span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>;

    <span class="synComment"># for instance, Moose::Meta::Class has a destructor_class, but</span>
    <span class="synComment"># Class::MOP::Class doesn't - this shouldn't be an error</span>
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$super_specific_meta</span>;

    <span class="synComment"># if metaclass is defined in superclass but not here, it's fixable</span>
    <span class="synComment"># this is a really odd case</span>
    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$specific_meta</span>;

    <span class="synStatement">return</span> <span class="synNumber">1</span> <span class="synConditional">if</span> <span class="synIdentifier">$specific_meta-&gt;_can_be_made_compatible_with</span>(<span class="synIdentifier">$super_specific_meta</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_fix_class_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$super_meta</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$self-&gt;_class_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>)) {
        (<span class="synIdentifier">$self-&gt;is_pristine</span>)
            || confess <span class="synString">&quot;Can't fix metaclass incompatibility for &quot;</span>
                     . <span class="synIdentifier">$self-&gt;name</span>
                     . <span class="synString">&quot; because it is not pristine.&quot;</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$super_meta_name</span> = <span class="synIdentifier">$super_meta-&gt;_real_ref_name</span>;

        <span class="synIdentifier">$self-&gt;_make_compatible_with</span>(<span class="synIdentifier">$super_meta_name</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_fix_single_metaclass_incompatibility </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$metaclass_type</span>, <span class="synIdentifier">$super_meta</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$self-&gt;_single_metaclass_can_be_made_compatible</span>(<span class="synIdentifier">$super_meta</span>, <span class="synIdentifier">$metaclass_type</span>)) {
        (<span class="synIdentifier">$self-&gt;is_pristine</span>)
            || confess <span class="synString">&quot;Can't fix metaclass incompatibility for &quot;</span>
                     . <span class="synIdentifier">$self-&gt;name</span>
                     . <span class="synString">&quot; because it is not pristine.&quot;</span>;

        <span class="synStatement">my</span> <span class="synIdentifier">$new_metaclass</span> = <span class="synIdentifier">$self-&gt;$metaclass_type</span>
            ? <span class="synIdentifier">$self-&gt;$metaclass_type-&gt;_get_compatible_metaclass</span>(<span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>)
            : <span class="synIdentifier">$super_meta-&gt;$metaclass_type</span>;
        <span class="synIdentifier">$self-&gt;{$metaclass_type}</span> = <span class="synIdentifier">$new_metaclass</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_restore_metaobjects_from </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$old_meta</span>) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;_restore_metamethods_from</span>(<span class="synIdentifier">$old_meta</span>);
    <span class="synIdentifier">$self-&gt;_restore_metaattributes_from</span>(<span class="synIdentifier">$old_meta</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_remove_generated_metaobjects </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$self-&gt;get_attribute</span>(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_attribute_list</span>) {
        <span class="synIdentifier">$attr-&gt;remove_accessors</span>;
    }
}

<span class="synComment"># creating classes with MOP ...</span>

<span class="synKeyword">sub </span><span class="synFunction">create </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@args</span> = <span class="synIdentifier">@_</span>;

    <span class="synStatement">unshift</span> <span class="synIdentifier">@args</span>, <span class="synString">'package'</span> <span class="synConditional">if</span> <span class="synIdentifier">@args</span> % <span class="synNumber">2</span> == <span class="synNumber">1</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@args</span>;

    (<span class="synOperator">ref</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span>)
        || confess <span class="synString">&quot;You must pass an ARRAY ref of superclasses&quot;</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span>;

    (<span class="synOperator">ref</span> <span class="synIdentifier">$options{</span><span class="synString">attributes</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span>)
        || confess <span class="synString">&quot;You must pass an ARRAY ref of attributes&quot;</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">attributes</span><span class="synIdentifier">}</span>;

    (<span class="synOperator">ref</span> <span class="synIdentifier">$options{</span><span class="synString">methods</span><span class="synIdentifier">}</span> <span class="synOperator">eq</span> <span class="synString">'HASH'</span>)
        || confess <span class="synString">&quot;You must pass a HASH ref of methods&quot;</span>
            <span class="synConditional">if</span> <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">methods</span><span class="synIdentifier">}</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$package</span>      = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">package</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$superclasses</span> = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$attributes</span>   = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">attributes</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$methods</span>      = <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">methods</span><span class="synIdentifier">}</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span>    = <span class="synStatement">exists</span> <span class="synIdentifier">$options{</span><span class="synString">meta_name</span><span class="synIdentifier">}</span>
                         ? <span class="synStatement">delete</span> <span class="synIdentifier">$options{</span><span class="synString">meta_name</span><span class="synIdentifier">}</span>
                         : <span class="synString">'meta'</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$class-&gt;SUPER</span>::create(<span class="synIdentifier">$package</span> =&gt; <span class="synIdentifier">%options</span>);

    <span class="synIdentifier">$meta-&gt;_add_meta_method</span>(<span class="synIdentifier">$meta_name</span>)
        <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$meta_name</span>;

    <span class="synIdentifier">$meta-&gt;superclasses</span>(<span class="synIdentifier">@{$superclasses}</span>)
        <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$superclasses</span>;
    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># process attributes first, so that they can</span>
    <span class="synComment"># install accessors, but locally defined methods</span>
    <span class="synComment"># can then overwrite them. It is maybe a little odd, but</span>
    <span class="synComment"># I think this should be the order of things.</span>
    <span class="synConditional">if</span> (<span class="synOperator">defined</span> <span class="synIdentifier">$attributes</span>) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">@{$attributes}</span>) {
            <span class="synIdentifier">$meta-&gt;add_attribute</span>(<span class="synIdentifier">$attr</span>);
        }
    }
    <span class="synConditional">if</span> (<span class="synOperator">defined</span> <span class="synIdentifier">$methods</span>) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$method_name</span> (<span class="synStatement">keys</span> <span class="synIdentifier">%{$methods}</span>) {
            <span class="synIdentifier">$meta-&gt;add_method</span>(<span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$methods-&gt;{$method_name}</span>);
        }
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$meta</span>;
}

<span class="synComment"># </span><span class="synTodo">XXX:</span><span class="synComment"> something more intelligent here?</span>
<span class="synKeyword">sub </span><span class="synFunction">_anon_package_prefix </span>{ <span class="synString">'Class::MOP::Class::__ANON__::SERIAL::'</span> }

<span class="synKeyword">sub </span><span class="synFunction">create_anon_class </span>{ <span class="synStatement">shift</span>-&gt;create_anon(<span class="synIdentifier">@_</span>) }
<span class="synKeyword">sub </span><span class="synFunction">is_anon_class     </span>{ <span class="synStatement">shift</span>-&gt;is_anon(<span class="synIdentifier">@_</span>)     }

<span class="synKeyword">sub </span><span class="synFunction">_anon_cache_key </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = <span class="synIdentifier">@_</span>;
    <span class="synComment"># Makes something like Super::Class|Super::Class::2</span>
    <span class="synStatement">return</span> <span class="synStatement">join</span> <span class="synString">'='</span> =&gt; (
        <span class="synStatement">join</span>( <span class="synString">'|'</span>, <span class="synStatement">sort</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$options{</span><span class="synString">superclasses</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> || [] </span><span class="synIdentifier">}</span> ),
    );
}

<span class="synComment"># Instance Construction &amp; Cloning</span>

<span class="synKeyword">sub </span><span class="synFunction">new_object </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># we need to protect the integrity of the</span>
    <span class="synComment"># Class::MOP::Class singletons here, so we</span>
    <span class="synComment"># delegate this to &amp;construct_class_instance</span>
    <span class="synComment"># which will deal with the singletons</span>
    <span class="synStatement">return</span> <span class="synIdentifier">$class-&gt;_construct_class_instance</span>(<span class="synIdentifier">@_</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$class-&gt;name-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synStatement">return</span> <span class="synIdentifier">$class-&gt;_construct_instance</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_construct_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$params</span> = <span class="synIdentifier">@_</span> == <span class="synNumber">1</span> ? <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span> : {<span class="synIdentifier">@_</span>};
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$class-&gt;get_meta_instance</span>();
    <span class="synComment"># </span><span class="synTodo">FIXME:</span>
    <span class="synComment"># the code below is almost certainly incorrect</span>
    <span class="synComment"># but this is foreign inheritance, so we might</span>
    <span class="synComment"># have to kludge it in the end.</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$instance</span>;
    <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">$instance_class</span> = blessed(<span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>)) {
        (<span class="synIdentifier">$instance_class</span> <span class="synOperator">eq</span> <span class="synIdentifier">$class-&gt;name</span>)
            || confess <span class="synString">&quot;Objects passed as the __INSTANCE__ parameter must &quot;</span>
                     . <span class="synString">&quot;already be blessed into the correct class, but &quot;</span>
                     . <span class="synString">&quot;</span><span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span><span class="synString"> is not a &quot;</span> . <span class="synIdentifier">$class-&gt;name</span>;
        <span class="synIdentifier">$instance</span> = <span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>;
    }
    <span class="synConditional">elsif</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>) {
        confess <span class="synString">&quot;The __INSTANCE__ parameter must be a blessed reference, not &quot;</span>
              . <span class="synIdentifier">$params-&gt;{</span><span class="synString">__INSTANCE__</span><span class="synIdentifier">}</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$instance</span> = <span class="synIdentifier">$meta_instance-&gt;create_instance</span>();
    }
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">$class-&gt;get_all_attributes</span>()) {
        <span class="synIdentifier">$attr-&gt;initialize_instance_slot</span>(<span class="synIdentifier">$meta_instance</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">$params</span>);
    }
    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$class-&gt;name</span>)) {
        <span class="synIdentifier">$meta_instance-&gt;_set_mop_slot</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$class</span>);
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_new_object </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> (
        <span class="synString">'my $class = shift;'</span>,
        <span class="synString">'$class = Scalar::Util::blessed($class) || $class;'</span>,
        <span class="synIdentifier">$self-&gt;_inline_fallback_constructor</span>(<span class="synString">'$class'</span>),
        <span class="synIdentifier">$self-&gt;_inline_params</span>(<span class="synString">'$params'</span>, <span class="synString">'$class'</span>),
        <span class="synIdentifier">$self-&gt;_inline_generate_instance</span>(<span class="synString">'$instance'</span>, <span class="synString">'$class'</span>),
        <span class="synIdentifier">$self-&gt;_inline_slot_initializers</span>,
        <span class="synIdentifier">$self-&gt;_inline_preserve_weak_metaclasses</span>,
        <span class="synIdentifier">$self-&gt;_inline_extra_init</span>,
        <span class="synString">'return $instance'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_fallback_constructor </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> (
        <span class="synString">'return '</span> . <span class="synIdentifier">$self-&gt;_generate_fallback_constructor</span>(<span class="synIdentifier">$class</span>),
            <span class="synString">'if '</span> . <span class="synIdentifier">$class</span> . <span class="synString">' ne \''</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">'\';'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_generate_fallback_constructor </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> <span class="synString">'Class::MOP::Class-&gt;initialize('</span> . <span class="synIdentifier">$class</span> . <span class="synString">')-&gt;new_object(@_)'</span>,
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_params </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$params</span>, <span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> (
        <span class="synString">'my '</span> . <span class="synIdentifier">$params</span> . <span class="synString">' = @_ == 1 ? $_[0] : {@_};'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_generate_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$inst</span>, <span class="synIdentifier">$class</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">return</span> (
        <span class="synString">'my '</span> . <span class="synIdentifier">$inst</span> . <span class="synString">' = '</span> . <span class="synIdentifier">$self-&gt;_inline_create_instance</span>(<span class="synIdentifier">$class</span>) . <span class="synString">';'</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_create_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;inline_create_instance</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_slot_initializers </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$idx</span> = <span class="synNumber">0</span>;

    <span class="synStatement">return</span> <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$self-&gt;_inline_slot_initializer</span>(<span class="synIdentifier">$_</span>, <span class="synIdentifier">$idx</span>++) <span class="synStatement">}</span>
               <span class="synStatement">sort</span> <span class="synStatement">{</span> <span class="synIdentifier">$a-&gt;name</span> <span class="synOperator">cmp</span> <span class="synIdentifier">$b-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_all_attributes</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_slot_initializer </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>  = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synOperator">defined</span>(<span class="synStatement">my</span> <span class="synIdentifier">$init_arg</span> = <span class="synIdentifier">$attr-&gt;init_arg</span>)) {
        <span class="synStatement">my</span> <span class="synIdentifier">@source</span> = (
            <span class="synString">'if (exists $params-&gt;{\''</span> . <span class="synIdentifier">$init_arg</span> . <span class="synString">'\'}) {'</span>,
                <span class="synIdentifier">$self-&gt;_inline_init_attr_from_constructor</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>),
            <span class="synString">'}'</span>,
        );
        <span class="synConditional">if</span> (<span class="synStatement">my</span> <span class="synIdentifier">@default</span> = <span class="synIdentifier">$self-&gt;_inline_init_attr_from_default</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>)) {
            <span class="synStatement">push</span> <span class="synIdentifier">@source</span>, (
                <span class="synString">'else {'</span>,
                    <span class="synIdentifier">@default</span>,
                <span class="synString">'}'</span>,
            );
        }
        <span class="synStatement">return</span> <span class="synIdentifier">@source</span>;
    }
    <span class="synConditional">elsif</span> (<span class="synStatement">my</span> <span class="synIdentifier">@default</span> = <span class="synIdentifier">$self-&gt;_inline_init_attr_from_default</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>)) {
        <span class="synStatement">return</span> (
            <span class="synString">'{'</span>,
                <span class="synIdentifier">@default</span>,
            <span class="synString">'}'</span>,
        );
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> ();
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_init_attr_from_constructor </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@initial_value</span> = <span class="synIdentifier">$attr-&gt;_inline_set_value</span>(
        <span class="synString">'$instance'</span>, <span class="synString">'$params-&gt;{\''</span> . <span class="synIdentifier">$attr-&gt;init_arg</span> . <span class="synString">'\'}'</span>,
    );

    <span class="synStatement">push</span> <span class="synIdentifier">@initial_value</span>, (
        <span class="synString">'$attrs-&gt;['</span> . <span class="synIdentifier">$idx</span> . <span class="synString">']-&gt;set_initial_value('</span>,
            <span class="synString">'$instance,'</span>,
            <span class="synIdentifier">$attr-&gt;_inline_instance_get</span>(<span class="synString">'$instance'</span>),
        <span class="synString">');'</span>,
    ) <span class="synConditional">if</span> <span class="synIdentifier">$attr-&gt;has_initializer</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">@initial_value</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_init_attr_from_default </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$default</span> = <span class="synIdentifier">$self-&gt;_inline_default_value</span>(<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$idx</span>);
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$default</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@initial_value</span> = <span class="synIdentifier">$attr-&gt;_inline_set_value</span>(<span class="synString">'$instance'</span>, <span class="synIdentifier">$default</span>);

    <span class="synStatement">push</span> <span class="synIdentifier">@initial_value</span>, (
        <span class="synString">'$attrs-&gt;['</span> . <span class="synIdentifier">$idx</span> . <span class="synString">']-&gt;set_initial_value('</span>,
            <span class="synString">'$instance,'</span>,
            <span class="synIdentifier">$attr-&gt;_inline_instance_get</span>(<span class="synString">'$instance'</span>),
        <span class="synString">');'</span>,
    ) <span class="synConditional">if</span> <span class="synIdentifier">$attr-&gt;has_initializer</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">@initial_value</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_default_value </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$attr</span>, <span class="synIdentifier">$index</span>) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> (<span class="synIdentifier">$attr-&gt;has_default</span>) {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># default values can either be CODE refs</span>
        <span class="synComment"># in which case we need to call them. Or</span>
        <span class="synComment"># they can be scalars (strings/numbers)</span>
        <span class="synComment"># in which case we can just deal with them</span>
        <span class="synComment"># in the code we eval.</span>
        <span class="synConditional">if</span> (<span class="synIdentifier">$attr-&gt;is_default_a_coderef</span>) {
            <span class="synStatement">return</span> <span class="synString">'$defaults-&gt;['</span> . <span class="synIdentifier">$index</span> . <span class="synString">']-&gt;($instance)'</span>;
        }
        <span class="synConditional">else</span> {
            <span class="synStatement">return</span> <span class="synString">'$defaults-&gt;['</span> . <span class="synIdentifier">$index</span> . <span class="synString">']'</span>;
        }
    }
    <span class="synConditional">elsif</span> (<span class="synIdentifier">$attr-&gt;has_builder</span>) {
        <span class="synStatement">return</span> <span class="synString">'$instance-&gt;'</span> . <span class="synIdentifier">$attr-&gt;builder</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_preserve_weak_metaclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$self-&gt;name</span>)) {
        <span class="synStatement">return</span> (
            <span class="synIdentifier">$self-&gt;_inline_set_mop_slot</span>(
                <span class="synString">'$instance'</span>, <span class="synString">'Class::MOP::class_of($class)'</span>
            ) . <span class="synString">';'</span>
        );
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span> ();
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_extra_init </span>{ }

<span class="synKeyword">sub </span><span class="synFunction">_eval_environment </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@attrs</span> = <span class="synStatement">sort</span> <span class="synStatement">{</span> <span class="synIdentifier">$a-&gt;name</span> <span class="synOperator">cmp</span> <span class="synIdentifier">$b-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_all_attributes</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$defaults</span> = [<span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;default</span> <span class="synStatement">}</span> <span class="synIdentifier">@attrs</span>];

    <span class="synStatement">return</span> {
        <span class="synString">'$defaults'</span> =&gt; \<span class="synIdentifier">$defaults</span>,
    };
}


<span class="synKeyword">sub </span><span class="synFunction">get_meta_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;{</span><span class="synString">'_meta_instance'</span><span class="synIdentifier">}</span> ||= <span class="synIdentifier">$self-&gt;_create_meta_instance</span>();
}

<span class="synKeyword">sub </span><span class="synFunction">_create_meta_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$instance</span> = <span class="synIdentifier">$self-&gt;instance_metaclass-&gt;new</span>(
        <span class="synString">associated_metaclass</span> =&gt; <span class="synIdentifier">$self</span>,
        <span class="synString">attributes</span> =&gt; [ <span class="synIdentifier">$self-&gt;get_all_attributes</span>() ],
    );

    <span class="synIdentifier">$self-&gt;add_meta_instance_dependencies</span>()
        <span class="synConditional">if</span> <span class="synIdentifier">$instance-&gt;is_dependent_on_superclasses</span>();

    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synComment"># </span><span class="synTodo">TODO:</span><span class="synComment"> this is actually not being used!</span>
<span class="synKeyword">sub </span><span class="synFunction">_inline_rebless_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;inline_rebless_instance_structure</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_get_mop_slot </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;_inline_get_mop_slot</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_set_mop_slot </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;_inline_set_mop_slot</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_clear_mop_slot </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;get_meta_instance-&gt;_inline_clear_mop_slot</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">clone_object </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$class</span>    = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$instance</span> = <span class="synStatement">shift</span>;
    (blessed(<span class="synIdentifier">$instance</span>) &amp;&amp; <span class="synIdentifier">$instance-&gt;isa</span>(<span class="synIdentifier">$class-&gt;name</span>))
        || confess <span class="synString">&quot;You must pass an instance of the metaclass (&quot;</span> . (<span class="synOperator">ref</span> <span class="synIdentifier">$class</span> ? <span class="synIdentifier">$class-&gt;name</span> : <span class="synIdentifier">$class</span>) . <span class="synString">&quot;), not (</span><span class="synIdentifier">$instance</span><span class="synString">)&quot;</span>;

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># we need to protect the integrity of the</span>
    <span class="synComment"># Class::MOP::Class singletons here, they</span>
    <span class="synComment"># should not be cloned.</span>
    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span> <span class="synConditional">if</span> <span class="synIdentifier">$instance-&gt;isa</span>(<span class="synString">'Class::MOP::Class'</span>);
    <span class="synIdentifier">$class-&gt;_clone_instance</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_clone_instance </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$class</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    (blessed(<span class="synIdentifier">$instance</span>))
        || confess <span class="synString">&quot;You can only clone instances, (</span><span class="synIdentifier">$instance</span><span class="synString">) is not a blessed instance&quot;</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$class-&gt;get_meta_instance</span>();
    <span class="synStatement">my</span> <span class="synIdentifier">$clone</span> = <span class="synIdentifier">$meta_instance-&gt;clone_instance</span>(<span class="synIdentifier">$instance</span>);
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">$class-&gt;get_all_attributes</span>()) {
        <span class="synConditional">if</span> ( <span class="synOperator">defined</span>( <span class="synStatement">my</span> <span class="synIdentifier">$init_arg</span> = <span class="synIdentifier">$attr-&gt;init_arg</span> ) ) {
            <span class="synConditional">if</span> (<span class="synStatement">exists</span> <span class="synIdentifier">$params{$init_arg}</span>) {
                <span class="synIdentifier">$attr-&gt;set_value</span>(<span class="synIdentifier">$clone</span>, <span class="synIdentifier">$params{$init_arg}</span>);
            }
        }
    }
    <span class="synStatement">return</span> <span class="synIdentifier">$clone</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_force_rebless_instance </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = Class::MOP::class_of(<span class="synIdentifier">$instance</span>);

    <span class="synIdentifier">$old_metaclass-&gt;rebless_instance_away</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$self</span>, <span class="synIdentifier">%params</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">$old_metaclass</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$self-&gt;get_meta_instance</span>;

    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$old_metaclass-&gt;name</span>)) {
        <span class="synIdentifier">$meta_instance-&gt;_clear_mop_slot</span>(<span class="synIdentifier">$instance</span>);
    }

    <span class="synComment"># rebless!</span>
    <span class="synComment"># we use $_[1] here because of t/cmop/rebless_overload.t regressions</span>
    <span class="synComment"># on 5.8.8</span>
    <span class="synIdentifier">$meta_instance-&gt;rebless_instance_structure</span>(<span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span>, <span class="synIdentifier">$self</span>);

    <span class="synIdentifier">$self-&gt;_fixup_attributes_after_rebless</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$old_metaclass</span>, <span class="synIdentifier">%params</span>);

    <span class="synConditional">if</span> (Class::MOP::metaclass_is_weak(<span class="synIdentifier">$self-&gt;name</span>)) {
        <span class="synIdentifier">$meta_instance-&gt;_set_mop_slot</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$self</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">rebless_instance </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$instance</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = Class::MOP::class_of(<span class="synIdentifier">$instance</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$old_class</span> = <span class="synIdentifier">$old_metaclass</span> ? <span class="synIdentifier">$old_metaclass-&gt;name</span> : blessed(<span class="synIdentifier">$instance</span>);
    <span class="synIdentifier">$self-&gt;name-&gt;isa</span>(<span class="synIdentifier">$old_class</span>)
        || confess <span class="synString">&quot;You may rebless only into a subclass of (</span><span class="synIdentifier">$old_class</span><span class="synString">), of which (&quot;</span>. <span class="synIdentifier">$self-&gt;name</span> .<span class="synString">&quot;) isn't.&quot;</span>;

    <span class="synIdentifier">$self-&gt;_force_rebless_instance</span>(<span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span>, <span class="synIdentifier">%params</span>);

    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">rebless_instance_back </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$instance</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$old_metaclass</span> = Class::MOP::class_of(<span class="synIdentifier">$instance</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$old_class</span>
        = <span class="synIdentifier">$old_metaclass</span> ? <span class="synIdentifier">$old_metaclass-&gt;name</span> : blessed(<span class="synIdentifier">$instance</span>);
    <span class="synIdentifier">$old_class-&gt;isa</span>( <span class="synIdentifier">$self-&gt;name</span> )
        || confess
        <span class="synString">&quot;You may rebless only into a superclass of (</span><span class="synIdentifier">$old_class</span><span class="synString">), of which (&quot;</span>
        . <span class="synIdentifier">$self-&gt;name</span>
        . <span class="synString">&quot;) isn't.&quot;</span>;

    <span class="synIdentifier">$self-&gt;_force_rebless_instance</span>(<span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span>);

    <span class="synStatement">return</span> <span class="synIdentifier">$instance</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">rebless_instance_away </span>{
    <span class="synComment"># this intentionally does nothing, it is just a hook</span>
}

<span class="synKeyword">sub </span><span class="synFunction">_fixup_attributes_after_rebless </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> (<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$rebless_from</span>, <span class="synIdentifier">%params</span>) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_instance</span> = <span class="synIdentifier">$self-&gt;get_meta_instance</span>;

    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> ( <span class="synIdentifier">$rebless_from-&gt;get_all_attributes</span> ) {
        <span class="synStatement">next</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;find_attribute_by_name</span>( <span class="synIdentifier">$attr-&gt;name</span> );
        <span class="synIdentifier">$meta_instance-&gt;deinitialize_slot</span>( <span class="synIdentifier">$instance</span>, <span class="synIdentifier">$_</span> ) <span class="synRepeat">for</span> <span class="synIdentifier">$attr-&gt;slots</span>;
    }

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> ( <span class="synIdentifier">$self-&gt;get_all_attributes</span> ) {
        <span class="synConditional">if</span> ( <span class="synIdentifier">$attr-&gt;has_value</span>(<span class="synIdentifier">$instance</span>) ) {
            <span class="synConditional">if</span> ( <span class="synOperator">defined</span>( <span class="synStatement">my</span> <span class="synIdentifier">$init_arg</span> = <span class="synIdentifier">$attr-&gt;init_arg</span> ) ) {
                <span class="synIdentifier">$params{$init_arg}</span> = <span class="synIdentifier">$attr-&gt;get_value</span>(<span class="synIdentifier">$instance</span>)
                    <span class="synConditional">unless</span> <span class="synStatement">exists</span> <span class="synIdentifier">$params{$init_arg}</span>;
            }
            <span class="synConditional">else</span> {
                <span class="synIdentifier">$attr-&gt;set_value</span>(<span class="synIdentifier">$instance</span>, <span class="synIdentifier">$attr-&gt;get_value</span>(<span class="synIdentifier">$instance</span>));
            }
        }
    }

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr</span> (<span class="synIdentifier">$self-&gt;get_all_attributes</span>) {
        <span class="synIdentifier">$attr-&gt;initialize_instance_slot</span>(<span class="synIdentifier">$meta_instance</span>, <span class="synIdentifier">$instance</span>, \<span class="synIdentifier">%params</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_attach_attribute </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$attribute</span>) = <span class="synIdentifier">@_</span>;
    <span class="synIdentifier">$attribute-&gt;attach_to_class</span>(<span class="synIdentifier">$self</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_post_add_attribute </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$attribute</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;invalidate_meta_instances</span>;

    <span class="synComment"># invalidate package flag here</span>
    try {
        <span class="synStatement">local</span> <span class="synIdentifier">$SIG{</span><span class="synString">__DIE__</span><span class="synIdentifier">}</span>;
        <span class="synIdentifier">$attribute-&gt;install_accessors</span>;
    }
    catch {
        <span class="synIdentifier">$self-&gt;remove_attribute</span>( <span class="synIdentifier">$attribute-&gt;name</span> );
        <span class="synStatement">die</span> <span class="synIdentifier">$_</span>;
    };
}

<span class="synKeyword">sub </span><span class="synFunction">remove_attribute </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$removed_attribute</span> = <span class="synIdentifier">$self-&gt;SUPER</span>::remove_attribute(<span class="synIdentifier">@_</span>)
        <span class="synOperator">or</span> <span class="synStatement">return</span>;

    <span class="synIdentifier">$self-&gt;invalidate_meta_instances</span>;

    <span class="synIdentifier">$removed_attribute-&gt;remove_accessors</span>;
    <span class="synIdentifier">$removed_attribute-&gt;detach_from_class</span>;

    <span class="synStatement">return</span><span class="synIdentifier">$removed_attribute</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_attribute_by_name </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$attr_name</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> ( <span class="synIdentifier">$self-&gt;linearized_isa</span> ) {
        <span class="synComment"># fetch the meta-class ...</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$meta-&gt;get_attribute</span>(<span class="synIdentifier">$attr_name</span>)
            <span class="synConditional">if</span> <span class="synIdentifier">$meta-&gt;has_attribute</span>(<span class="synIdentifier">$attr_name</span>);
    }

    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">get_all_attributes </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%attrs</span> = <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> Class::MOP::Class</span><span class="synIdentifier">-&gt;initialize($_)-&gt;_attribute_map</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> <span class="synStatement">}</span>
        <span class="synStatement">reverse</span> <span class="synIdentifier">$self-&gt;linearized_isa</span>;
    <span class="synStatement">return</span> <span class="synStatement">values</span> <span class="synIdentifier">%attrs</span>;
}

<span class="synComment"># Inheritance</span>

<span class="synKeyword">sub </span><span class="synFunction">superclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>     = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$isa</span> = <span class="synIdentifier">$self-&gt;get_or_add_package_symbol</span>(<span class="synString">'@ISA'</span>);

    <span class="synConditional">if</span> (<span class="synIdentifier">@_</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">@supers</span> = <span class="synIdentifier">@_</span>;
        <span class="synIdentifier">@{$isa}</span> = <span class="synIdentifier">@supers</span>;

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># on 5.8 and below, we need to call</span>
        <span class="synComment"># a method to get Perl to detect</span>
        <span class="synComment"># a cycle in the class hierarchy</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$self-&gt;name</span>;
        <span class="synIdentifier">$class-&gt;isa</span>(<span class="synIdentifier">$class</span>);

        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># we need to check the metaclass</span>
        <span class="synComment"># compatibility here so that we can</span>
        <span class="synComment"># be sure that the superclass is</span>
        <span class="synComment"># not potentially creating an issues</span>
        <span class="synComment"># we don't know about</span>

        <span class="synIdentifier">$self-&gt;_check_metaclass_compatibility</span>();
        <span class="synIdentifier">$self-&gt;_superclasses_updated</span>();
    }

    <span class="synStatement">return</span> <span class="synIdentifier">@{$isa}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_superclasses_updated </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;update_meta_instance_dependencies</span>();
    <span class="synComment"># keep strong references to all our parents, so they don't disappear if</span>
    <span class="synComment"># they are anon classes and don't have any direct instances</span>
    <span class="synIdentifier">$self-&gt;_superclass_metas</span>(
        <span class="synStatement">map</span> <span class="synStatement">{</span> Class::MOP::class_of(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;superclasses</span>
    );
}

<span class="synKeyword">sub </span><span class="synFunction">_superclass_metas </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;{</span><span class="synString">_superclass_metas</span><span class="synIdentifier">}</span> = [<span class="synIdentifier">@_</span>];
}

<span class="synKeyword">sub </span><span class="synFunction">subclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$super_class</span> = <span class="synIdentifier">$self-&gt;name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$super_class-&gt;mro</span><span class="synperlVarBlock">::get_isarev() </span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">direct_subclasses </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$super_class</span> = <span class="synIdentifier">$self-&gt;name</span>;

    <span class="synStatement">return</span> <span class="synStatement">grep</span> <span class="synStatement">{</span>
        <span class="synStatement">grep</span> <span class="synStatement">{</span>
            <span class="synIdentifier">$_</span> <span class="synOperator">eq</span> <span class="synIdentifier">$super_class</span>
        <span class="synStatement">}</span> Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$_</span>)-&gt;superclasses
    <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;subclasses</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">linearized_isa </span>{
    <span class="synStatement">return</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> mro::get_linear_isa( (</span><span class="synStatement">shift</span><span class="synperlVarBlock">)-&gt;name ) </span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">class_precedence_list </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synIdentifier">$self-&gt;name</span>;

    <span class="synConditional">unless</span> (Class::MOP::IS_RUNNING_ON_5_10()) {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># We need to check for circular inheritance here</span>
        <span class="synComment"># if we are not on 5.10, cause 5.8 detects it late.</span>
        <span class="synComment"># This will do nothing if all is well, and blow up</span>
        <span class="synComment"># otherwise. Yes, it's an ugly hack, better</span>
        <span class="synComment"># suggestions are welcome.</span>
        <span class="synComment"># - SL</span>
        (<span class="synIdentifier">$name</span> || <span class="synStatement">return</span>)-&gt;isa(<span class="synString">'This is a test for circular inheritance'</span>)
    }

    <span class="synComment"># if our mro is c3, we can</span>
    <span class="synComment"># just grab the linear_isa</span>
    <span class="synConditional">if</span> (mro::get_mro(<span class="synIdentifier">$name</span>) <span class="synOperator">eq</span> <span class="synString">'c3'</span>) {
        <span class="synStatement">return</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> mro::get_linear_isa(</span><span class="synIdentifier">$name</span><span class="synperlVarBlock">) </span><span class="synIdentifier">}</span>
    }
    <span class="synConditional">else</span> {
        <span class="synComment"># </span><span class="synTodo">NOTE:</span>
        <span class="synComment"># we can't grab the linear_isa for dfs</span>
        <span class="synComment"># since it has all the duplicates</span>
        <span class="synComment"># already removed.</span>
        <span class="synStatement">return</span> (
            <span class="synIdentifier">$name</span>,
            <span class="synStatement">map</span> <span class="synStatement">{</span>
                Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$_</span>)-&gt;class_precedence_list()
            <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;superclasses</span>()
        );
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_method_lookup_order </span>{
    <span class="synStatement">return</span> (<span class="synStatement">shift</span>-&gt;linearized_isa, <span class="synString">'UNIVERSAL'</span>);
}

<span class="synComment">## Methods</span>

{
    <span class="synStatement">my</span> <span class="synIdentifier">$fetch_and_prepare_method</span> = <span class="synKeyword">sub </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$wrapped_metaclass</span> = <span class="synIdentifier">$self-&gt;wrapped_method_metaclass</span>;
        <span class="synComment"># fetch it locally</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$self-&gt;get_method</span>(<span class="synIdentifier">$method_name</span>);
        <span class="synComment"># if we don't have local ...</span>
        <span class="synConditional">unless</span> (<span class="synIdentifier">$method</span>) {
            <span class="synComment"># try to find the next method</span>
            <span class="synIdentifier">$method</span> = <span class="synIdentifier">$self-&gt;find_next_method_by_name</span>(<span class="synIdentifier">$method_name</span>);
            <span class="synComment"># die if it does not exist</span>
            (<span class="synOperator">defined</span> <span class="synIdentifier">$method</span>)
                || confess <span class="synString">&quot;The method '</span><span class="synIdentifier">$method_name</span><span class="synString">' was not found in the inheritance hierarchy for &quot;</span> . <span class="synIdentifier">$self-&gt;name</span>;
            <span class="synComment"># and now make sure to wrap it</span>
            <span class="synComment"># even if it is already wrapped</span>
            <span class="synComment"># because we need a new sub ref</span>
            <span class="synIdentifier">$method</span> = <span class="synIdentifier">$wrapped_metaclass-&gt;wrap</span>(<span class="synIdentifier">$method</span>,
                <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
                <span class="synString">name</span>         =&gt; <span class="synIdentifier">$method_name</span>,
            );
        }
        <span class="synConditional">else</span> {
            <span class="synComment"># now make sure we wrap it properly</span>
            <span class="synIdentifier">$method</span> = <span class="synIdentifier">$wrapped_metaclass-&gt;wrap</span>(<span class="synIdentifier">$method</span>,
                <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
                <span class="synString">name</span>         =&gt; <span class="synIdentifier">$method_name</span>,
            ) <span class="synConditional">unless</span> <span class="synIdentifier">$method-&gt;isa</span>(<span class="synIdentifier">$wrapped_metaclass</span>);
        }
        <span class="synIdentifier">$self-&gt;add_method</span>(<span class="synIdentifier">$method_name</span> =&gt; <span class="synIdentifier">$method</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span>;
    };

    <span class="synKeyword">sub </span><span class="synFunction">add_before_method_modifier </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$method_modifier</span>) = <span class="synIdentifier">@_</span>;
        (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
            || confess <span class="synString">&quot;You must pass in a method name&quot;</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$fetch_and_prepare_method</span>-&gt;(<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>);
        <span class="synIdentifier">$method-&gt;add_before_modifier</span>(
            subname(<span class="synString">':before'</span> =&gt; <span class="synIdentifier">$method_modifier</span>)
        );
    }

    <span class="synKeyword">sub </span><span class="synFunction">add_after_method_modifier </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$method_modifier</span>) = <span class="synIdentifier">@_</span>;
        (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
            || confess <span class="synString">&quot;You must pass in a method name&quot;</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$fetch_and_prepare_method</span>-&gt;(<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>);
        <span class="synIdentifier">$method-&gt;add_after_modifier</span>(
            subname(<span class="synString">':after'</span> =&gt; <span class="synIdentifier">$method_modifier</span>)
        );
    }

    <span class="synKeyword">sub </span><span class="synFunction">add_around_method_modifier </span>{
        <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>, <span class="synIdentifier">$method_modifier</span>) = <span class="synIdentifier">@_</span>;
        (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
            || confess <span class="synString">&quot;You must pass in a method name&quot;</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = <span class="synIdentifier">$fetch_and_prepare_method</span>-&gt;(<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>);
        <span class="synIdentifier">$method-&gt;add_around_modifier</span>(
            subname(<span class="synString">':around'</span> =&gt; <span class="synIdentifier">$method_modifier</span>)
        );
    }

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># the methods above used to be named like this:</span>
    <span class="synComment">#    ${pkg}::${method}:(before|after|around)</span>
    <span class="synComment"># but this proved problematic when using one modifier</span>
    <span class="synComment"># to wrap multiple methods (something which is likely</span>
    <span class="synComment"># to happen pretty regularly IMO). So instead of naming</span>
    <span class="synComment"># it like this, I have chosen to just name them purely</span>
    <span class="synComment"># with their modifier names, like so:</span>
    <span class="synComment">#    :(before|after|around)</span>
    <span class="synComment"># The fact is that in a stack trace, it will be fairly</span>
    <span class="synComment"># evident from the context what method they are attached</span>
    <span class="synComment"># to, and so don't need the fully qualified name.</span>
}

<span class="synKeyword">sub </span><span class="synFunction">find_method_by_name </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
        || confess <span class="synString">&quot;You must define a method name to find&quot;</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">$self-&gt;_method_lookup_order</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>)-&gt;get_method(<span class="synIdentifier">$method_name</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$method</span>;
    }
    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">get_all_methods </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%methods</span>;
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> ( <span class="synStatement">reverse</span> <span class="synIdentifier">$self-&gt;_method_lookup_order</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>);

        <span class="synIdentifier">$methods{</span><span class="synperlVarMember"> </span><span class="synIdentifier">$_-&gt;name</span><span class="synperlVarMember"> </span><span class="synIdentifier">}</span> = <span class="synIdentifier">$_</span> <span class="synRepeat">for</span> <span class="synIdentifier">$meta-&gt;_get_local_methods</span>;
    }

    <span class="synStatement">return</span> <span class="synStatement">values</span> <span class="synIdentifier">%methods</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">get_all_method_names </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_all_methods</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_all_methods_by_name </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
        || confess <span class="synString">&quot;You must define a method name to find&quot;</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@methods</span>;
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">$self-&gt;_method_lookup_order</span>) {
        <span class="synComment"># fetch the meta-class ...</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>);
        <span class="synStatement">push</span> <span class="synIdentifier">@methods</span> =&gt; {
            <span class="synString">name</span>  =&gt; <span class="synIdentifier">$method_name</span>,
            <span class="synString">class</span> =&gt; <span class="synIdentifier">$class</span>,
            <span class="synString">code</span>  =&gt; <span class="synIdentifier">$meta-&gt;get_method</span>(<span class="synIdentifier">$method_name</span>)
        } <span class="synConditional">if</span> <span class="synIdentifier">$meta-&gt;has_method</span>(<span class="synIdentifier">$method_name</span>);
    }
    <span class="synStatement">return</span> <span class="synIdentifier">@methods</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">find_next_method_by_name </span>{
    <span class="synStatement">my</span> (<span class="synIdentifier">$self</span>, <span class="synIdentifier">$method_name</span>) = <span class="synIdentifier">@_</span>;
    (<span class="synOperator">defined</span> <span class="synIdentifier">$method_name</span> &amp;&amp; <span class="synStatement">length</span> <span class="synIdentifier">$method_name</span>)
        || confess <span class="synString">&quot;You must define a method name to find&quot;</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@cpl</span> = (<span class="synIdentifier">$self-&gt;_method_lookup_order</span>);
    <span class="synStatement">shift</span> <span class="synIdentifier">@cpl</span>; <span class="synComment"># discard ourselves</span>
    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">@cpl</span>) {
        <span class="synStatement">my</span> <span class="synIdentifier">$method</span> = Class::MOP::Class-&gt;initialize(<span class="synIdentifier">$class</span>)-&gt;get_method(<span class="synIdentifier">$method_name</span>);
        <span class="synStatement">return</span> <span class="synIdentifier">$method</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$method</span>;
    }
    <span class="synStatement">return</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">update_meta_instance_dependencies </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;{</span><span class="synString">meta_instance_dependencies</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$self-&gt;add_meta_instance_dependencies</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">add_meta_instance_dependencies </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synIdentifier">$self-&gt;remove_meta_instance_dependencies</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">@attrs</span> = <span class="synIdentifier">$self-&gt;get_all_attributes</span>();

    <span class="synStatement">my</span> <span class="synIdentifier">%seen</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">@classes</span> = <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synOperator">not</span> <span class="synIdentifier">$seen{</span><span class="synperlVarMember"> </span><span class="synIdentifier">$_-&gt;name</span><span class="synperlVarMember"> </span><span class="synIdentifier">}</span>++ <span class="synStatement">}</span>
        <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;associated_class</span> <span class="synStatement">}</span> <span class="synIdentifier">@attrs</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">@classes</span>) {
        <span class="synIdentifier">$class-&gt;add_dependent_meta_instance</span>(<span class="synIdentifier">$self</span>);
    }

    <span class="synIdentifier">$self-&gt;{</span><span class="synString">meta_instance_dependencies</span><span class="synIdentifier">}</span> = \<span class="synIdentifier">@classes</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">remove_meta_instance_dependencies </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$classes</span> = <span class="synStatement">delete</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">meta_instance_dependencies</span><span class="synIdentifier">}</span> ) {
        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$class</span> (<span class="synIdentifier">@$classes</span>) {
            <span class="synIdentifier">$class-&gt;remove_dependent_meta_instance</span>(<span class="synIdentifier">$self</span>);
        }

        <span class="synStatement">return</span> <span class="synIdentifier">$classes</span>;
    }

    <span class="synStatement">return</span>;

}

<span class="synKeyword">sub </span><span class="synFunction">add_dependent_meta_instance </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$metaclass</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">push</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$self-&gt;{</span><span class="synString">dependent_meta_instances</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>, <span class="synIdentifier">$metaclass</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">remove_dependent_meta_instance </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$metaclass</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synIdentifier">$metaclass-&gt;name</span>;
    <span class="synIdentifier">@$_</span> = <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;name</span> <span class="synOperator">ne</span> <span class="synIdentifier">$name</span> <span class="synStatement">}</span> <span class="synIdentifier">@$_</span>
        <span class="synRepeat">for</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">dependent_meta_instances</span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">invalidate_meta_instances </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$_-&gt;invalidate_meta_instance</span>()
        <span class="synRepeat">for</span> <span class="synIdentifier">$self</span>, <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$self-&gt;{</span><span class="synString">dependent_meta_instances</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">invalidate_meta_instance </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;
    <span class="synOperator">undef</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">_meta_instance</span><span class="synIdentifier">}</span>;
}

<span class="synComment"># check if we can reinitialize</span>
<span class="synKeyword">sub </span><span class="synFunction">is_pristine </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synComment"># if any local attr is defined</span>
    <span class="synStatement">return</span> <span class="synConditional">if</span> <span class="synIdentifier">$self-&gt;get_attribute_list</span>;

    <span class="synComment"># or any non-declared methods</span>
    <span class="synRepeat">for</span> <span class="synStatement">my</span> <span class="synIdentifier">$method</span> ( <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$self-&gt;get_method</span>(<span class="synIdentifier">$_</span>) <span class="synStatement">}</span> <span class="synIdentifier">$self-&gt;get_method_list</span> ) {
        <span class="synStatement">return</span> <span class="synConditional">if</span> <span class="synIdentifier">$method-&gt;isa</span>(<span class="synString">&quot;Class::MOP::Method::Generated&quot;</span>);
        <span class="synComment"># </span><span class="synTodo">FIXME</span><span class="synComment"> do we need to enforce this too? return unless $method-&gt;isa( $self-&gt;method_metaclass );</span>
    }

    <span class="synStatement">return</span> <span class="synNumber">1</span>;
}

<span class="synComment">## Class closing</span>

<span class="synKeyword">sub </span><span class="synFunction">is_mutable   </span>{ <span class="synNumber">1</span> }
<span class="synKeyword">sub </span><span class="synFunction">is_immutable </span>{ <span class="synNumber">0</span> }

<span class="synKeyword">sub </span><span class="synFunction">immutable_options </span>{ <span class="synIdentifier">%{</span><span class="synperlVarBlock2"> </span><span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">options</span><span class="synIdentifier">}</span><span class="synperlVarBlock2"> || {</span>}<span class="synperlVarBlock2"> </span><span class="synIdentifier">}</span> }

<span class="synKeyword">sub </span><span class="synFunction">_immutable_options </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> (
        <span class="synString">inline_accessors</span>   =&gt; <span class="synNumber">1</span>,
        <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">1</span>,
        <span class="synString">inline_destructor</span>  =&gt; <span class="synNumber">0</span>,
        <span class="synString">debug</span>              =&gt; <span class="synNumber">0</span>,
        <span class="synString">immutable_trait</span>    =&gt; <span class="synIdentifier">$self-&gt;immutable_trait</span>,
        <span class="synString">constructor_name</span>   =&gt; <span class="synIdentifier">$self-&gt;constructor_name</span>,
        <span class="synString">constructor_class</span>  =&gt; <span class="synIdentifier">$self-&gt;constructor_class</span>,
        <span class="synString">destructor_class</span>   =&gt; <span class="synIdentifier">$self-&gt;destructor_class</span>,
        <span class="synIdentifier">@args</span>,
    );
}

<span class="synKeyword">sub </span><span class="synFunction">make_immutable </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span> <span class="synConditional">unless</span> <span class="synIdentifier">$self-&gt;is_mutable</span>;

    <span class="synStatement">my</span> (<span class="synIdentifier">$file</span>, <span class="synIdentifier">$line</span>) = (<span class="synStatement">caller</span>)[<span class="synFloat">1..2</span>];

    <span class="synIdentifier">$self-&gt;_initialize_immutable</span>(
        <span class="synString">file</span> =&gt; <span class="synIdentifier">$file</span>,
        <span class="synString">line</span> =&gt; <span class="synIdentifier">$line</span>,
        <span class="synIdentifier">$self-&gt;_immutable_options</span>(<span class="synIdentifier">@args</span>),
    );
    <span class="synIdentifier">$self-&gt;_rebless_as_immutable</span>(<span class="synIdentifier">@args</span>);

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">make_mutable </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;is_immutable</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">@args</span> = <span class="synIdentifier">$self-&gt;immutable_options</span>;
        <span class="synIdentifier">$self-&gt;_rebless_as_mutable</span>();
        <span class="synIdentifier">$self-&gt;_remove_inlined_code</span>(<span class="synIdentifier">@args</span>);
        <span class="synStatement">delete</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
    }
    <span class="synConditional">else</span> {
        <span class="synStatement">return</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_rebless_as_immutable </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">@args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">original_class</span><span class="synIdentifier">}</span> = <span class="synOperator">ref</span> <span class="synIdentifier">$self</span>;

    <span class="synOperator">bless</span> <span class="synIdentifier">$self</span> =&gt; <span class="synIdentifier">$self-&gt;_immutable_metaclass</span>(<span class="synIdentifier">@args</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_immutable_metaclass </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$args{</span><span class="synString">immutable_metaclass</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">return</span> <span class="synIdentifier">$class</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$trait</span> = <span class="synIdentifier">$args{</span><span class="synString">immutable_trait</span><span class="synIdentifier">}</span> = <span class="synIdentifier">$self-&gt;immutable_trait</span>
        || confess <span class="synString">&quot;no immutable trait specified for </span><span class="synIdentifier">$self</span><span class="synString">&quot;</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span>      = <span class="synIdentifier">$self-&gt;meta</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_attr</span> = <span class="synIdentifier">$meta-&gt;find_attribute_by_name</span>(<span class="synString">&quot;immutable_trait&quot;</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$class_name</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$meta_attr</span> <span class="synOperator">and</span> <span class="synIdentifier">$trait</span> <span class="synOperator">eq</span> <span class="synIdentifier">$meta_attr-&gt;default</span> ) {
        <span class="synComment"># if the trait is the same as the default we try and pick a</span>
        <span class="synComment"># predictable name for the immutable metaclass</span>
        <span class="synIdentifier">$class_name</span> = <span class="synString">'Class::MOP::Class::Immutable::'</span> . <span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>);
    }
    <span class="synConditional">else</span> {
        <span class="synIdentifier">$class_name</span> = <span class="synStatement">join</span> <span class="synString">'::'</span>, <span class="synString">'Class::MOP::Class::Immutable::CustomTrait'</span>,
            <span class="synIdentifier">$trait</span>, <span class="synString">'ForMetaClass'</span>, <span class="synOperator">ref</span>(<span class="synIdentifier">$self</span>);
    }

    <span class="synStatement">return</span> <span class="synIdentifier">$class_name</span>
        <span class="synConditional">if</span> is_class_loaded(<span class="synIdentifier">$class_name</span>);

    <span class="synComment"># If the metaclass is a subclass of CMOP::Class which has had</span>
    <span class="synComment"># metaclass roles applied (via Moose), then we want to make sure</span>
    <span class="synComment"># that we preserve that anonymous class (see Fey::ORM for an</span>
    <span class="synComment"># example of where this matters).</span>
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span> = <span class="synIdentifier">$meta-&gt;_real_ref_name</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$immutable_meta</span> = <span class="synIdentifier">$meta_name-&gt;create</span>(
        <span class="synIdentifier">$class_name</span>,
        <span class="synString">superclasses</span> =&gt; [ <span class="synOperator">ref</span> <span class="synIdentifier">$self</span> ],
    );

    Class::MOP::MiniTrait::apply( <span class="synIdentifier">$immutable_meta</span>, <span class="synIdentifier">$trait</span> );

    <span class="synIdentifier">$immutable_meta-&gt;make_immutable</span>(
        <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">0</span>,
        <span class="synString">inline_accessors</span>   =&gt; <span class="synNumber">0</span>,
    );

    <span class="synStatement">return</span> <span class="synIdentifier">$class_name</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_remove_inlined_code </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synIdentifier">$self-&gt;remove_method</span>( <span class="synIdentifier">$_-&gt;name</span> ) <span class="synRepeat">for</span> <span class="synIdentifier">$self-&gt;_inlined_methods</span>;

    <span class="synStatement">delete</span> <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">inlined_methods</span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inlined_methods </span>{ <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">inlined_methods</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> || [] </span><span class="synIdentifier">}</span> }

<span class="synKeyword">sub </span><span class="synFunction">_add_inlined_method </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">$method</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">push</span> <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">inlined_methods</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> ||= [] </span><span class="synIdentifier">}</span>, <span class="synIdentifier">$method</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_initialize_immutable </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synIdentifier">$self-&gt;{</span><span class="synString">__immutable</span><span class="synIdentifier">}{</span><span class="synString">options</span><span class="synIdentifier">}</span> = \<span class="synIdentifier">%args</span>;
    <span class="synIdentifier">$self-&gt;_install_inlined_code</span>(<span class="synIdentifier">%args</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">_install_inlined_code </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synComment"># </span><span class="synTodo">FIXME</span>
    <span class="synIdentifier">$self-&gt;_inline_accessors</span>(<span class="synIdentifier">%args</span>)   <span class="synConditional">if</span> <span class="synIdentifier">$args{</span><span class="synString">inline_accessors</span><span class="synIdentifier">}</span>;
    <span class="synIdentifier">$self-&gt;_inline_constructor</span>(<span class="synIdentifier">%args</span>) <span class="synConditional">if</span> <span class="synIdentifier">$args{</span><span class="synString">inline_constructor</span><span class="synIdentifier">}</span>;
    <span class="synIdentifier">$self-&gt;_inline_destructor</span>(<span class="synIdentifier">%args</span>)  <span class="synConditional">if</span> <span class="synIdentifier">$args{</span><span class="synString">inline_destructor</span><span class="synIdentifier">}</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_rebless_as_mutable </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synOperator">bless</span> <span class="synIdentifier">$self</span>, <span class="synIdentifier">$self-&gt;_get_mutable_metaclass_name</span>;

    <span class="synStatement">return</span> <span class="synIdentifier">$self</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_accessors </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span> = <span class="synStatement">shift</span>;

    <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$attr_name</span> ( <span class="synIdentifier">$self-&gt;get_attribute_list</span> ) {
        <span class="synIdentifier">$self-&gt;get_attribute</span>(<span class="synIdentifier">$attr_name</span>)-&gt;install_accessors(<span class="synNumber">1</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_constructor </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synIdentifier">$args{</span><span class="synString">constructor_name</span><span class="synIdentifier">}</span>;
    <span class="synComment"># A class may not even have a constructor, and that's okay.</span>
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$name</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;has_method</span>(<span class="synIdentifier">$name</span>) &amp;&amp; !<span class="synIdentifier">$args{</span><span class="synString">replace_constructor</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$self-&gt;name</span>;
        <span class="synStatement">warn</span> <span class="synString">&quot;Not inlining a constructor for </span><span class="synIdentifier">$class</span><span class="synString"> since it defines&quot;</span>
            . <span class="synString">&quot; its own constructor.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>
            . <span class="synString">&quot;If you are certain you don't need to inline your&quot;</span>
            . <span class="synString">&quot; constructor, specify inline_constructor =&gt; 0 in your&quot;</span>
            . <span class="synString">&quot; call to </span><span class="synIdentifier">$class-&gt;meta-&gt;make_immutable</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$constructor_class</span> = <span class="synIdentifier">$args{</span><span class="synString">constructor_class</span><span class="synIdentifier">}</span>;

    load_class(<span class="synIdentifier">$constructor_class</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$constructor</span> = <span class="synIdentifier">$constructor_class-&gt;new</span>(
        <span class="synString">options</span>      =&gt; \<span class="synIdentifier">%args</span>,
        <span class="synString">metaclass</span>    =&gt; <span class="synIdentifier">$self</span>,
        <span class="synString">is_inline</span>    =&gt; <span class="synNumber">1</span>,
        <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
        <span class="synString">name</span>         =&gt; <span class="synIdentifier">$name</span>,
        <span class="synString">definition_context</span> =&gt; {
            <span class="synString">description</span> =&gt; <span class="synString">&quot;constructor &quot;</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot;::&quot;</span> . <span class="synIdentifier">$name</span>,
            <span class="synString">file</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">file</span><span class="synIdentifier">}</span>,
            <span class="synString">line</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">line</span><span class="synIdentifier">}</span>,
        },
    );

    <span class="synConditional">if</span> ( <span class="synIdentifier">$args{</span><span class="synString">replace_constructor</span><span class="synIdentifier">}</span> <span class="synOperator">or</span> <span class="synIdentifier">$constructor-&gt;can_be_inlined</span> ) {
        <span class="synIdentifier">$self-&gt;add_method</span>( <span class="synIdentifier">$name</span> =&gt; <span class="synIdentifier">$constructor</span> );
        <span class="synIdentifier">$self-&gt;_add_inlined_method</span>(<span class="synIdentifier">$constructor</span>);
    }
}

<span class="synKeyword">sub </span><span class="synFunction">_inline_destructor </span>{
    <span class="synStatement">my</span> ( <span class="synIdentifier">$self</span>, <span class="synIdentifier">%args</span> ) = <span class="synIdentifier">@_</span>;

    ( <span class="synStatement">exists</span> <span class="synIdentifier">$args{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$args{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span> )
        || confess <span class="synString">&quot;The 'inline_destructor' option is present, but &quot;</span>
        . <span class="synString">&quot;no destructor class was specified&quot;</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$self-&gt;has_method</span>(<span class="synString">'DESTROY'</span>) &amp;&amp; ! <span class="synIdentifier">$args{</span><span class="synString">replace_destructor</span><span class="synIdentifier">}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$self-&gt;name</span>;
        <span class="synStatement">warn</span> <span class="synString">&quot;Not inlining a destructor for </span><span class="synIdentifier">$class</span><span class="synString"> since it defines&quot;</span>
            . <span class="synString">&quot; its own destructor.</span><span class="synSpecial">\n</span><span class="synString">&quot;</span>;
        <span class="synStatement">return</span>;
    }

    <span class="synStatement">my</span> <span class="synIdentifier">$destructor_class</span> = <span class="synIdentifier">$args{</span><span class="synString">destructor_class</span><span class="synIdentifier">}</span>;

    load_class(<span class="synIdentifier">$destructor_class</span>);

    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$destructor_class-&gt;is_needed</span>(<span class="synIdentifier">$self</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$destructor</span> = <span class="synIdentifier">$destructor_class-&gt;new</span>(
        <span class="synString">options</span>      =&gt; \<span class="synIdentifier">%args</span>,
        <span class="synString">metaclass</span>    =&gt; <span class="synIdentifier">$self</span>,
        <span class="synString">package_name</span> =&gt; <span class="synIdentifier">$self-&gt;name</span>,
        <span class="synString">name</span>         =&gt; <span class="synString">'DESTROY'</span>,
        <span class="synString">definition_context</span> =&gt; {
            <span class="synString">description</span> =&gt; <span class="synString">&quot;destructor &quot;</span> . <span class="synIdentifier">$self-&gt;name</span> . <span class="synString">&quot;::DESTROY&quot;</span>,
            <span class="synString">file</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">file</span><span class="synIdentifier">}</span>,
            <span class="synString">line</span>        =&gt; <span class="synIdentifier">$args{</span><span class="synString">line</span><span class="synIdentifier">}</span>,
        },
    );

    <span class="synConditional">if</span> ( <span class="synIdentifier">$args{</span><span class="synString">replace_destructor</span><span class="synIdentifier">}</span> <span class="synOperator">or</span> <span class="synIdentifier">$destructor-&gt;can_be_inlined</span> ) {
        <span class="synIdentifier">$self-&gt;add_method</span>( <span class="synString">'DESTROY'</span> =&gt; <span class="synIdentifier">$destructor</span> );
        <span class="synIdentifier">$self-&gt;_add_inlined_method</span>(<span class="synIdentifier">$destructor</span>);
    }
}

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: Class Meta Object</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Class::MOP::Class - Class Meta Object</span>

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

<span class="synperlPOD">version 2.1005</span>

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synPreProc">  # assuming that class Foo</span>
<span class="synPreProc">  # has been defined, you can</span>

<span class="synPreProc">  # use this for introspection ...</span>

<span class="synPreProc">  # add a method to Foo ...</span>
<span class="synPreProc">  Foo-&gt;meta-&gt;add_method( 'bar' =&gt; sub {...} )</span>

<span class="synPreProc">  # get a list of all the classes searched</span>
<span class="synPreProc">  # the method dispatcher in the correct order</span>
<span class="synPreProc">  Foo-&gt;meta-&gt;class_precedence_list()</span>

<span class="synPreProc">  # remove a method from Foo</span>
<span class="synPreProc">  Foo-&gt;meta-&gt;remove_method('bar');</span>

<span class="synPreProc">  # or use this to actually create classes ...</span>

<span class="synPreProc">  Class::MOP::Class-&gt;create(</span>
<span class="synPreProc">      'Bar' =&gt; (</span>
<span class="synPreProc">          version      =&gt; '0.01',</span>
<span class="synPreProc">          superclasses =&gt; ['Foo'],</span>
<span class="synPreProc">          attributes   =&gt; [</span>
<span class="synPreProc">              Class::MOP::Attribute-&gt;new('$bar'),</span>
<span class="synPreProc">              Class::MOP::Attribute-&gt;new('$baz'),</span>
<span class="synPreProc">          ],</span>
<span class="synPreProc">          methods =&gt; {</span>
<span class="synPreProc">              calculate_bar =&gt; sub {...},</span>
<span class="synPreProc">              construct_baz =&gt; sub {...}</span>
<span class="synPreProc">          }</span>
<span class="synPreProc">      )</span>
<span class="synPreProc">  );</span>

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

<span class="synperlPOD">The Class Protocol is the largest and most complex part of the</span>
<span class="synperlPOD">Class::MOP meta-object protocol. It controls the introspection and</span>
<span class="synperlPOD">manipulation of Perl 5 classes, and it can create them as well. The</span>
<span class="synperlPOD">best way to understand what this module can do is to read the</span>
<span class="synperlPOD">documentation for each of its methods.</span>

<span class="synStatement">=head1</span><span class="synString"> INHERITANCE</span>

<span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> is a subclass of </span><span class="synIdentifier">L&lt;Class::MOP::Module&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head1</span><span class="synString"> METHODS</span>

<span class="synStatement">=head2</span><span class="synString"> Class construction</span>

<span class="synperlPOD">These methods all create new </span><span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> objects. These</span>
<span class="synperlPOD">objects can represent existing classes or they can be used to create</span>
<span class="synperlPOD">new classes from scratch.</span>

<span class="synperlPOD">The metaclass object for a given class is a singleton. If you attempt</span>
<span class="synperlPOD">to create a metaclass for the same class twice, you will just get the</span>
<span class="synperlPOD">existing object.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;create($package_name, %options) &gt;&gt;</span>

<span class="synperlPOD">This method creates a new </span><span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> object with the given</span>
<span class="synperlPOD">package name. It accepts a number of options:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">8</span>

<span class="synStatement">=item</span><span class="synString"> * version</span>

<span class="synperlPOD">An optional version number for the newly created package.</span>

<span class="synStatement">=item</span><span class="synString"> * authority</span>

<span class="synperlPOD">An optional authority for the newly created package.</span>

<span class="synStatement">=item</span><span class="synString"> * superclasses</span>

<span class="synperlPOD">An optional array reference of superclass names.</span>

<span class="synStatement">=item</span><span class="synString"> * methods</span>

<span class="synperlPOD">An optional hash reference of methods for the class. The keys of the</span>
<span class="synperlPOD">hash reference are method names and values are subroutine references.</span>

<span class="synStatement">=item</span><span class="synString"> * attributes</span>

<span class="synperlPOD">An optional array reference of </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD"> objects.</span>

<span class="synStatement">=item</span><span class="synString"> * meta_name</span>

<span class="synperlPOD">Specifies the name to install the </span><span class="synIdentifier">C&lt;meta&gt;</span><span class="synperlPOD"> method for this class under.</span>
<span class="synperlPOD">If it is not passed, </span><span class="synIdentifier">C&lt;meta&gt;</span><span class="synperlPOD"> is assumed, and if </span><span class="synIdentifier">C&lt;undef&gt;</span><span class="synperlPOD"> is explicitly</span>
<span class="synperlPOD">given, no meta method will be installed.</span>

<span class="synStatement">=item</span><span class="synString"> * weaken</span>

<span class="synperlPOD">If true, the metaclass that is stored in the global cache will be a</span>
<span class="synperlPOD">weak reference.</span>

<span class="synperlPOD">Classes created in this way are destroyed once the metaclass they are</span>
<span class="synperlPOD">attached to goes out of scope, and will be removed from Perl's internal</span>
<span class="synperlPOD">symbol table.</span>

<span class="synperlPOD">All instances of a class with a weakened metaclass keep a special</span>
<span class="synperlPOD">reference to the metaclass object, which prevents the metaclass from</span>
<span class="synperlPOD">going out of scope while any instances exist.</span>

<span class="synperlPOD">This only works if the instance is based on a hash reference, however.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;create_anon_class(%options) &gt;&gt;</span>

<span class="synperlPOD">This method works just like </span><span class="synIdentifier">C&lt;&lt; Class::MOP::Class-&gt;create &gt;&gt;</span><span class="synperlPOD"> but it</span>
<span class="synperlPOD">creates an &quot;anonymous&quot; class. In fact, the class does have a name, but</span>
<span class="synperlPOD">that name is a unique name generated internally by this module.</span>

<span class="synperlPOD">It accepts the same </span><span class="synIdentifier">C&lt;superclasses&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;methods&gt;</span><span class="synperlPOD">, and </span><span class="synIdentifier">C&lt;attributes&gt;</span>
<span class="synperlPOD">parameters that </span><span class="synIdentifier">C&lt;create&gt;</span><span class="synperlPOD"> accepts.</span>

<span class="synperlPOD">Anonymous classes default to </span><span class="synIdentifier">C&lt;&lt; weaken =&gt; 1 &gt;&gt;</span><span class="synperlPOD">, although this can be</span>
<span class="synperlPOD">overridden.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;initialize($package_name, %options) &gt;&gt;</span>

<span class="synperlPOD">This method will initialize a </span><span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> object for the</span>
<span class="synperlPOD">named package. Unlike </span><span class="synIdentifier">C&lt;create&gt;</span><span class="synperlPOD">, this method </span><span class="synIdentifier">I&lt;will not&gt;</span><span class="synperlPOD"> create a new</span>
<span class="synperlPOD">class.</span>

<span class="synperlPOD">The purpose of this method is to retrieve a </span><span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span>
<span class="synperlPOD">object for introspecting an existing class.</span>

<span class="synperlPOD">If an existing </span><span class="synIdentifier">C&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> object exists for the named</span>
<span class="synperlPOD">package, it will be returned, and any options provided will be</span>
<span class="synperlPOD">ignored!</span>

<span class="synperlPOD">If the object does not yet exist, it will be created.</span>

<span class="synperlPOD">The valid options that can be passed to this method are</span>
<span class="synIdentifier">C&lt;attribute_metaclass&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;method_metaclass&gt;</span><span class="synperlPOD">,</span>
<span class="synIdentifier">C&lt;wrapped_method_metaclass&gt;</span><span class="synperlPOD">, and </span><span class="synIdentifier">C&lt;instance_metaclass&gt;</span><span class="synperlPOD">. These are all</span>
<span class="synperlPOD">optional, and default to the appropriate class in the </span><span class="synIdentifier">C&lt;Class::MOP&gt;</span>
<span class="synperlPOD">distribution.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Object instance construction and cloning</span>

<span class="synperlPOD">These methods are all related to creating and/or cloning object</span>
<span class="synperlPOD">instances.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;clone_object($instance, %params) &gt;&gt;</span>

<span class="synperlPOD">This method clones an existing object instance. Any parameters you</span>
<span class="synperlPOD">provide are will override existing attribute values in the object.</span>

<span class="synperlPOD">This is a convenience method for cloning an object instance, then</span>
<span class="synperlPOD">blessing it into the appropriate package.</span>

<span class="synperlPOD">You could implement a clone method in your class, using this method:</span>

<span class="synPreProc">  sub clone {</span>
<span class="synPreProc">      my ($self, %params) = @_;</span>
<span class="synPreProc">      $self-&gt;meta-&gt;clone_object($self, %params);</span>
<span class="synPreProc">  }</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;rebless_instance($instance, %params) &gt;&gt;</span>

<span class="synperlPOD">This method changes the class of </span><span class="synIdentifier">C&lt;$instance&gt;</span><span class="synperlPOD"> to the metaclass's class.</span>

<span class="synperlPOD">You can only rebless an instance into a subclass of its current</span>
<span class="synperlPOD">class. If you pass any additional parameters, these will be treated</span>
<span class="synperlPOD">like constructor parameters and used to initialize the object's</span>
<span class="synperlPOD">attributes. Any existing attributes that are already set will be</span>
<span class="synperlPOD">overwritten.</span>

<span class="synperlPOD">Before reblessing the instance, this method will call</span>
<span class="synIdentifier">C&lt;rebless_instance_away&gt;</span><span class="synperlPOD"> on the instance's current metaclass. This method</span>
<span class="synperlPOD">will be passed the instance, the new metaclass, and any parameters</span>
<span class="synperlPOD">specified to </span><span class="synIdentifier">C&lt;rebless_instance&gt;</span><span class="synperlPOD">. By default, </span><span class="synIdentifier">C&lt;rebless_instance_away&gt;</span>
<span class="synperlPOD">does nothing; it is merely a hook.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;rebless_instance_back($instance) &gt;&gt;</span>

<span class="synperlPOD">Does the same thing as </span><span class="synIdentifier">C&lt;rebless_instance&gt;</span><span class="synperlPOD">, except that you can only</span>
<span class="synperlPOD">rebless an instance into one of its superclasses. Any attributes that</span>
<span class="synperlPOD">do not exist in the superclass will be deinitialized.</span>

<span class="synperlPOD">This is a much more dangerous operation than </span><span class="synIdentifier">C&lt;rebless_instance&gt;</span><span class="synperlPOD">,</span>
<span class="synperlPOD">especially when multiple inheritance is involved, so use this carefully!</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;new_object(%params) &gt;&gt;</span>

<span class="synperlPOD">This method is used to create a new object of the metaclass's</span>
<span class="synperlPOD">class. Any parameters you provide are used to initialize the</span>
<span class="synperlPOD">instance's attributes. A special </span><span class="synIdentifier">C&lt;__INSTANCE__&gt;</span><span class="synperlPOD"> key can be passed to</span>
<span class="synperlPOD">provide an already generated instance, rather than having Class::MOP</span>
<span class="synperlPOD">generate it for you. This is mostly useful for using Class::MOP with</span>
<span class="synperlPOD">foreign classes which generate instances using their own constructors.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;instance_metaclass &gt;&gt;</span>

<span class="synperlPOD">Returns the class name of the instance metaclass. See</span>
<span class="synIdentifier">L&lt;Class::MOP::Instance&gt;</span><span class="synperlPOD"> for more information on the instance</span>
<span class="synperlPOD">metaclass.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_meta_instance &gt;&gt;</span>

<span class="synperlPOD">Returns an instance of the </span><span class="synIdentifier">C&lt;instance_metaclass&gt;</span><span class="synperlPOD"> to be used in the</span>
<span class="synperlPOD">construction of a new instance of the class.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Informational predicates</span>

<span class="synperlPOD">These are a few predicate methods for asking information about the</span>
<span class="synperlPOD">class itself.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_anon_class &gt;&gt;</span>

<span class="synperlPOD">This returns true if the class was created by calling C&lt;&lt;</span>
<span class="synperlPOD">Class::MOP::Class-&gt;create_anon_class &gt;&gt;.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_mutable &gt;&gt;</span>

<span class="synperlPOD">This returns true if the class is still mutable.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_immutable &gt;&gt;</span>

<span class="synperlPOD">This returns true if the class has been made immutable.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_pristine &gt;&gt;</span>

<span class="synperlPOD">A class is </span><span class="synIdentifier">I&lt;not&gt;</span><span class="synperlPOD"> pristine if it has non-inherited attributes or if it</span>
<span class="synperlPOD">has any generated methods.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Inheritance Relationships</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;superclasses(@superclasses) &gt;&gt;</span>

<span class="synperlPOD">This is a read-write accessor which represents the superclass</span>
<span class="synperlPOD">relationships of the metaclass's class.</span>

<span class="synperlPOD">This is basically sugar around getting and setting </span><span class="synIdentifier">C&lt;@ISA&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;class_precedence_list &gt;&gt;</span>

<span class="synperlPOD">This returns a list of all of the class's ancestor classes. The</span>
<span class="synperlPOD">classes are returned in method dispatch order.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;linearized_isa &gt;&gt;</span>

<span class="synperlPOD">This returns a list based on </span><span class="synIdentifier">C&lt;class_precedence_list&gt;</span><span class="synperlPOD"> but with all</span>
<span class="synperlPOD">duplicates removed.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;subclasses &gt;&gt;</span>

<span class="synperlPOD">This returns a list of all subclasses for this class, even indirect</span>
<span class="synperlPOD">subclasses.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;direct_subclasses &gt;&gt;</span>

<span class="synperlPOD">This returns a list of immediate subclasses for this class, which does not</span>
<span class="synperlPOD">include indirect subclasses.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Method introspection and creation</span>

<span class="synperlPOD">These methods allow you to introspect a class's methods, as well as</span>
<span class="synperlPOD">add, remove, or change methods.</span>

<span class="synperlPOD">Determining what is truly a method in a Perl 5 class requires some</span>
<span class="synperlPOD">heuristics (aka guessing).</span>

<span class="synperlPOD">Methods defined outside the package with a fully qualified name (C&lt;sub</span>
<span class="synperlPOD">Package::name { ... }&gt;) will be included. Similarly, methods named</span>
<span class="synperlPOD">with a fully qualified name using </span><span class="synIdentifier">L&lt;Sub::Name&gt;</span><span class="synperlPOD"> are also included.</span>

<span class="synperlPOD">However, we attempt to ignore imported functions.</span>

<span class="synperlPOD">Ultimately, we are using heuristics to determine what truly is a</span>
<span class="synperlPOD">method in a class, and these heuristics may get the wrong answer in</span>
<span class="synperlPOD">some edge cases. However, for most &quot;normal&quot; cases the heuristics work</span>
<span class="synperlPOD">correctly.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_method($method_name) &gt;&gt;</span>

<span class="synperlPOD">This will return a </span><span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> for the specified</span>
<span class="synIdentifier">C&lt;$method_name&gt;</span><span class="synperlPOD">. If the class does not have the specified method, it</span>
<span class="synperlPOD">returns </span><span class="synIdentifier">C&lt;undef&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;has_method($method_name) &gt;&gt;</span>

<span class="synperlPOD">Returns a boolean indicating whether or not the class defines the</span>
<span class="synperlPOD">named method. It does not include methods inherited from parent</span>
<span class="synperlPOD">classes.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_method_list &gt;&gt;</span>

<span class="synperlPOD">This will return a list of method </span><span class="synIdentifier">I&lt;names&gt;</span><span class="synperlPOD"> for all methods defined in</span>
<span class="synperlPOD">this class.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_method($method_name, $method) &gt;&gt;</span>

<span class="synperlPOD">This method takes a method name and a subroutine reference, and adds</span>
<span class="synperlPOD">the method to the class.</span>

<span class="synperlPOD">The subroutine reference can be a </span><span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD">, and you are</span>
<span class="synperlPOD">strongly encouraged to pass a meta method object instead of a code</span>
<span class="synperlPOD">reference. If you do so, that object gets stored as part of the</span>
<span class="synperlPOD">class's method map directly. If not, the meta information will have to</span>
<span class="synperlPOD">be recreated later, and may be incorrect.</span>

<span class="synperlPOD">If you provide a method object, this method will clone that object if</span>
<span class="synperlPOD">the object's package name does not match the class name. This lets us</span>
<span class="synperlPOD">track the original source of any methods added from other classes</span>
<span class="synperlPOD">(notably Moose roles).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;remove_method($method_name) &gt;&gt;</span>

<span class="synperlPOD">Remove the named method from the class. This method returns the</span>
<span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> object for the method.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;method_metaclass &gt;&gt;</span>

<span class="synperlPOD">Returns the class name of the method metaclass, see</span>
<span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> for more information on the method metaclass.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;wrapped_method_metaclass &gt;&gt;</span>

<span class="synperlPOD">Returns the class name of the wrapped method metaclass, see</span>
<span class="synIdentifier">L&lt;Class::MOP::Method::Wrapped&gt;</span><span class="synperlPOD"> for more information on the wrapped</span>
<span class="synperlPOD">method metaclass.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_methods &gt;&gt;</span>

<span class="synperlPOD">This will traverse the inheritance hierarchy and return a list of all</span>
<span class="synperlPOD">the </span><span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> objects for this class and its parents.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_method_by_name($method_name) &gt;&gt;</span>

<span class="synperlPOD">This will return a </span><span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> for the specified</span>
<span class="synIdentifier">C&lt;$method_name&gt;</span><span class="synperlPOD">. If the class does not have the specified method, it</span>
<span class="synperlPOD">returns </span><span class="synIdentifier">C&lt;undef&gt;</span>

<span class="synperlPOD">Unlike </span><span class="synIdentifier">C&lt;get_method&gt;</span><span class="synperlPOD">, this method </span><span class="synIdentifier">I&lt;will&gt;</span><span class="synperlPOD"> look for the named method in</span>
<span class="synperlPOD">superclasses.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_method_names &gt;&gt;</span>

<span class="synperlPOD">This will return a list of method </span><span class="synIdentifier">I&lt;names&gt;</span><span class="synperlPOD"> for all of this class's</span>
<span class="synperlPOD">methods, including inherited methods.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_all_methods_by_name($method_name) &gt;&gt;</span>

<span class="synperlPOD">This method looks for the named method in the class and all of its</span>
<span class="synperlPOD">parents. It returns every matching method it finds in the inheritance</span>
<span class="synperlPOD">tree, so it returns a list of methods.</span>

<span class="synperlPOD">Each method is returned as a hash reference with three keys. The keys</span>
<span class="synperlPOD">are </span><span class="synIdentifier">C&lt;name&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">C&lt;class&gt;</span><span class="synperlPOD">, and </span><span class="synIdentifier">C&lt;code&gt;</span><span class="synperlPOD">. The </span><span class="synIdentifier">C&lt;code&gt;</span><span class="synperlPOD"> key has a</span>
<span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> object as its value.</span>

<span class="synperlPOD">The list of methods is distinct.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_next_method_by_name($method_name) &gt;&gt;</span>

<span class="synperlPOD">This method returns the first method in any superclass matching the</span>
<span class="synperlPOD">given name. It is effectively the method that </span><span class="synIdentifier">C&lt;SUPER::$method_name&gt;</span>
<span class="synperlPOD">would dispatch to.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Attribute introspection and creation</span>

<span class="synperlPOD">Because Perl 5 does not have a core concept of attributes in classes,</span>
<span class="synperlPOD">we can only return information about attributes which have been added</span>
<span class="synperlPOD">via this class's methods. We cannot discover information about</span>
<span class="synperlPOD">attributes which are defined in terms of &quot;regular&quot; Perl 5 methods.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_attribute($attribute_name) &gt;&gt;</span>

<span class="synperlPOD">This will return a </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD"> for the specified</span>
<span class="synIdentifier">C&lt;$attribute_name&gt;</span><span class="synperlPOD">. If the class does not have the specified</span>
<span class="synperlPOD">attribute, it returns </span><span class="synIdentifier">C&lt;undef&gt;</span><span class="synperlPOD">.</span>

<span class="synTodo">NOTE</span><span class="synperlPOD"> that get_attribute does not search superclasses, for that you</span>
<span class="synperlPOD">need to use </span><span class="synIdentifier">C&lt;find_attribute_by_name&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;has_attribute($attribute_name) &gt;&gt;</span>

<span class="synperlPOD">Returns a boolean indicating whether or not the class defines the</span>
<span class="synperlPOD">named attribute. It does not include attributes inherited from parent</span>
<span class="synperlPOD">classes.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_attribute_list &gt;&gt;</span>

<span class="synperlPOD">This will return a list of attributes </span><span class="synIdentifier">I&lt;names&gt;</span><span class="synperlPOD"> for all attributes</span>
<span class="synperlPOD">defined in this class.  Note that this operates on the current class</span>
<span class="synperlPOD">only, it does not traverse the inheritance hierarchy.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_attributes &gt;&gt;</span>

<span class="synperlPOD">This will traverse the inheritance hierarchy and return a list of all</span>
<span class="synperlPOD">the </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD"> objects for this class and its parents.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;find_attribute_by_name($attribute_name) &gt;&gt;</span>

<span class="synperlPOD">This will return a </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD"> for the specified</span>
<span class="synIdentifier">C&lt;$attribute_name&gt;</span><span class="synperlPOD">. If the class does not have the specified</span>
<span class="synperlPOD">attribute, it returns </span><span class="synIdentifier">C&lt;undef&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Unlike </span><span class="synIdentifier">C&lt;get_attribute&gt;</span><span class="synperlPOD">, this attribute </span><span class="synIdentifier">I&lt;will&gt;</span><span class="synperlPOD"> look for the named</span>
<span class="synperlPOD">attribute in superclasses.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_attribute(...) &gt;&gt;</span>

<span class="synperlPOD">This method accepts either an existing </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span>
<span class="synperlPOD">object or parameters suitable for passing to that class's </span><span class="synIdentifier">C&lt;new&gt;</span>
<span class="synperlPOD">method.</span>

<span class="synperlPOD">The attribute provided will be added to the class.</span>

<span class="synperlPOD">Any accessor methods defined by the attribute will be added to the</span>
<span class="synperlPOD">class when the attribute is added.</span>

<span class="synperlPOD">If an attribute of the same name already exists, the old attribute</span>
<span class="synperlPOD">will be removed first.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;remove_attribute($attribute_name) &gt;&gt;</span>

<span class="synperlPOD">This will remove the named attribute from the class, and</span>
<span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD"> object.</span>

<span class="synperlPOD">Removing an attribute also removes any accessor methods defined by the</span>
<span class="synperlPOD">attribute.</span>

<span class="synperlPOD">However, note that removing an attribute will only affect </span><span class="synIdentifier">I&lt;future&gt;</span>
<span class="synperlPOD">object instances created for this class, not existing instances.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;attribute_metaclass &gt;&gt;</span>

<span class="synperlPOD">Returns the class name of the attribute metaclass for this class. By</span>
<span class="synperlPOD">default, this is </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Overload introspection and creation</span>

<span class="synperlPOD">These methods provide an API to the core </span><span class="synIdentifier">L&lt;overload&gt;</span><span class="synperlPOD"> functionality.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;is_overloaded &gt;&gt;</span>

<span class="synperlPOD">Returns true if overloading is enabled for this class. Corresponds to</span>
<span class="synIdentifier">L&lt;overload::Overloaded|overload/Public Functions&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_overloaded_operator($op) &gt;&gt;</span>

<span class="synperlPOD">Returns the </span><span class="synIdentifier">L&lt;Class::MOP::Method::Overload&gt;</span><span class="synperlPOD"> object corresponding to the</span>
<span class="synperlPOD">operator named </span><span class="synIdentifier">C&lt;$op&gt;</span><span class="synperlPOD">, if one exists for this class.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;has_overloaded_operator($op) &gt;&gt;</span>

<span class="synperlPOD">Returns whether or not the operator </span><span class="synIdentifier">C&lt;$op&gt;</span><span class="synperlPOD"> is overloaded for this class.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_overload_list &gt;&gt;</span>

<span class="synperlPOD">Returns a list of operator names which have been overloaded (see</span>
<span class="synIdentifier">L&lt;overload/Overloadable Operations&gt;</span><span class="synperlPOD"> for the list of valid operator names).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;get_all_overloaded_operators &gt;&gt;</span>

<span class="synperlPOD">Returns a list of </span><span class="synIdentifier">L&lt;Class::MOP::Method::Overload&gt;</span><span class="synperlPOD"> objects corresponding to the</span>
<span class="synperlPOD">operators that have been overloaded.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_overloaded_operator($op, $impl) &gt;&gt;</span>

<span class="synperlPOD">Overloads the operator </span><span class="synIdentifier">C&lt;$op&gt;</span><span class="synperlPOD"> for this class, with the implementation </span><span class="synIdentifier">C&lt;$impl&gt;</span><span class="synperlPOD">.</span>
<span class="synIdentifier">C&lt;$impl&gt;</span><span class="synperlPOD"> can be either a coderef or a method name. Corresponds to</span>
<span class="synIdentifier">C&lt;&lt; use overload $op =&gt; $impl; &gt;&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;remove_overloaded_operator($op) &gt;&gt;</span>

<span class="synperlPOD">Remove overloading for operator </span><span class="synIdentifier">C&lt;$op&gt;</span><span class="synperlPOD">. Corresponds to </span><span class="synIdentifier">C&lt;&lt; no overload $op; &gt;&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Class Immutability</span>

<span class="synperlPOD">Making a class immutable &quot;freezes&quot; the class definition. You can no</span>
<span class="synperlPOD">longer call methods which alter the class, such as adding or removing</span>
<span class="synperlPOD">methods or attributes.</span>

<span class="synperlPOD">Making a class immutable lets us optimize the class by inlining some</span>
<span class="synperlPOD">methods, and also allows us to optimize some methods on the metaclass</span>
<span class="synperlPOD">object itself.</span>

<span class="synperlPOD">After immutabilization, the metaclass object will cache most informational</span>
<span class="synperlPOD">methods that returns information about methods or attributes. Methods which</span>
<span class="synperlPOD">would alter the class, such as </span><span class="synIdentifier">C&lt;add_attribute&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;add_method&gt;</span><span class="synperlPOD">, will</span>
<span class="synperlPOD">throw an error on an immutable metaclass object.</span>

<span class="synperlPOD">The immutabilization system in </span><span class="synIdentifier">L&lt;Moose&gt;</span><span class="synperlPOD"> takes much greater advantage</span>
<span class="synperlPOD">of the inlining features than Class::MOP itself does.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;make_immutable(%options) &gt;&gt;</span>

<span class="synperlPOD">This method will create an immutable transformer and use it to make</span>
<span class="synperlPOD">the class and its metaclass object immutable, and returns true</span>
<span class="synperlPOD">(you should not rely on the details of this value apart from its truth).</span>

<span class="synperlPOD">This method accepts the following options:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">8</span>

<span class="synStatement">=item</span><span class="synString"> * inline_accessors</span>

<span class="synStatement">=item</span><span class="synString"> * inline_constructor</span>

<span class="synStatement">=item</span><span class="synString"> * inline_destructor</span>

<span class="synperlPOD">These are all booleans indicating whether the specified </span><span class="synIdentifier">method(s)</span>
<span class="synperlPOD">should be inlined.</span>

<span class="synperlPOD">By default, accessors and the constructor are inlined, but not the</span>
<span class="synperlPOD">destructor.</span>

<span class="synStatement">=item</span><span class="synString"> * immutable_trait</span>

<span class="synperlPOD">The name of a class which will be used as a parent class for the</span>
<span class="synperlPOD">metaclass object being made immutable. This &quot;trait&quot; implements the</span>
<span class="synperlPOD">post-immutability functionality of the metaclass (but not the</span>
<span class="synperlPOD">transformation itself).</span>

<span class="synperlPOD">This defaults to </span><span class="synIdentifier">L&lt;Class::MOP::Class::Immutable::Trait&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> * constructor_name</span>

<span class="synperlPOD">This is the constructor method name. This defaults to &quot;new&quot;.</span>

<span class="synStatement">=item</span><span class="synString"> * constructor_class</span>

<span class="synperlPOD">The name of the method metaclass for constructors. It will be used to</span>
<span class="synperlPOD">generate the inlined constructor. This defaults to</span>
<span class="synperlPOD">&quot;Class::MOP::Method::Constructor&quot;.</span>

<span class="synStatement">=item</span><span class="synString"> * replace_constructor</span>

<span class="synperlPOD">This is a boolean indicating whether an existing constructor should be</span>
<span class="synperlPOD">replaced when inlining a constructor. This defaults to false.</span>

<span class="synStatement">=item</span><span class="synString"> * destructor_class</span>

<span class="synperlPOD">The name of the method metaclass for destructors. It will be used to</span>
<span class="synperlPOD">generate the inlined destructor. This defaults to</span>
<span class="synperlPOD">&quot;Class::MOP::Method::Denstructor&quot;.</span>

<span class="synStatement">=item</span><span class="synString"> * replace_destructor</span>

<span class="synperlPOD">This is a boolean indicating whether an existing destructor should be</span>
<span class="synperlPOD">replaced when inlining a destructor. This defaults to false.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;immutable_options &gt;&gt;</span>

<span class="synperlPOD">Returns a hash of the options used when making the class immutable, including</span>
<span class="synperlPOD">both defaults and anything supplied by the user in the call to C&lt;&lt;</span>
<span class="synIdentifier">$metaclass</span><span class="synperlPOD">-&gt;make_immutable &gt;&gt;. This is useful if you need to temporarily make</span>
<span class="synperlPOD">a class mutable and then restore immutability as it was before.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;make_mutable &gt;&gt;</span>

<span class="synperlPOD">Calling this method reverse the immutabilization transformation.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Method Modifiers</span>

<span class="synperlPOD">Method modifiers are hooks which allow a method to be wrapped with</span>
<span class="synIdentifier">I&lt;before&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">I&lt;after&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">I&lt;around&gt;</span><span class="synperlPOD"> method modifiers. Every time a</span>
<span class="synperlPOD">method is called, its modifiers are also called.</span>

<span class="synperlPOD">A class can modify its own methods, as well as methods defined in</span>
<span class="synperlPOD">parent classes.</span>

<span class="synStatement">=head3</span><span class="synString"> How method modifiers work?</span>

<span class="synperlPOD">Method modifiers work by wrapping the original method and then</span>
<span class="synperlPOD">replacing it in the class's symbol table. The wrappers will handle</span>
<span class="synperlPOD">calling all the modifiers in the appropriate order and preserving the</span>
<span class="synperlPOD">calling context for the original method.</span>

<span class="synperlPOD">The return values of </span><span class="synIdentifier">C&lt;before&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;after&gt;</span><span class="synperlPOD"> modifiers are</span>
<span class="synperlPOD">ignored. This is because their purpose is </span><span class="synIdentifier">B&lt;not&gt;</span><span class="synperlPOD"> to filter the input</span>
<span class="synperlPOD">and output of the primary method (this is done with an </span><span class="synIdentifier">I&lt;around&gt;</span>
<span class="synperlPOD">modifier).</span>

<span class="synperlPOD">This may seem like an odd restriction to some, but doing this allows</span>
<span class="synperlPOD">for simple code to be added at the beginning or end of a method call</span>
<span class="synperlPOD">without altering the function of the wrapped method or placing any</span>
<span class="synperlPOD">extra responsibility on the code of the modifier.</span>

<span class="synperlPOD">Of course if you have more complex needs, you can use the </span><span class="synIdentifier">C&lt;around&gt;</span>
<span class="synperlPOD">modifier which allows you to change both the parameters passed to the</span>
<span class="synperlPOD">wrapped method, as well as its return value.</span>

<span class="synperlPOD">Before and around modifiers are called in last-defined-first-called</span>
<span class="synperlPOD">order, while after modifiers are called in first-defined-first-called</span>
<span class="synperlPOD">order. So the call tree might looks something like this:</span>

<span class="synPreProc">  before 2</span>
<span class="synPreProc">   before 1</span>
<span class="synPreProc">    around 2</span>
<span class="synPreProc">     around 1</span>
<span class="synPreProc">      primary</span>
<span class="synPreProc">     around 1</span>
<span class="synPreProc">    around 2</span>
<span class="synPreProc">   after 1</span>
<span class="synPreProc">  after 2</span>

<span class="synStatement">=head3</span><span class="synString"> What is the performance impact?</span>

<span class="synperlPOD">Of course there is a performance cost associated with method</span>
<span class="synperlPOD">modifiers, but we have made every effort to make that cost directly</span>
<span class="synperlPOD">proportional to the number of modifier features you use.</span>

<span class="synperlPOD">The wrapping method does its best to </span><span class="synIdentifier">B&lt;only&gt;</span><span class="synperlPOD"> do as much work as it</span>
<span class="synperlPOD">absolutely needs to. In order to do this we have moved some of the</span>
<span class="synperlPOD">performance costs to set-up time, where they are easier to amortize.</span>

<span class="synperlPOD">All this said, our benchmarks have indicated the following:</span>

<span class="synPreProc">  simple wrapper with no modifiers             100% slower</span>
<span class="synPreProc">  simple wrapper with simple before modifier   400% slower</span>
<span class="synPreProc">  simple wrapper with simple after modifier    450% slower</span>
<span class="synPreProc">  simple wrapper with simple around modifier   500-550% slower</span>
<span class="synPreProc">  simple wrapper with all 3 modifiers          1100% slower</span>

<span class="synperlPOD">These numbers may seem daunting, but you must remember, every feature</span>
<span class="synperlPOD">comes with some cost. To put things in perspective, just doing a</span>
<span class="synperlPOD">simple </span><span class="synIdentifier">C&lt;AUTOLOAD&gt;</span><span class="synperlPOD"> which does nothing but extract the name of the</span>
<span class="synperlPOD">method called and return it costs about 400% over a normal method</span>
<span class="synperlPOD">call.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_before_method_modifier($method_name, $code) &gt;&gt;</span>

<span class="synperlPOD">This wraps the specified method with the supplied subroutine</span>
<span class="synperlPOD">reference. The modifier will be called as a method itself, and will</span>
<span class="synperlPOD">receive the same arguments as are passed to the method.</span>

<span class="synperlPOD">When the modifier exits, the wrapped method will be called.</span>

<span class="synperlPOD">The return value of the modifier will be ignored.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_after_method_modifier($method_name, $code) &gt;&gt;</span>

<span class="synperlPOD">This wraps the specified method with the supplied subroutine</span>
<span class="synperlPOD">reference. The modifier will be called as a method itself, and will</span>
<span class="synperlPOD">receive the same arguments as are passed to the method.</span>

<span class="synperlPOD">When the wrapped methods exits, the modifier will be called.</span>

<span class="synperlPOD">The return value of the modifier will be ignored.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; $metaclass-&gt;add_around_method_modifier($method_name, $code) &gt;&gt;</span>

<span class="synperlPOD">This wraps the specified method with the supplied subroutine</span>
<span class="synperlPOD">reference.</span>

<span class="synperlPOD">The first argument passed to the modifier will be a subroutine</span>
<span class="synperlPOD">reference to the wrapped method. The second argument is the object,</span>
<span class="synperlPOD">and after that come any arguments passed when the method is called.</span>

<span class="synperlPOD">The around modifier can choose to call the original method, as well as</span>
<span class="synperlPOD">what arguments to pass if it does so.</span>

<span class="synperlPOD">The return value of the modifier is what will be seen by the caller.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Introspection</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;&lt; Class::MOP::Class-&gt;meta &gt;&gt;</span>

<span class="synperlPOD">This will return a </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> instance for this class.</span>

<span class="synperlPOD">It should also be noted that </span><span class="synIdentifier">L&lt;Class::MOP&gt;</span><span class="synperlPOD"> will actually bootstrap</span>
<span class="synperlPOD">this module by installing a number of attribute meta-objects into its</span>
<span class="synperlPOD">metaclass.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

<span class="synperlPOD">Moose is maintained by the Moose Cabal, along with the help of many contributors. See </span><span class="synIdentifier">L&lt;Moose/CABAL&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span><span class="synperlPOD"> for details.</span>

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

<span class="synperlPOD">This software is copyright (c) 2013 by Infinity Interactive, Inc..</span>

<span class="synperlPOD">This is free software; you can redistribute it and/or modify it under</span>
<span class="synperlPOD">the same terms as the Perl 5 programming language system itself.</span>

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
