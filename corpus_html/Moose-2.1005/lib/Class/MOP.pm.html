<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre>
<span class="synStatement">package</span><span class="synType"> Class::MOP</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Class::MOP::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}

<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;

<span class="synStatement">use </span><span class="synFloat">5.008</span>;

<span class="synStatement">use </span>MRO::Compat;

<span class="synStatement">use </span>Carp          <span class="synString">'confess'</span>;
<span class="synStatement">use </span>Class::Load <span class="synFloat">0.07</span> ();
<span class="synStatement">use </span>Scalar::Util  <span class="synString">'weaken'</span>, <span class="synString">'isweak'</span>, <span class="synString">'reftype'</span>, <span class="synString">'blessed'</span>;
<span class="synStatement">use </span>Data::OptList;
<span class="synStatement">use </span>Try::Tiny;

<span class="synStatement">use </span>Class::MOP::Mixin::AttributeCore;
<span class="synStatement">use </span>Class::MOP::Mixin::HasAttributes;
<span class="synStatement">use </span>Class::MOP::Mixin::HasMethods;
<span class="synStatement">use </span>Class::MOP::Class;
<span class="synStatement">use </span>Class::MOP::Attribute;
<span class="synStatement">use </span>Class::MOP::Method;

<span class="synPreProc">BEGIN </span>{
    *IS_RUNNING_ON_5_10 = (<span class="synIdentifier">$]</span> &lt; <span class="synFloat">5.009_005</span>)
        ? <span class="synKeyword">sub </span><span class="synType">() </span>{ <span class="synNumber">0</span> }
        : <span class="synKeyword">sub </span><span class="synType">() </span>{ <span class="synNumber">1</span> };

    <span class="synComment"># this is either part of core or set up appropriately by MRO::Compat</span>
    *check_package_cache_flag = \<span class="synIdentifier">&amp;</span><span class="synType">mro::</span><span class="synIdentifier">get_pkg_gen</span>;
}

XSLoader::load(
    <span class="synString">'Moose'</span>,
    <span class="synIdentifier">$</span><span class="synType">Class::</span><span class="synIdentifier">MOP::{</span><span class="synString">VERSION</span><span class="synIdentifier">}</span> ? <span class="synIdentifier">${</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$</span><span class="synType">Class::</span><span class="synIdentifier">MOP::{</span><span class="synString">VERSION</span><span class="synIdentifier">}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span> : ()
);

{
    <span class="synComment"># Metaclasses are singletons, so we cache them here.</span>
    <span class="synComment"># there is no need to worry about destruction though</span>
    <span class="synComment"># because they should die only when the program dies.</span>
    <span class="synComment"># After all, do package definitions even get reaped?</span>
    <span class="synComment"># Anonymous classes manage their own destruction.</span>
    <span class="synStatement">my</span> <span class="synIdentifier">%METAS</span>;

    <span class="synKeyword">sub </span><span class="synFunction">get_all_metaclasses         </span>{        <span class="synIdentifier">%METAS</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">get_all_metaclass_instances </span>{ <span class="synStatement">values</span> <span class="synIdentifier">%METAS</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">get_all_metaclass_names     </span>{ <span class="synStatement">keys</span>   <span class="synIdentifier">%METAS</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">get_metaclass_by_name       </span>{ <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>         }
    <span class="synKeyword">sub </span><span class="synFunction">store_metaclass_by_name     </span>{ <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span> = <span class="synIdentifier">$_[</span><span class="synNumber">1</span><span class="synIdentifier">]</span> }
    <span class="synKeyword">sub </span><span class="synFunction">weaken_metaclass            </span>{ weaken(<span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>) }
    <span class="synKeyword">sub </span><span class="synFunction">metaclass_is_weak           </span>{ isweak(<span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>) }
    <span class="synKeyword">sub </span><span class="synFunction">does_metaclass_exist        </span>{ <span class="synStatement">exists</span> <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span> &amp;&amp; <span class="synOperator">defined</span> <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span> }
    <span class="synKeyword">sub </span><span class="synFunction">remove_metaclass_by_name    </span>{ <span class="synStatement">delete</span> <span class="synIdentifier">$METAS{$_[</span><span class="synNumber">0</span><span class="synIdentifier">]}</span>; <span class="synStatement">return</span> }

    <span class="synComment"># This handles instances as well as class names</span>
    <span class="synKeyword">sub </span><span class="synFunction">class_of </span>{
        <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synOperator">defined</span> <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>;
        <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = blessed(<span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>) || <span class="synIdentifier">$_[</span><span class="synNumber">0</span><span class="synIdentifier">]</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$METAS{$class}</span>;
    }

    <span class="synComment"># </span><span class="synTodo">NOTE:</span>
    <span class="synComment"># We only cache metaclasses, meaning instances of</span>
    <span class="synComment"># Class::MOP::Class. We do not cache instance of</span>
    <span class="synComment"># Class::MOP::Package or Class::MOP::Module. Mostly</span>
    <span class="synComment"># because I don't yet see a good reason to do so.</span>
}

<span class="synKeyword">sub </span><span class="synFunction">load_class </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Class::Load::</span><span class="synIdentifier">load_class</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">load_first_existing_class </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Class::Load::</span><span class="synIdentifier">load_first_existing_class</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">is_class_loaded </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Class::Load::</span><span class="synIdentifier">is_class_loaded</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">_definition_context </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">%context</span>;
    <span class="synIdentifier">@context{</span><span class="synString">qw(package file line)</span><span class="synIdentifier">}</span> = <span class="synStatement">caller</span>(<span class="synNumber">1</span>);

    <span class="synStatement">return</span> (
        <span class="synString">definition_context</span> =&gt; \<span class="synIdentifier">%context</span>,
    );
}

<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## Setting up our environment ...</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## Class::MOP needs to have a few things in the global perl environment so</span>
<span class="synComment">## that it can operate effectively. Those things are done here.</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>

<span class="synComment"># ... nothing yet actually ;)</span>

<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## Bootstrapping</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>
<span class="synComment">## The code below here is to bootstrap our MOP with itself. This is also</span>
<span class="synComment">## sometimes called &quot;tying the knot&quot;. By doing this, we make it much easier</span>
<span class="synComment">## to extend the MOP through subclassing and such since now you can use the</span>
<span class="synComment">## MOP itself to extend itself.</span>
<span class="synComment">##</span>
<span class="synComment">## Yes, I know, that's weird and insane, but it's a good thing, trust me :)</span>
<span class="synComment">## ----------------------------------------------------------------------------</span>

<span class="synComment"># We need to add in the meta-attributes here so that</span>
<span class="synComment"># any subclass of Class::MOP::* will be able to</span>
<span class="synComment"># inherit them using _construct_instance</span>

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin::HasMethods</span>

Class::MOP::Mixin::HasMethods-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'_methods'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'_method_map'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasMethods::</span><span class="synIdentifier">_method_map</span>
        },
        <span class="synString">default</span> =&gt; <span class="synKeyword">sub </span>{ {} },
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasMethods-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'method_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'method_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasMethods::</span><span class="synIdentifier">method_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Method'</span>,
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasMethods-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'wrapped_method_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'wrapped_method_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasMethods::</span><span class="synIdentifier">wrapped_method_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Method::Wrapped'</span>,
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin::HasMethods</span>

Class::MOP::Mixin::HasAttributes-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attributes'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'_attribute_map'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasAttributes::</span><span class="synIdentifier">_attribute_map</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ {} },
        _definition_context(),
    ))
);

Class::MOP::Mixin::HasAttributes-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attribute_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'attribute_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::HasAttributes::</span><span class="synIdentifier">attribute_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Attribute'</span>,
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Package</span>

Class::MOP::Package-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'package'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Package::</span><span class="synIdentifier">name</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Package-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'namespace'</span> =&gt; (
        <span class="synString">reader</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'namespace'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Package::</span><span class="synIdentifier">namespace</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Module</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># yeah this is kind of stretching things a bit,</span>
<span class="synComment"># but truthfully the version should be an attribute</span>
<span class="synComment"># of the Module, the weirdness comes from having to</span>
<span class="synComment"># stick to Perl 5 convention and store it in the</span>
<span class="synComment"># $VERSION package variable. Basically if you just</span>
<span class="synComment"># squint at it, it will look how you want it to look.</span>
<span class="synComment"># Either as a package variable, or as a attribute of</span>
<span class="synComment"># the metaclass, isn't abstraction great :)</span>

Class::MOP::Module-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'version'</span> =&gt; (
        <span class="synString">reader</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'version'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Module::</span><span class="synIdentifier">version</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># By following the same conventions as version here,</span>
<span class="synComment"># we are opening up the possibility that people can</span>
<span class="synComment"># use the $AUTHORITY in non-Class::MOP modules as</span>
<span class="synComment"># well.</span>

Class::MOP::Module-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'authority'</span> =&gt; (
        <span class="synString">reader</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'authority'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Module::</span><span class="synIdentifier">authority</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Class</span>

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'superclasses'</span> =&gt; (
        <span class="synString">accessor</span> =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'superclasses'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">superclasses</span>
        },
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ \<span class="synOperator">undef</span> },
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'instance_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'instance_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">instance_metaclass</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synString">'Class::MOP::Instance'</span>,
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'immutable_trait'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'immutable_trait'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">immutable_trait</span>
        },
        <span class="synString">default</span> =&gt; <span class="synString">&quot;Class::MOP::Class::Immutable::Trait&quot;</span>,
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'constructor_name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'constructor_name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">constructor_name</span>,
        },
        <span class="synString">default</span> =&gt; <span class="synString">&quot;new&quot;</span>,
        _definition_context(),
    ))
);

Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'constructor_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'constructor_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">constructor_class</span>,
        },
        <span class="synString">default</span> =&gt; <span class="synString">&quot;Class::MOP::Method::Constructor&quot;</span>,
        _definition_context(),
    ))
);


Class::MOP::Class-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'destructor_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'destructor_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Class::</span><span class="synIdentifier">destructor_class</span>,
        },
        _definition_context(),
    ))
);

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># we don't actually need to tie the knot with</span>
<span class="synComment"># Class::MOP::Class here, it is actually handled</span>
<span class="synComment"># within Class::MOP::Class itself in the</span>
<span class="synComment"># _construct_class_instance method.</span>

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin::AttributeCore</span>
Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">name</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'accessor'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'accessor'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">accessor</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_accessor'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_accessor</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'reader'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'reader'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">reader</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_reader'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_reader</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'initializer'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'initializer'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">initializer</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_initializer'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_initializer</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'definition_context'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'definition_context'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">definition_context</span>     },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'writer'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'writer'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">writer</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_writer'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_writer</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'predicate'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'predicate'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">predicate</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_predicate'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_predicate</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'clearer'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'clearer'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">clearer</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_clearer'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_clearer</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'builder'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'builder'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">builder</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_builder'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_builder</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'init_arg'</span> =&gt; (
        <span class="synString">reader</span>    =&gt; { <span class="synString">'init_arg'</span>     =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">init_arg</span>     },
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_init_arg'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_init_arg</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'default'</span> =&gt; (
        <span class="synComment"># default has a custom 'reader' method ...</span>
        <span class="synString">predicate</span> =&gt; { <span class="synString">'has_default'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_default</span> },
        _definition_context(),
    ))
);

Class::MOP::Mixin::AttributeCore-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'insertion_order'</span> =&gt; (
        <span class="synString">reader</span>      =&gt; { <span class="synString">'insertion_order'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">insertion_order</span> },
        <span class="synString">writer</span>      =&gt; { <span class="synString">'_set_insertion_order'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">_set_insertion_order</span> },
        <span class="synString">predicate</span>   =&gt; { <span class="synString">'has_insertion_order'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Mixin::AttributeCore::</span><span class="synIdentifier">has_insertion_order</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Attribute</span>
Class::MOP::Attribute-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we need to do this in order</span>
            <span class="synComment"># for the instance meta-object to</span>
            <span class="synComment"># not fall into meta-circular death</span>
            <span class="synComment">#</span>
            <span class="synComment"># we just alias the original method</span>
            <span class="synComment"># rather than re-produce it here</span>
            <span class="synString">'associated_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Attribute::</span><span class="synIdentifier">associated_class</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Attribute-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_methods'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'associated_methods'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Attribute::</span><span class="synIdentifier">associated_methods</span> },
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ [] },
        _definition_context(),
    ))
);

Class::MOP::Attribute-&gt;meta-&gt;add_method(<span class="synString">'clone'</span> =&gt; <span class="synKeyword">sub </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$self</span>  = <span class="synStatement">shift</span>;
    <span class="synIdentifier">$self-&gt;meta-&gt;clone_object</span>(<span class="synIdentifier">$self</span>, <span class="synIdentifier">@_</span>);
});

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method</span>
Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'body'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'body'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">body</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_metaclass'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'associated_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">associated_metaclass</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'package_name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'package_name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">package_name</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'name'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'name'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">name</span> },
        _definition_context(),
    ))
);

Class::MOP::Method-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'original_method'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'original_method'</span>      =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">original_method</span> },
        <span class="synString">writer</span>   =&gt; { <span class="synString">'_set_original_method'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::</span><span class="synIdentifier">_set_original_method</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Wrapped</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># the way this item is initialized, this</span>
<span class="synComment"># really does not follow the standard</span>
<span class="synComment"># practices of attributes, but we put</span>
<span class="synComment"># it here for completeness</span>
Class::MOP::Method::Wrapped-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'modifier_table'</span> =&gt; (
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Generated</span>

Class::MOP::Method::Generated-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'is_inline'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'is_inline'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Generated::</span><span class="synIdentifier">is_inline</span> },
        <span class="synString">default</span>  =&gt; <span class="synNumber">0</span>,
        _definition_context(),
    ))
);

Class::MOP::Method::Generated-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'definition_context'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'definition_context'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Generated::</span><span class="synIdentifier">definition_context</span> },
        _definition_context(),
    ))
);


<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Inlined</span>

Class::MOP::Method::Inlined-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'_expected_method_class'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'_expected_method_class'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Inlined::</span><span class="synIdentifier">_expected_method_class</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Accessor</span>

Class::MOP::Method::Accessor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attribute'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'associated_attribute'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Accessor::</span><span class="synIdentifier">associated_attribute</span>
        },
        _definition_context(),
    ))
);

Class::MOP::Method::Accessor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'accessor_type'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; { <span class="synString">'accessor_type'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Accessor::</span><span class="synIdentifier">accessor_type</span> },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Method::Constructor</span>

Class::MOP::Method::Constructor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'options'</span> =&gt; (
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'options'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Constructor::</span><span class="synIdentifier">options</span>
        },
        <span class="synString">default</span>  =&gt; <span class="synKeyword">sub </span>{ +{} },
        _definition_context(),
    ))
);

Class::MOP::Method::Constructor-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_metaclass'</span> =&gt; (
        <span class="synString">init_arg</span> =&gt; <span class="synString">&quot;metaclass&quot;</span>, <span class="synComment"># </span><span class="synTodo">FIXME</span><span class="synComment"> alias and rename</span>
        <span class="synString">reader</span>   =&gt; {
            <span class="synString">'associated_metaclass'</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Method::Constructor::</span><span class="synIdentifier">associated_metaclass</span>
        },
        _definition_context(),
    ))
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Instance</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span>
<span class="synComment"># these don't yet do much of anything, but are just</span>
<span class="synComment"># included for completeness</span>

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'associated_metaclass'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">associated_metaclass</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">associated_metaclass</span> },
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'_class_name'</span>,
        <span class="synString">init_arg</span> =&gt; <span class="synOperator">undef</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">_class_name</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">_class_name</span> },
        <span class="synComment">#lazy     =&gt; 1, # not yet supported by Class::MOP but out our version does it anyway</span>
        <span class="synComment">#default  =&gt; sub { $_[0]-&gt;associated_metaclass-&gt;name },</span>
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'attributes'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">attributes</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">get_all_attributes</span> },
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'slots'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">slots</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">slots</span> },
        _definition_context(),
    ),
);

Class::MOP::Instance-&gt;meta-&gt;add_attribute(
    Class::MOP::Attribute-&gt;new(<span class="synString">'slot_hash'</span>,
        <span class="synString">reader</span>   =&gt; { <span class="synString">slot_hash</span> =&gt; \<span class="synIdentifier">&amp;</span><span class="synType">Class::MOP::Instance::</span><span class="synIdentifier">slot_hash</span> },
        _definition_context(),
    ),
);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Object</span>

<span class="synComment"># need to replace the meta method there with a real meta method object</span>
Class::MOP::Object-&gt;meta-&gt;_add_meta_method(<span class="synString">'meta'</span>);

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Class::MOP::Mixin</span>

<span class="synComment"># need to replace the meta method there with a real meta method object</span>
Class::MOP::Mixin-&gt;meta-&gt;_add_meta_method(<span class="synString">'meta'</span>);

<span class="synStatement">require</span> Class::MOP::Deprecated <span class="synConditional">unless</span> <span class="synStatement">our</span> <span class="synIdentifier">$no_deprecated</span>;

<span class="synComment"># we need the meta instance of the meta instance to be created now, in order</span>
<span class="synComment"># for the constructor to be able to use it</span>
Class::MOP::Instance-&gt;meta-&gt;get_meta_instance;

<span class="synComment"># pretend the add_method never happened. it hasn't yet affected anything</span>
<span class="synOperator">undef</span> Class::MOP::Instance-&gt;meta-&gt;{_package_cache_flag};

<span class="synComment">## --------------------------------------------------------</span>
<span class="synComment">## Now close all the Class::MOP::* classes</span>

<span class="synComment"># </span><span class="synTodo">NOTE:</span><span class="synComment"> we don't need to inline the accessors this only lengthens the compile</span>
<span class="synComment"># time of the MOP, and gives us no actual benefits.</span>

<span class="synIdentifier">$_-&gt;meta-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">constructor_name</span>    =&gt; <span class="synString">&quot;_new&quot;</span>,
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">0</span>,
) <span class="synRepeat">for</span> <span class="synString">qw/</span>
<span class="synString">    Class::MOP::Package</span>
<span class="synString">    Class::MOP::Module</span>
<span class="synString">    Class::MOP::Class</span>

<span class="synString">    Class::MOP::Attribute</span>
<span class="synString">    Class::MOP::Method</span>
<span class="synString">    Class::MOP::Instance</span>

<span class="synString">    Class::MOP::Object</span>

<span class="synString">    Class::MOP::Method::Generated</span>
<span class="synString">    Class::MOP::Method::Inlined</span>

<span class="synString">    Class::MOP::Method::Accessor</span>
<span class="synString">    Class::MOP::Method::Constructor</span>
<span class="synString">    Class::MOP::Method::Wrapped</span>

<span class="synString">    Class::MOP::Method::Meta</span>
<span class="synString">    Class::MOP::Method::Overload</span>
<span class="synString">/</span>;

<span class="synIdentifier">$_-&gt;meta-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span>  =&gt; <span class="synNumber">0</span>,
    <span class="synString">constructor_name</span>    =&gt; <span class="synOperator">undef</span>,
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">0</span>,
) <span class="synRepeat">for</span> <span class="synString">qw/</span>
<span class="synString">    Class::MOP::Mixin</span>
<span class="synString">    Class::MOP::Mixin::AttributeCore</span>
<span class="synString">    Class::MOP::Mixin::HasAttributes</span>
<span class="synString">    Class::MOP::Mixin::HasMethods</span>
<span class="synString">/</span>;

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: A Meta Object Protocol for Perl 5</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Class::MOP - A Meta Object Protocol for Perl 5</span>

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

<span class="synperlPOD">version 2.1005</span>

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

<span class="synperlPOD">This module is a fully functioning meta object protocol for the</span>
<span class="synperlPOD">Perl 5 object system. It makes no attempt to change the behavior or</span>
<span class="synperlPOD">characteristics of the Perl 5 object system, only to create a</span>
<span class="synperlPOD">protocol for its manipulation and introspection.</span>

<span class="synperlPOD">That said, it does attempt to create the tools for building a rich set</span>
<span class="synperlPOD">of extensions to the Perl 5 object system. Every attempt has been made</span>
<span class="synperlPOD">to abide by the spirit of the Perl 5 object system that we all know</span>
<span class="synperlPOD">and love.</span>

<span class="synperlPOD">This documentation is sparse on conceptual details. We suggest looking</span>
<span class="synperlPOD">at the items listed in the </span><span class="synIdentifier">L&lt;SEE ALSO&gt;</span><span class="synperlPOD"> section for more</span>
<span class="synperlPOD">information. In particular the book &quot;The Art of the Meta Object</span>
<span class="synperlPOD">Protocol&quot; was very influential in the development of this system.</span>

<span class="synStatement">=head2</span><span class="synString"> What is a Meta Object Protocol?</span>

<span class="synperlPOD">A meta object protocol is an API to an object system.</span>

<span class="synperlPOD">To be more specific, it abstracts the components of an object system</span>
<span class="synperlPOD">(classes, object, methods, object attributes, etc.). These</span>
<span class="synperlPOD">abstractions can then be used to inspect and manipulate the object</span>
<span class="synperlPOD">system which they describe.</span>

<span class="synperlPOD">It can be said that there are two MOPs for any object system; the</span>
<span class="synperlPOD">implicit MOP and the explicit MOP. The implicit MOP handles things</span>
<span class="synperlPOD">like method dispatch or inheritance, which happen automatically as</span>
<span class="synperlPOD">part of how the object system works. The explicit MOP typically</span>
<span class="synperlPOD">handles the introspection/reflection features of the object system.</span>

<span class="synperlPOD">All object systems have implicit MOPs. Without one, they would not</span>
<span class="synperlPOD">work. Explicit MOPs are much less common, and depending on the</span>
<span class="synperlPOD">language can vary from restrictive (Reflection in Java or C#) to wide</span>
<span class="synperlPOD">open (CLOS is a perfect example).</span>

<span class="synStatement">=head2</span><span class="synString"> Yet Another Class Builder! Why?</span>

<span class="synperlPOD">This is </span><span class="synIdentifier">B&lt;not&gt;</span><span class="synperlPOD"> a class builder so much as a I&lt;class builder</span>
<span class="synIdentifier">B&lt;builder&gt;</span><span class="synperlPOD">&gt;. The intent is that an end user will not use this module</span>
<span class="synperlPOD">directly, but instead this module is used by module authors to build</span>
<span class="synperlPOD">extensions and features onto the Perl 5 object system.</span>

<span class="synperlPOD">This system is used by </span><span class="synIdentifier">L&lt;Moose&gt;</span><span class="synperlPOD">, which supplies a powerful class</span>
<span class="synperlPOD">builder system built entirely on top of </span><span class="synIdentifier">C&lt;Class::MOP&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head2</span><span class="synString"> Who is this module for?</span>

<span class="synperlPOD">This module is for anyone who has ever created or wanted to create a</span>
<span class="synperlPOD">module for the Class:: namespace. The tools which this module provides</span>
<span class="synperlPOD">make doing complex Perl 5 wizardry simpler, by removing such barriers</span>
<span class="synperlPOD">as the need to hack symbol tables, or understand the fine details of</span>
<span class="synperlPOD">method dispatch.</span>

<span class="synStatement">=head2</span><span class="synString"> What changes do I have to make to use this module?</span>

<span class="synperlPOD">This module was designed to be as unobtrusive as possible. Many of its</span>
<span class="synperlPOD">features are accessible without </span><span class="synIdentifier">B&lt;any&gt;</span><span class="synperlPOD"> change to your existing</span>
<span class="synperlPOD">code. It is meant to be a complement to your existing code and not an</span>
<span class="synperlPOD">intrusion on your code base. Unlike many other </span><span class="synIdentifier">B&lt;Class::&gt;</span><span class="synperlPOD"> modules,</span>
<span class="synperlPOD">this module </span><span class="synIdentifier">B&lt;does not&gt;</span><span class="synperlPOD"> require you subclass it, or even that you</span>
<span class="synIdentifier">C&lt;use&gt;</span><span class="synperlPOD"> it in within your module's package.</span>

<span class="synperlPOD">The only features which require additions to your code are the</span>
<span class="synperlPOD">attribute handling and instance construction features, and these are</span>
<span class="synperlPOD">both completely optional features. The only reason for this is because</span>
<span class="synperlPOD">Perl 5's object system does not actually have these features built</span>
<span class="synperlPOD">in. More information about this feature can be found below.</span>

<span class="synStatement">=head2</span><span class="synString"> About Performance</span>

<span class="synperlPOD">It is a common misconception that explicit MOPs are a performance hit.</span>
<span class="synperlPOD">This is not a universal truth, it is a side-effect of some specific</span>
<span class="synperlPOD">implementations. For instance, using Java reflection is slow because</span>
<span class="synperlPOD">the JVM cannot take advantage of any compiler optimizations, and the</span>
<span class="synperlPOD">JVM has to deal with much more runtime type information as well.</span>

<span class="synperlPOD">Reflection in C# is marginally better as it was designed into the</span>
<span class="synperlPOD">language and runtime (the CLR). In contrast, CLOS (the Common Lisp</span>
<span class="synperlPOD">Object System) was built to support an explicit MOP, and so</span>
<span class="synperlPOD">performance is tuned for it.</span>

<span class="synperlPOD">This library in particular does its absolute best to avoid putting</span>
<span class="synIdentifier">B&lt;any&gt;</span><span class="synperlPOD"> drain at all upon your code's performance. In fact, by itself</span>
<span class="synperlPOD">it does nothing to affect your existing code. So you only pay for what</span>
<span class="synperlPOD">you actually use.</span>

<span class="synStatement">=head2</span><span class="synString"> About Metaclass compatibility</span>

<span class="synperlPOD">This module makes sure that all metaclasses created are both upwards</span>
<span class="synperlPOD">and downwards compatible. The topic of metaclass compatibility is</span>
<span class="synperlPOD">highly esoteric and is something only encountered when doing deep and</span>
<span class="synperlPOD">involved metaclass hacking. There are two basic kinds of metaclass</span>
<span class="synperlPOD">incompatibility; upwards and downwards.</span>

<span class="synperlPOD">Upwards metaclass compatibility means that the metaclass of a</span>
<span class="synperlPOD">given class is either the same as (or a subclass of) all of the</span>
<span class="synperlPOD">class's ancestors.</span>

<span class="synperlPOD">Downward metaclass compatibility means that the metaclasses of a</span>
<span class="synperlPOD">given class's ancestors are all the same as (or a subclass of) that</span>
<span class="synperlPOD">metaclass.</span>

<span class="synperlPOD">Here is a diagram showing a set of two classes (</span><span class="synIdentifier">C&lt;A&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;B&gt;</span><span class="synperlPOD">) and</span>
<span class="synperlPOD">two metaclasses (</span><span class="synIdentifier">C&lt;Meta::A&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;Meta::B&gt;</span><span class="synperlPOD">) which have correct</span>
<span class="synperlPOD">metaclass compatibility both upwards and downwards.</span>

<span class="synPreProc">    +---------+     +---------+</span>
<span class="synPreProc">    | Meta::A |&lt;----| Meta::B |      &lt;....... (instance of  )</span>
<span class="synPreProc">    +---------+     +---------+      &lt;------- (inherits from)</span>
<span class="synPreProc">         ^               ^</span>
<span class="synPreProc">         :               :</span>
<span class="synPreProc">    +---------+     +---------+</span>
<span class="synPreProc">    |    A    |&lt;----|    B    |</span>
<span class="synPreProc">    +---------+     +---------+</span>

<span class="synperlPOD">In actuality, </span><span class="synIdentifier">I&lt;all&gt;</span><span class="synperlPOD"> of a class's metaclasses must be compatible,</span>
<span class="synperlPOD">not just the class metaclass. That includes the instance, attribute,</span>
<span class="synperlPOD">and method metaclasses, as well as the constructor and destructor</span>
<span class="synperlPOD">classes.</span>

<span class="synIdentifier">C&lt;Class::MOP&gt;</span><span class="synperlPOD"> will attempt to fix some simple types of</span>
<span class="synperlPOD">incompatibilities. If all the metaclasses for the parent class are</span>
<span class="synIdentifier">I&lt;subclasses&gt;</span><span class="synperlPOD"> of the child's metaclasses then we can simply replace</span>
<span class="synperlPOD">the child's metaclasses with the parent's. In addition, if the child</span>
<span class="synperlPOD">is missing a metaclass that the parent has, we can also just make the</span>
<span class="synperlPOD">child use the parent's metaclass.</span>

<span class="synperlPOD">As I said this is a highly esoteric topic and one you will only run</span>
<span class="synperlPOD">into if you do a lot of subclassing of </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD">. If you</span>
<span class="synperlPOD">are interested in why this is an issue see the paper I&lt;Uniform and</span>
<span class="synperlPOD">safe metaclass composition&gt; linked to in the </span><span class="synIdentifier">L&lt;SEE ALSO&gt;</span><span class="synperlPOD"> section of</span>
<span class="synperlPOD">this document.</span>

<span class="synStatement">=head2</span><span class="synString"> Using custom metaclasses</span>

<span class="synperlPOD">Always use the </span><span class="synIdentifier">L&lt;metaclass&gt;</span><span class="synperlPOD"> pragma when using a custom metaclass, this</span>
<span class="synperlPOD">will ensure the proper initialization order and not accidentally</span>
<span class="synperlPOD">create an incorrect type of metaclass for you. This is a very rare</span>
<span class="synperlPOD">problem, and one which can only occur if you are doing deep metaclass</span>
<span class="synperlPOD">programming. So in other words, don't worry about it.</span>

<span class="synperlPOD">Note that if you're using </span><span class="synIdentifier">L&lt;Moose&gt;</span><span class="synperlPOD"> we encourage you to </span><span class="synIdentifier">I&lt;not&gt;</span><span class="synperlPOD"> use the</span>
<span class="synIdentifier">L&lt;metaclass&gt;</span><span class="synperlPOD"> pragma, and instead use </span><span class="synIdentifier">L&lt;Moose::Util::MetaRole&gt;</span><span class="synperlPOD"> to apply</span>
<span class="synperlPOD">roles to a class's metaclasses. This topic is covered at length in</span>
<span class="synperlPOD">various </span><span class="synIdentifier">L&lt;Moose::Cookbook&gt;</span><span class="synperlPOD"> recipes.</span>

<span class="synStatement">=head1</span><span class="synString"> PROTOCOLS</span>

<span class="synperlPOD">The meta-object protocol is divided into 4 main sub-protocols:</span>

<span class="synStatement">=head2</span><span class="synString"> The Class protocol</span>

<span class="synperlPOD">This provides a means of manipulating and introspecting a Perl 5</span>
<span class="synperlPOD">class. It handles symbol table hacking for you, and provides a rich</span>
<span class="synperlPOD">set of methods that go beyond simple package introspection.</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> for more details.</span>

<span class="synStatement">=head2</span><span class="synString"> The Attribute protocol</span>

<span class="synperlPOD">This provides a consistent representation for an attribute of a Perl 5</span>
<span class="synperlPOD">class. Since there are so many ways to create and handle attributes in</span>
<span class="synperlPOD">Perl 5 OO, the Attribute protocol provide as much of a unified</span>
<span class="synperlPOD">approach as possible. Of course, you are always free to extend this</span>
<span class="synperlPOD">protocol by subclassing the appropriate classes.</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD"> for more details.</span>

<span class="synStatement">=head2</span><span class="synString"> The Method protocol</span>

<span class="synperlPOD">This provides a means of manipulating and introspecting methods in the</span>
<span class="synperlPOD">Perl 5 object system. As with attributes, there are many ways to</span>
<span class="synperlPOD">approach this topic, so we try to keep it pretty basic, while still</span>
<span class="synperlPOD">making it possible to extend the system in many ways.</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Class::MOP::Method&gt;</span><span class="synperlPOD"> for more details.</span>

<span class="synStatement">=head2</span><span class="synString"> The Instance protocol</span>

<span class="synperlPOD">This provides a layer of abstraction for creating object instances.</span>
<span class="synperlPOD">Since the other layers use this protocol, it is relatively easy to</span>
<span class="synperlPOD">change the type of your instances from the default hash reference to</span>
<span class="synperlPOD">some other type of reference. Several examples are provided in the</span>
<span class="synIdentifier">F&lt;examples/&gt;</span><span class="synperlPOD"> directory included in this distribution.</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Class::MOP::Instance&gt;</span><span class="synperlPOD"> for more details.</span>

<span class="synStatement">=head1</span><span class="synString"> FUNCTIONS</span>

<span class="synperlPOD">Note that this module does not export any constants or functions.</span>

<span class="synStatement">=head2</span><span class="synString"> Utility functions</span>

<span class="synperlPOD">Note that these are all called as </span><span class="synIdentifier">B&lt;functions, not methods&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_code_info($code)&gt;</span>

<span class="synperlPOD">This function returns two values, the name of the package the </span><span class="synIdentifier">C&lt;$code&gt;</span>
<span class="synperlPOD">is from and the name of the </span><span class="synIdentifier">C&lt;$code&gt;</span><span class="synperlPOD"> itself. This is used by several</span>
<span class="synperlPOD">elements of the MOP to determine where a given </span><span class="synIdentifier">C&lt;$code&gt;</span><span class="synperlPOD"> reference is</span>
<span class="synperlPOD">from.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::class_of($instance_or_class_name)&gt;</span>

<span class="synperlPOD">This will return the metaclass of the given instance or class name.  If the</span>
<span class="synperlPOD">class lacks a metaclass, no metaclass will be initialized, and </span><span class="synIdentifier">C&lt;undef&gt;</span><span class="synperlPOD"> will be</span>
<span class="synperlPOD">returned.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Metaclass cache functions</span>

<span class="synIdentifier">C&lt;Class::MOP&gt;</span><span class="synperlPOD"> holds a cache of metaclasses. The following are functions</span>
<span class="synperlPOD">(</span><span class="synIdentifier">B&lt;not methods&gt;</span><span class="synperlPOD">) which can be used to access that cache. It is not</span>
<span class="synperlPOD">recommended that you mess with these. Bad things could happen, but if</span>
<span class="synperlPOD">you are brave and willing to risk it: go for it!</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_all_metaclasses&gt;</span>

<span class="synperlPOD">This will return a hash of all the metaclass instances that have</span>
<span class="synperlPOD">been cached by </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD">, keyed by the package name.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_all_metaclass_instances&gt;</span>

<span class="synperlPOD">This will return a list of all the metaclass instances that have</span>
<span class="synperlPOD">been cached by </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_all_metaclass_names&gt;</span>

<span class="synperlPOD">This will return a list of all the metaclass names that have</span>
<span class="synperlPOD">been cached by </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::get_metaclass_by_name($name)&gt;</span>

<span class="synperlPOD">This will return a cached </span><span class="synIdentifier">L&lt;Class::MOP::Class&gt;</span><span class="synperlPOD"> instance, or nothing</span>
<span class="synperlPOD">if no metaclass exists with that </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::store_metaclass_by_name($name, $meta)&gt;</span>

<span class="synperlPOD">This will store a metaclass in the cache at the supplied </span><span class="synIdentifier">C&lt;$key&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::weaken_metaclass($name)&gt;</span>

<span class="synperlPOD">In rare cases (e.g. anonymous metaclasses) it is desirable to</span>
<span class="synperlPOD">store a weakened reference in the metaclass cache. This</span>
<span class="synperlPOD">function will weaken the reference to the metaclass stored</span>
<span class="synperlPOD">in </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::metaclass_is_weak($name)&gt;</span>

<span class="synperlPOD">Returns true if the metaclass for </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD"> has been weakened</span>
<span class="synperlPOD">(via </span><span class="synIdentifier">C&lt;weaken_metaclass&gt;</span><span class="synperlPOD">).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::does_metaclass_exist($name)&gt;</span>

<span class="synperlPOD">This will return true of there exists a metaclass stored in the</span>
<span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD"> key, and return false otherwise.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;Class::MOP::remove_metaclass_by_name($name)&gt;</span>

<span class="synperlPOD">This will remove the metaclass stored in the </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD"> key.</span>

<span class="synStatement">=back</span>

<span class="synperlPOD">Some utility functions (such as </span><span class="synIdentifier">C&lt;Class::MOP::load_class&gt;</span><span class="synperlPOD">) that were</span>
<span class="synperlPOD">previously defined in </span><span class="synIdentifier">C&lt;Class::MOP&gt;</span><span class="synperlPOD"> regarding loading of classes have been</span>
<span class="synperlPOD">extracted to </span><span class="synIdentifier">L&lt;Class::Load&gt;</span><span class="synperlPOD">. Please see </span><span class="synIdentifier">L&lt;Class::Load&gt;</span><span class="synperlPOD"> for documentation.</span>

<span class="synStatement">=head1</span><span class="synString"> SEE ALSO</span>

<span class="synStatement">=head2</span><span class="synString"> Books</span>

<span class="synperlPOD">There are very few books out on Meta Object Protocols and Metaclasses</span>
<span class="synperlPOD">because it is such an esoteric topic. The following books are really</span>
<span class="synperlPOD">the only ones I have found. If you know of any more, </span><span class="synIdentifier">B&lt;I&lt;please&gt;&gt;</span>
<span class="synperlPOD">email me and let me know, I would love to hear about them.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;The Art of the Meta Object Protocol&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;Advances in Object-Oriented Metalevel Architecture and Reflection&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;Putting MetaClasses to Work&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;Smalltalk: The Language&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Papers</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> &quot;Uniform and safe metaclass composition&quot;</span>

<span class="synperlPOD">An excellent paper by the people who brought us the original Traits paper.</span>
<span class="synperlPOD">This paper is on how Traits can be used to do safe metaclass composition,</span>
<span class="synperlPOD">and offers an excellent introduction section which delves into the topic of</span>
<span class="synperlPOD">metaclass compatibility.</span>

<span class="synIdentifier">L&lt;http://scg.unibe.ch/archive/papers/Duca05ySafeMetaclassTrait.pdf&gt;</span>

<span class="synStatement">=item</span><span class="synString"> &quot;Safe Metaclass Programming&quot;</span>

<span class="synperlPOD">This paper seems to precede the above paper, and propose a mix-in based</span>
<span class="synperlPOD">approach as opposed to the Traits based approach. Both papers have similar</span>
<span class="synperlPOD">information on the metaclass compatibility problem space.</span>

<span class="synIdentifier">L&lt;http://citeseer.ist.psu.edu/37617.html&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Prior Art</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> The Perl 6 MetaModel work in the Pugs project</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">L&lt;http://svn.openfoundry.org/pugs/misc/Perl-MetaModel/&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">L&lt;http://github.com/perl6/p5-modules/tree/master/Perl6-ObjectSpace/&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Articles</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> CPAN Module Review of Class::MOP</span>

<span class="synIdentifier">L&lt;http://www.oreillynet.com/onlamp/blog/2006/06/cpan_module_review_classmop.html&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> SIMILAR MODULES</span>

<span class="synperlPOD">As I have said above, this module is a class-builder-builder, so it is</span>
<span class="synperlPOD">not the same thing as modules like </span><span class="synIdentifier">L&lt;Class::Accessor&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">L&lt;Class::MethodMaker&gt;</span><span class="synperlPOD">. That being said there are very few modules on CPAN</span>
<span class="synperlPOD">with similar goals to this module. The one I have found which is most</span>
<span class="synperlPOD">like this module is </span><span class="synIdentifier">L&lt;Class::Meta&gt;</span><span class="synperlPOD">, although its philosophy and the MOP it</span>
<span class="synperlPOD">creates are very different from this modules.</span>

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

<span class="synperlPOD">All complex software has bugs lurking in it, and this module is no</span>
<span class="synperlPOD">exception.</span>

<span class="synperlPOD">Please report any bugs to </span><span class="synIdentifier">C&lt;bug-class-mop@rt.cpan.org&gt;</span><span class="synperlPOD">, or through the</span>
<span class="synperlPOD">web interface at </span><span class="synIdentifier">L&lt;http://rt.cpan.org&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">You can also discuss feature requests or possible bugs on the Moose</span>
<span class="synperlPOD">mailing list (moose</span><span class="synIdentifier">@perl</span><span class="synperlPOD">.org) or on IRC at</span>
<span class="synIdentifier">L&lt;irc://irc.perl.org/#moose&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head1</span><span class="synString"> ACKNOWLEDGEMENTS</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> Rob Kinyon</span>

<span class="synperlPOD">Thanks to Rob for actually getting the development of this module kick-started.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

<span class="synperlPOD">Moose is maintained by the Moose Cabal, along with the help of many contributors. See </span><span class="synIdentifier">L&lt;Moose/CABAL&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span><span class="synperlPOD"> for details.</span>

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

<span class="synperlPOD">This software is copyright (c) 2013 by Infinity Interactive, Inc..</span>

<span class="synperlPOD">This is free software; you can redistribute it and/or modify it under</span>
<span class="synperlPOD">the same terms as the Perl 5 programming language system itself.</span>

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
