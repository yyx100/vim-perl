<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
 <head>
  <title>[untitled]</title>
  <link rel="stylesheet" type="text/css" href="../../t/vim_syntax.css" />
 </head>
 <body>

<pre><span class="synStatement">package</span><span class="synType"> Moose</span>;
<span class="synPreProc">BEGIN </span>{
  <span class="synIdentifier">$</span><span class="synType">Moose::</span><span class="synIdentifier">AUTHORITY</span> = <span class="synString">'cpan:STEVAN'</span>;
}
{
  <span class="synIdentifier">$</span><span class="synType">Moose::</span><span class="synIdentifier">VERSION</span> = <span class="synString">'2.1005'</span>;
}
<span class="synStatement">use strict</span>;
<span class="synStatement">use warnings</span>;

<span class="synStatement">use </span><span class="synFloat">5.008</span>;

<span class="synStatement">use </span>Scalar::Util <span class="synString">'blessed'</span>;
<span class="synStatement">use </span>Carp         <span class="synString">'carp'</span>, <span class="synString">'confess'</span>;
<span class="synStatement">use </span>Class::Load  <span class="synString">'is_class_loaded'</span>;

<span class="synStatement">use </span>Moose::Deprecated;
<span class="synStatement">use </span>Moose::Exporter;

<span class="synStatement">use </span>Class::MOP;

<span class="synPreProc">BEGIN </span>{
    <span class="synStatement">die</span> <span class="synString">&quot;Class::MOP version </span><span class="synIdentifier">$</span><span class="synType">Moose::</span><span class="synIdentifier">VERSION</span><span class="synString"> required--this is version </span><span class="synIdentifier">$</span><span class="synType">Class::MOP::</span><span class="synIdentifier">VERSION</span><span class="synString">&quot;</span>
        <span class="synConditional">if</span> <span class="synIdentifier">$</span><span class="synType">Moose::</span><span class="synIdentifier">VERSION</span> &amp;&amp; <span class="synIdentifier">$</span><span class="synType">Class::MOP::</span><span class="synIdentifier">VERSION</span> <span class="synOperator">ne</span> <span class="synIdentifier">$</span><span class="synType">Moose::</span><span class="synIdentifier">VERSION</span>;
}

<span class="synStatement">use </span>Moose::Meta::Class;
<span class="synStatement">use </span>Moose::Meta::TypeConstraint;
<span class="synStatement">use </span>Moose::Meta::TypeCoercion;
<span class="synStatement">use </span>Moose::Meta::Attribute;
<span class="synStatement">use </span>Moose::Meta::Instance;

<span class="synStatement">use </span>Moose::Object;

<span class="synStatement">use </span>Moose::Meta::Role;
<span class="synStatement">use </span>Moose::Meta::Role::Composite;
<span class="synStatement">use </span>Moose::Meta::Role::Application;
<span class="synStatement">use </span>Moose::Meta::Role::Application::RoleSummation;
<span class="synStatement">use </span>Moose::Meta::Role::Application::ToClass;
<span class="synStatement">use </span>Moose::Meta::Role::Application::ToRole;
<span class="synStatement">use </span>Moose::Meta::Role::Application::ToInstance;

<span class="synStatement">use </span>Moose::Util::TypeConstraints;
<span class="synStatement">use </span>Moose::Util ();

<span class="synStatement">use </span>Moose::Meta::Attribute::Native;

<span class="synKeyword">sub </span><span class="synFunction">throw_error </span>{
    <span class="synComment"># </span><span class="synTodo">FIXME</span><span class="synComment"> This</span>
    <span class="synStatement">shift</span>;
    <span class="synStatement">goto</span> \<span class="synIdentifier">&amp;confess</span>
}

<span class="synKeyword">sub </span><span class="synFunction">extends </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synStatement">shift</span>;

    Moose-&gt;throw_error(<span class="synString">&quot;Must derive at least one class&quot;</span>) <span class="synConditional">unless</span> <span class="synIdentifier">@_</span>;

    <span class="synComment"># this checks the metaclass to make sure</span>
    <span class="synComment"># it is correct, sometimes it can get out</span>
    <span class="synComment"># of sync when the classes are being built</span>
    <span class="synIdentifier">$meta-&gt;superclasses</span>(<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">with </span>{
    Moose::Util::apply_all_roles(<span class="synStatement">shift</span>, <span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">has </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$name</span> = <span class="synStatement">shift</span>;

    Moose-&gt;throw_error(<span class="synString">'Usage: has \'name\' =&gt; ( key =&gt; value, ... )'</span>)
        <span class="synConditional">if</span> <span class="synIdentifier">@_</span> % <span class="synNumber">2</span> == <span class="synNumber">1</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">%context</span> = Moose::Util::_caller_info;
    <span class="synIdentifier">$context{</span><span class="synString">context</span><span class="synIdentifier">}</span> = <span class="synString">'has declaration'</span>;
    <span class="synIdentifier">$context{</span><span class="synString">type</span><span class="synIdentifier">}</span> = <span class="synString">'class'</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%options</span> = ( <span class="synString">definition_context</span> =&gt; \<span class="synIdentifier">%context</span>, <span class="synIdentifier">@_</span> );
    <span class="synStatement">my</span> <span class="synIdentifier">$attrs</span> = ( <span class="synOperator">ref</span>(<span class="synIdentifier">$name</span>) <span class="synOperator">eq</span> <span class="synString">'ARRAY'</span> ) ? <span class="synIdentifier">$name</span> : [ (<span class="synIdentifier">$name</span>) ];
    <span class="synIdentifier">$meta-&gt;add_attribute</span>( <span class="synIdentifier">$_</span>, <span class="synIdentifier">%options</span> ) <span class="synRepeat">for</span> <span class="synIdentifier">@$attrs</span>;
}

<span class="synKeyword">sub </span><span class="synFunction">before </span>{
    Moose::Util::add_method_modifier(<span class="synStatement">shift</span>, <span class="synString">'before'</span>, \<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">after </span>{
    Moose::Util::add_method_modifier(<span class="synStatement">shift</span>, <span class="synString">'after'</span>, \<span class="synIdentifier">@_</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">around </span>{
    Moose::Util::add_method_modifier(<span class="synStatement">shift</span>, <span class="synString">'around'</span>, \<span class="synIdentifier">@_</span>);
}

<span class="synStatement">our</span> <span class="synIdentifier">$SUPER_PACKAGE</span>;
<span class="synStatement">our</span> <span class="synIdentifier">$SUPER_BODY</span>;
<span class="synStatement">our</span> <span class="synIdentifier">@SUPER_ARGS</span>;

<span class="synKeyword">sub </span><span class="synFunction">super </span>{
    <span class="synConditional">if</span> (<span class="synIdentifier">@_</span>) {
        carp <span class="synString">'Arguments passed to super() are ignored'</span>;
    }

    <span class="synComment"># This check avoids a recursion loop - see</span>
    <span class="synComment"># t/bugs/super_recursion.t</span>
    <span class="synStatement">return</span> <span class="synConditional">if</span> <span class="synOperator">defined</span> <span class="synIdentifier">$SUPER_PACKAGE</span> &amp;&amp; <span class="synIdentifier">$SUPER_PACKAGE</span> <span class="synOperator">ne</span> <span class="synStatement">caller</span>();
    <span class="synStatement">return</span> <span class="synConditional">unless</span> <span class="synIdentifier">$SUPER_BODY</span>; <span class="synIdentifier">$SUPER_BODY</span>-&gt;(<span class="synIdentifier">@SUPER_ARGS</span>);
}

<span class="synKeyword">sub </span><span class="synFunction">override </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$name</span>, <span class="synIdentifier">$method</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synIdentifier">$meta-&gt;add_override_method_modifier</span>( <span class="synIdentifier">$name</span> =&gt; <span class="synIdentifier">$method</span> );
}

<span class="synKeyword">sub </span><span class="synFunction">inner </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$pkg</span> = <span class="synStatement">caller</span>();
    <span class="synStatement">our</span> ( <span class="synIdentifier">%INNER_BODY</span>, <span class="synIdentifier">%INNER_ARGS</span> );

    <span class="synConditional">if</span> ( <span class="synStatement">my</span> <span class="synIdentifier">$body</span> = <span class="synIdentifier">$INNER_BODY{$pkg}</span> ) {
        <span class="synStatement">my</span> <span class="synIdentifier">@args</span> = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> </span><span class="synIdentifier">$INNER_ARGS{$pkg}</span><span class="synperlVarBlock"> </span><span class="synIdentifier">}</span>;
        <span class="synStatement">local</span> <span class="synIdentifier">$INNER_ARGS{$pkg}</span>;
        <span class="synStatement">local</span> <span class="synIdentifier">$INNER_BODY{$pkg}</span>;
        <span class="synStatement">return</span> <span class="synIdentifier">$body</span>-&gt;(<span class="synIdentifier">@args</span>);
    } <span class="synConditional">else</span> {
        <span class="synStatement">return</span>;
    }
}

<span class="synKeyword">sub </span><span class="synFunction">augment </span>{
    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span> = <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> ( <span class="synIdentifier">$name</span>, <span class="synIdentifier">$method</span> ) = <span class="synIdentifier">@_</span>;
    <span class="synIdentifier">$meta-&gt;add_augment_method_modifier</span>( <span class="synIdentifier">$name</span> =&gt; <span class="synIdentifier">$method</span> );
}

Moose::Exporter-&gt;setup_import_methods(
    <span class="synString">with_meta</span> =&gt; [
        <span class="synString">qw( extends with has before after around override augment )</span>
    ],
    <span class="synString">as_is</span> =&gt; [
        <span class="synString">qw( super inner )</span>,
        \<span class="synIdentifier">&amp;</span><span class="synType">Carp::</span><span class="synIdentifier">confess</span>,
        \<span class="synIdentifier">&amp;</span><span class="synType">Scalar::Util::</span><span class="synIdentifier">blessed</span>,
    ],
);

<span class="synKeyword">sub </span><span class="synFunction">init_meta </span>{
    <span class="synStatement">shift</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">%args</span> = <span class="synIdentifier">@_</span>;

    <span class="synStatement">my</span> <span class="synIdentifier">$class</span> = <span class="synIdentifier">$args{</span><span class="synString">for_class</span><span class="synIdentifier">}</span>
        <span class="synOperator">or</span> Moose-&gt;throw_error(<span class="synString">&quot;Cannot call init_meta without specifying a for_class&quot;</span>);
    <span class="synStatement">my</span> <span class="synIdentifier">$base_class</span> = <span class="synIdentifier">$args{</span><span class="synString">base_class</span><span class="synIdentifier">}</span> || <span class="synString">'Moose::Object'</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$metaclass</span>  = <span class="synIdentifier">$args{</span><span class="synString">metaclass</span><span class="synIdentifier">}</span>  || <span class="synString">'Moose::Meta::Class'</span>;
    <span class="synStatement">my</span> <span class="synIdentifier">$meta_name</span>  = <span class="synStatement">exists</span> <span class="synIdentifier">$args{</span><span class="synString">meta_name</span><span class="synIdentifier">}</span> ? <span class="synIdentifier">$args{</span><span class="synString">meta_name</span><span class="synIdentifier">}</span> : <span class="synString">'meta'</span>;

    Moose-&gt;throw_error(<span class="synString">&quot;The Metaclass </span><span class="synIdentifier">$metaclass</span><span class="synString"> must be loaded. (Perhaps you forgot to 'use </span><span class="synIdentifier">$metaclass</span><span class="synString">'?)&quot;</span>)
        <span class="synConditional">unless</span> is_class_loaded(<span class="synIdentifier">$metaclass</span>);

    Moose-&gt;throw_error(<span class="synString">&quot;The Metaclass </span><span class="synIdentifier">$metaclass</span><span class="synString"> must be a subclass of Moose::Meta::Class.&quot;</span>)
        <span class="synConditional">unless</span> <span class="synIdentifier">$metaclass-&gt;isa</span>(<span class="synString">'Moose::Meta::Class'</span>);

    <span class="synComment"># make a subtype for each Moose class</span>
    class_type(<span class="synIdentifier">$class</span>)
        <span class="synConditional">unless</span> find_type_constraint(<span class="synIdentifier">$class</span>);

    <span class="synStatement">my</span> <span class="synIdentifier">$meta</span>;

    <span class="synConditional">if</span> ( <span class="synIdentifier">$meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$class</span>) ) {
        <span class="synConditional">unless</span> ( <span class="synIdentifier">$meta-&gt;isa</span>(<span class="synString">&quot;Moose::Meta::Class&quot;</span>) ) {
            <span class="synStatement">my</span> <span class="synIdentifier">$error_message</span> = <span class="synString">&quot;</span><span class="synIdentifier">$class</span><span class="synString"> already has a metaclass, but it does not inherit </span><span class="synIdentifier">$metaclass</span><span class="synString"> (</span><span class="synIdentifier">$meta</span><span class="synString">).&quot;</span>;
            <span class="synConditional">if</span> ( <span class="synIdentifier">$meta-&gt;isa</span>(<span class="synString">'Moose::Meta::Role'</span>) ) {
                Moose-&gt;throw_error(<span class="synIdentifier">$error_message</span> . <span class="synString">' You cannot make the same thing a role and a class. Remove either Moose or Moose::Role.'</span>);
            } <span class="synConditional">else</span> {
                Moose-&gt;throw_error(<span class="synIdentifier">$error_message</span>);
            }
        }
    } <span class="synConditional">else</span> {
        <span class="synComment"># no metaclass</span>

        <span class="synComment"># now we check whether our ancestors have metaclass, and if so borrow that</span>
        <span class="synStatement">my</span> ( <span class="synOperator">undef</span>, <span class="synIdentifier">@isa</span> ) = <span class="synIdentifier">@{</span><span class="synperlVarBlock"> mro::get_linear_isa(</span><span class="synIdentifier">$class</span><span class="synperlVarBlock">) </span><span class="synIdentifier">}</span>;

        <span class="synRepeat">foreach</span> <span class="synStatement">my</span> <span class="synIdentifier">$ancestor</span> ( <span class="synIdentifier">@isa</span> ) {
            <span class="synStatement">my</span> <span class="synIdentifier">$ancestor_meta</span> = Class::MOP::get_metaclass_by_name(<span class="synIdentifier">$ancestor</span>) || <span class="synStatement">next</span>;

            <span class="synStatement">my</span> <span class="synIdentifier">$ancestor_meta_class</span> = <span class="synIdentifier">$ancestor_meta-&gt;_real_ref_name</span>;

            <span class="synComment"># if we have an ancestor metaclass that inherits $metaclass, we use</span>
            <span class="synComment"># that. This is like _fix_metaclass_incompatibility, but we can do it now.</span>

            <span class="synComment"># the case of having an ancestry is not very common, but arises in</span>
            <span class="synComment"># e.g. Reaction</span>
            <span class="synConditional">unless</span> ( <span class="synIdentifier">$metaclass-&gt;isa</span>( <span class="synIdentifier">$ancestor_meta_class</span> ) ) {
                <span class="synConditional">if</span> ( <span class="synIdentifier">$ancestor_meta_class-&gt;isa</span>(<span class="synIdentifier">$metaclass</span>) ) {
                    <span class="synIdentifier">$metaclass</span> = <span class="synIdentifier">$ancestor_meta_class</span>;
                }
            }
        }

        <span class="synIdentifier">$meta</span> = <span class="synIdentifier">$metaclass-&gt;initialize</span>(<span class="synIdentifier">$class</span>);
    }

    <span class="synConditional">if</span> (<span class="synOperator">defined</span> <span class="synIdentifier">$meta_name</span>) {
        <span class="synComment"># also check for inherited non moose 'meta' method?</span>
        <span class="synStatement">my</span> <span class="synIdentifier">$existing</span> = <span class="synIdentifier">$meta-&gt;get_method</span>(<span class="synIdentifier">$meta_name</span>);
        <span class="synConditional">if</span> (<span class="synIdentifier">$existing</span> &amp;&amp; !<span class="synIdentifier">$existing-&gt;isa</span>(<span class="synString">'Class::MOP::Method::Meta'</span>)) {
            Carp::cluck <span class="synString">&quot;Moose is overwriting an existing method named &quot;</span>
                      . <span class="synString">&quot;</span><span class="synIdentifier">$meta_name</span><span class="synString"> in class </span><span class="synIdentifier">$class</span><span class="synString"> with a method &quot;</span>
                      . <span class="synString">&quot;which returns the class's metaclass. If this is &quot;</span>
                      . <span class="synString">&quot;actually what you want, you should remove the &quot;</span>
                      . <span class="synString">&quot;existing method, otherwise, you should rename or &quot;</span>
                      . <span class="synString">&quot;disable this generated method using the &quot;</span>
                      . <span class="synString">&quot;'-meta_name' option to 'use Moose'.&quot;</span>;
        }
        <span class="synIdentifier">$meta-&gt;_add_meta_method</span>(<span class="synIdentifier">$meta_name</span>);
    }

    <span class="synComment"># make sure they inherit from Moose::Object</span>
    <span class="synIdentifier">$meta-&gt;superclasses</span>(<span class="synIdentifier">$base_class</span>)
      <span class="synConditional">unless</span> <span class="synIdentifier">$meta-&gt;superclasses</span>();

    <span class="synStatement">return</span> <span class="synIdentifier">$meta</span>;
}

<span class="synComment"># This may be used in some older MooseX extensions.</span>
<span class="synKeyword">sub </span><span class="synFunction">_get_caller </span>{
    <span class="synStatement">goto</span> <span class="synIdentifier">&amp;</span><span class="synType">Moose::Exporter::</span><span class="synIdentifier">_get_caller</span>;
}

<span class="synComment">## make 'em all immutable</span>

<span class="synIdentifier">$_-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">1</span>,
    <span class="synString">constructor_name</span>   =&gt; <span class="synString">&quot;_new&quot;</span>,
    <span class="synComment"># these are Class::MOP accessors, so they need inlining</span>
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">1</span>
    ) <span class="synRepeat">for</span> <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;is_mutable</span> <span class="synStatement">}</span>
    <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;meta</span> <span class="synStatement">}</span>
    <span class="synString">qw(</span>
<span class="synString">    Moose::Meta::Attribute</span>
<span class="synString">    Moose::Meta::Class</span>
<span class="synString">    Moose::Meta::Instance</span>

<span class="synString">    Moose::Meta::TypeCoercion</span>
<span class="synString">    Moose::Meta::TypeCoercion::Union</span>

<span class="synString">    Moose::Meta::Method</span>
<span class="synString">    Moose::Meta::Method::Constructor</span>
<span class="synString">    Moose::Meta::Method::Destructor</span>
<span class="synString">    Moose::Meta::Method::Overridden</span>
<span class="synString">    Moose::Meta::Method::Augmented</span>

<span class="synString">    Moose::Meta::Role</span>
<span class="synString">    Moose::Meta::Role::Attribute</span>
<span class="synString">    Moose::Meta::Role::Method</span>
<span class="synString">    Moose::Meta::Role::Method::Required</span>
<span class="synString">    Moose::Meta::Role::Method::Conflicting</span>

<span class="synString">    Moose::Meta::Role::Composite</span>

<span class="synString">    Moose::Meta::Role::Application</span>
<span class="synString">    Moose::Meta::Role::Application::RoleSummation</span>
<span class="synString">    Moose::Meta::Role::Application::ToClass</span>
<span class="synString">    Moose::Meta::Role::Application::ToRole</span>
<span class="synString">    Moose::Meta::Role::Application::ToInstance</span>
<span class="synString">)</span>;

<span class="synIdentifier">$_-&gt;make_immutable</span>(
    <span class="synString">inline_constructor</span> =&gt; <span class="synNumber">0</span>,
    <span class="synString">constructor_name</span>   =&gt; <span class="synOperator">undef</span>,
    <span class="synComment"># these are Class::MOP accessors, so they need inlining</span>
    <span class="synString">inline_accessors</span> =&gt; <span class="synNumber">1</span>
    ) <span class="synRepeat">for</span> <span class="synStatement">grep</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;is_mutable</span> <span class="synStatement">}</span>
    <span class="synStatement">map</span> <span class="synStatement">{</span> <span class="synIdentifier">$_-&gt;meta</span> <span class="synStatement">}</span>
    <span class="synString">qw(</span>
<span class="synString">    Moose::Meta::Method::Accessor</span>
<span class="synString">    Moose::Meta::Method::Delegation</span>
<span class="synString">    Moose::Meta::Mixin::AttributeCore</span>
<span class="synString">)</span>;

<span class="synNumber">1</span>;

<span class="synComment"># ABSTRACT: A postmodern object system for Perl 5</span>

<span class="synComment">__END__</span>

<span class="synStatement">=pod</span>

<span class="synStatement">=head1</span><span class="synString"> NAME</span>

<span class="synperlPOD">Moose - A postmodern object system for Perl 5</span>

<span class="synStatement">=head1</span><span class="synString"> VERSION</span>

<span class="synperlPOD">version 2.1005</span>

<span class="synStatement">=head1</span><span class="synString"> SYNOPSIS</span>

<span class="synPreProc">  package Point;</span>
<span class="synPreProc">  use Moose; # automatically turns on strict and warnings</span>

<span class="synPreProc">  has 'x' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');</span>
<span class="synPreProc">  has 'y' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');</span>

<span class="synPreProc">  sub clear {</span>
<span class="synPreProc">      my $self = shift;</span>
<span class="synPreProc">      $self-&gt;x(0);</span>
<span class="synPreProc">      $self-&gt;y(0);</span>
<span class="synPreProc">  }</span>

<span class="synPreProc">  package Point3D;</span>
<span class="synPreProc">  use Moose;</span>

<span class="synPreProc">  extends 'Point';</span>

<span class="synPreProc">  has 'z' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');</span>

<span class="synPreProc">  after 'clear' =&gt; sub {</span>
<span class="synPreProc">      my $self = shift;</span>
<span class="synPreProc">      $self-&gt;z(0);</span>
<span class="synPreProc">  };</span>

<span class="synStatement">=head1</span><span class="synString"> DESCRIPTION</span>

<span class="synperlPOD">Moose is an extension of the Perl 5 object system.</span>

<span class="synperlPOD">The main goal of Moose is to make Perl 5 Object Oriented programming</span>
<span class="synperlPOD">easier, more consistent, and less tedious. With Moose you can think</span>
<span class="synperlPOD">more about what you want to do and less about the mechanics of OOP.</span>

<span class="synperlPOD">Additionally, Moose is built on top of </span><span class="synIdentifier">L&lt;Class::MOP&gt;</span><span class="synperlPOD">, which is a</span>
<span class="synperlPOD">metaclass system for Perl 5. This means that Moose not only makes</span>
<span class="synperlPOD">building normal Perl 5 objects better, but it provides the power of</span>
<span class="synperlPOD">metaclass programming as well.</span>

<span class="synStatement">=head2</span><span class="synString"> New to Moose?</span>

<span class="synperlPOD">If you're new to Moose, the best place to start is the</span>
<span class="synIdentifier">L&lt;Moose::Manual&gt;</span><span class="synperlPOD"> docs, followed by the </span><span class="synIdentifier">L&lt;Moose::Cookbook&gt;</span><span class="synperlPOD">. The intro</span>
<span class="synperlPOD">will show you what Moose is, and how it makes Perl 5 OO better.</span>

<span class="synperlPOD">The cookbook recipes on Moose basics will get you up to speed with</span>
<span class="synperlPOD">many of Moose's features quickly. Once you have an idea of what Moose</span>
<span class="synperlPOD">can do, you can use the API documentation to get more detail on</span>
<span class="synperlPOD">features which interest you.</span>

<span class="synStatement">=head2</span><span class="synString"> Moose Extensions</span>

<span class="synperlPOD">The </span><span class="synIdentifier">C&lt;MooseX::&gt;</span><span class="synperlPOD"> namespace is the official place to find Moose extensions.</span>
<span class="synperlPOD">These extensions can be found on the CPAN.  The easiest way to find them</span>
<span class="synperlPOD">is to search for them (</span><span class="synIdentifier">L&lt;http://search.cpan.org/search?query=MooseX::&gt;</span><span class="synperlPOD">),</span>
<span class="synperlPOD">or to examine </span><span class="synIdentifier">L&lt;Task::Moose&gt;</span><span class="synperlPOD"> which aims to keep an up-to-date, easily</span>
<span class="synperlPOD">installable list of Moose extensions.</span>

<span class="synStatement">=head1</span><span class="synString"> TRANSLATIONS</span>

<span class="synperlPOD">Much of the Moose documentation has been translated into other languages.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> Japanese</span>

<span class="synperlPOD">Japanese docs can be found at</span>
<span class="synIdentifier">L&lt;http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html&gt;</span><span class="synperlPOD">. The</span>
<span class="synperlPOD">source POD files can be found in GitHub:</span>
<span class="synIdentifier">L&lt;http://github.com/jpa/Moose-Doc-JA&gt;</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> BUILDING CLASSES WITH MOOSE</span>

<span class="synperlPOD">Moose makes every attempt to provide as much convenience as possible during</span>
<span class="synperlPOD">class construction/definition, but still stay out of your way if you want it</span>
<span class="synperlPOD">to. Here are a few items to note when building classes with Moose.</span>

<span class="synperlPOD">When you </span><span class="synIdentifier">C&lt;use Moose&gt;</span><span class="synperlPOD">, Moose will set the class's parent class to</span>
<span class="synIdentifier">L&lt;Moose::Object&gt;</span><span class="synperlPOD">, </span><span class="synIdentifier">I&lt;unless&gt;</span><span class="synperlPOD"> the class using Moose already has a parent</span>
<span class="synperlPOD">class. In addition, specifying a parent with </span><span class="synIdentifier">C&lt;extends&gt;</span><span class="synperlPOD"> will change the parent</span>
<span class="synperlPOD">class.</span>

<span class="synperlPOD">Moose will also manage all attributes (including inherited ones) that are</span>
<span class="synperlPOD">defined with </span><span class="synIdentifier">C&lt;has&gt;</span><span class="synperlPOD">. And (assuming you call </span><span class="synIdentifier">C&lt;new&gt;</span><span class="synperlPOD">, which is inherited from</span>
<span class="synIdentifier">L&lt;Moose::Object&gt;</span><span class="synperlPOD">) this includes properly initializing all instance slots,</span>
<span class="synperlPOD">setting defaults where appropriate, and performing any type constraint checking</span>
<span class="synperlPOD">or coercion.</span>

<span class="synStatement">=head1</span><span class="synString"> PROVIDED METHODS</span>

<span class="synperlPOD">Moose provides a number of methods to all your classes, mostly through the</span>
<span class="synperlPOD">inheritance of </span><span class="synIdentifier">L&lt;Moose::Object&gt;</span><span class="synperlPOD">. There is however, one exception.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;meta&gt;</span>

<span class="synperlPOD">This is a method which provides access to the current class's metaclass.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> EXPORTED FUNCTIONS</span>

<span class="synperlPOD">Moose will export a number of functions into the class's namespace which</span>
<span class="synperlPOD">may then be used to set up the class. These functions all work directly</span>
<span class="synperlPOD">on the current class.</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;extends (@superclasses)&gt;</span>

<span class="synperlPOD">This function will set the </span><span class="synIdentifier">superclass(es)</span><span class="synperlPOD"> for the current class. If the parent</span>
<span class="synperlPOD">classes are not yet loaded, then </span><span class="synIdentifier">C&lt;extends&gt;</span><span class="synperlPOD"> tries to load them.</span>

<span class="synperlPOD">This approach is recommended instead of </span><span class="synIdentifier">C&lt;use base&gt;</span><span class="synperlPOD">, because </span><span class="synIdentifier">C&lt;use base&gt;</span>
<span class="synperlPOD">actually </span><span class="synIdentifier">C&lt;push&gt;</span><span class="synperlPOD">es onto the class's </span><span class="synIdentifier">C&lt;@ISA&gt;</span><span class="synperlPOD">, whereas </span><span class="synIdentifier">C&lt;extends&gt;</span><span class="synperlPOD"> will</span>
<span class="synperlPOD">replace it. This is important to ensure that classes which do not have</span>
<span class="synperlPOD">superclasses still properly inherit from </span><span class="synIdentifier">L&lt;Moose::Object&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Each superclass can be followed by a hash reference with options. Currently,</span>
<span class="synperlPOD">only </span><span class="synIdentifier">L&lt;-version|Class::MOP/Class Loading Options&gt;</span><span class="synperlPOD"> is recognized:</span>

<span class="synPreProc">    extends 'My::Parent'      =&gt; { -version =&gt; 0.01 },</span>
<span class="synPreProc">            'My::OtherParent' =&gt; { -version =&gt; 0.03 };</span>

<span class="synperlPOD">An exception will be thrown if the version requirements are not</span>
<span class="synperlPOD">satisfied.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;with (@roles)&gt;</span>

<span class="synperlPOD">This will apply a given set of </span><span class="synIdentifier">C&lt;@roles&gt;</span><span class="synperlPOD"> to the local class.</span>

<span class="synperlPOD">Like with </span><span class="synIdentifier">C&lt;extends&gt;</span><span class="synperlPOD">, each specified role can be followed by a hash</span>
<span class="synperlPOD">reference with a </span><span class="synIdentifier">L&lt;-version|Class::MOP/Class Loading Options&gt;</span><span class="synperlPOD"> option:</span>

<span class="synPreProc">    with 'My::Role'      =&gt; { -version =&gt; 0.32 },</span>
<span class="synPreProc">         'My::Otherrole' =&gt; { -version =&gt; 0.23 };</span>

<span class="synperlPOD">The specified version requirements must be satisfied, otherwise an</span>
<span class="synperlPOD">exception will be thrown.</span>

<span class="synperlPOD">If your role takes options or arguments, they can be passed along in the</span>
<span class="synperlPOD">hash reference as well.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;has $name|@$names =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; %options&gt;</span>

<span class="synperlPOD">This will install an attribute of a given </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD"> into the current class. If</span>
<span class="synperlPOD">the first parameter is an array reference, it will create an attribute for</span>
<span class="synperlPOD">every </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD"> in the list. The </span><span class="synIdentifier">C&lt;%options&gt;</span><span class="synperlPOD"> will be passed to the constructor</span>
<span class="synperlPOD">for </span><span class="synIdentifier">L&lt;Moose::Meta::Attribute&gt;</span><span class="synperlPOD"> (which inherits from </span><span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD">),</span>
<span class="synperlPOD">so the full documentation for the valid options can be found there. These are</span>
<span class="synperlPOD">the most commonly used options:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;is =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; 'rw'|'ro'&gt;</span>

<span class="synperlPOD">The </span><span class="synIdentifier">I&lt;is&gt;</span><span class="synperlPOD"> option accepts either </span><span class="synIdentifier">I&lt;rw&gt;</span><span class="synperlPOD"> (for read/write) or </span><span class="synIdentifier">I&lt;ro&gt;</span><span class="synperlPOD"> (for read</span>
<span class="synperlPOD">only). These will create either a read/write accessor or a read-only</span>
<span class="synperlPOD">accessor respectively, using the same name as the </span><span class="synIdentifier">C&lt;$name&gt;</span><span class="synperlPOD"> of the attribute.</span>

<span class="synperlPOD">If you need more control over how your accessors are named, you can</span>
<span class="synperlPOD">use the </span><span class="synIdentifier">L&lt;reader|Class::MOP::Attribute/reader&gt;</span><span class="synperlPOD">,</span>
<span class="synIdentifier">L&lt;writer|Class::MOP::Attribute/writer&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">L&lt;accessor|Class::MOP::Attribute/accessor&gt;</span><span class="synperlPOD"> options inherited from</span>
<span class="synIdentifier">L&lt;Class::MOP::Attribute&gt;</span><span class="synperlPOD">, however if you use those, you won't need the</span>
<span class="synIdentifier">I&lt;is&gt;</span><span class="synperlPOD"> option.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;isa =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; $type_name&gt;</span>

<span class="synperlPOD">The </span><span class="synIdentifier">I&lt;isa&gt;</span><span class="synperlPOD"> option uses Moose's type constraint facilities to set up runtime</span>
<span class="synperlPOD">type checking for this attribute. Moose will perform the checks during class</span>
<span class="synperlPOD">construction, and within any accessors. The </span><span class="synIdentifier">C&lt;$type_name&gt;</span><span class="synperlPOD"> argument must be a</span>
<span class="synperlPOD">string. The string may be either a class name or a type defined using</span>
<span class="synperlPOD">Moose's type definition features. (Refer to </span><span class="synIdentifier">L&lt;Moose::Util::TypeConstraints&gt;</span>
<span class="synperlPOD">for information on how to define a new type, and how to retrieve type meta-data).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;coerce =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; (1|0)&gt;</span>

<span class="synperlPOD">This will attempt to use coercion with the supplied type constraint to change</span>
<span class="synperlPOD">the value passed into any accessors or constructors. You </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synperlPOD"> supply a type</span>
<span class="synperlPOD">constraint, and that type constraint </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synperlPOD"> define a coercion. See</span>
<span class="synIdentifier">L&lt;Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion&gt;</span><span class="synperlPOD"> for an example.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;does =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; $role_name&gt;</span>

<span class="synperlPOD">This will accept the name of a role which the value stored in this attribute</span>
<span class="synperlPOD">is expected to have consumed.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;required =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; (1|0)&gt;</span>

<span class="synperlPOD">This marks the attribute as being required. This means a value must be</span>
<span class="synperlPOD">supplied during class construction, </span><span class="synIdentifier">I&lt;or&gt;</span><span class="synperlPOD"> the attribute must be lazy</span>
<span class="synperlPOD">and have either a default or a builder. Note that c&lt;required&gt; does not</span>
<span class="synperlPOD">say anything about the attribute's value, which can be </span><span class="synIdentifier">C&lt;undef&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;weak_ref =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; (1|0)&gt;</span>

<span class="synperlPOD">This will tell the class to store the value of this attribute as a weakened</span>
<span class="synperlPOD">reference. If an attribute is a weakened reference, it </span><span class="synIdentifier">B&lt;cannot&gt;</span><span class="synperlPOD"> also be</span>
<span class="synperlPOD">coerced. Note that when a weak ref expires, the attribute's value becomes</span>
<span class="synperlPOD">undefined, and is still considered to be set for purposes of predicate,</span>
<span class="synperlPOD">default, etc.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;lazy =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; (1|0)&gt;</span>

<span class="synperlPOD">This will tell the class to not create this slot until absolutely necessary.</span>
<span class="synperlPOD">If an attribute is marked as lazy it </span><span class="synIdentifier">B&lt;must&gt;</span><span class="synperlPOD"> have a default or builder</span>
<span class="synperlPOD">supplied.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;trigger =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; $code&gt;</span>

<span class="synperlPOD">The </span><span class="synIdentifier">I&lt;trigger&gt;</span><span class="synperlPOD"> option is a CODE reference which will be called after</span>
<span class="synperlPOD">the value of the attribute is set. The CODE ref is passed the</span>
<span class="synperlPOD">instance itself, the updated value, and the original value if the</span>
<span class="synperlPOD">attribute was already set.</span>

<span class="synperlPOD">You </span><span class="synIdentifier">B&lt;can&gt;</span><span class="synperlPOD"> have a trigger on a read-only attribute.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> Triggers will only fire when you </span><span class="synIdentifier">B&lt;assign&gt;</span><span class="synperlPOD"> to the attribute,</span>
<span class="synperlPOD">either in the constructor, or using the writer. Default and built values will</span>
<span class="synIdentifier">B&lt;not&gt;</span><span class="synperlPOD"> cause the trigger to be fired.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;handles =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE&gt;</span>

<span class="synperlPOD">The </span><span class="synIdentifier">I&lt;handles&gt;</span><span class="synperlPOD"> option provides Moose classes with automated delegation features.</span>
<span class="synperlPOD">This is a pretty complex and powerful option. It accepts many different option</span>
<span class="synperlPOD">formats, each with its own benefits and drawbacks.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> The class being delegated to does not need to be a Moose based class,</span>
<span class="synperlPOD">which is why this feature is especially useful when wrapping non-Moose classes.</span>

<span class="synperlPOD">All </span><span class="synIdentifier">I&lt;handles&gt;</span><span class="synperlPOD"> option formats share the following traits:</span>

<span class="synperlPOD">You cannot override a locally defined method with a delegated method; an</span>
<span class="synperlPOD">exception will be thrown if you try. That is to say, if you define </span><span class="synIdentifier">C&lt;foo&gt;</span><span class="synperlPOD"> in</span>
<span class="synperlPOD">your class, you cannot override it with a delegated </span><span class="synIdentifier">C&lt;foo&gt;</span><span class="synperlPOD">. This is almost never</span>
<span class="synperlPOD">something you would want to do, and if it is, you should do it by hand and not</span>
<span class="synperlPOD">use Moose.</span>

<span class="synperlPOD">You cannot override any of the methods found in Moose::Object, or the </span><span class="synIdentifier">C&lt;BUILD&gt;</span>
<span class="synperlPOD">and </span><span class="synIdentifier">C&lt;DEMOLISH&gt;</span><span class="synperlPOD"> methods. These will not throw an exception, but will silently</span>
<span class="synperlPOD">move on to the next method in the list. My reasoning for this is that you would</span>
<span class="synperlPOD">almost never want to do this, since it usually breaks your class. As with</span>
<span class="synperlPOD">overriding locally defined methods, if you do want to do this, you should do it</span>
<span class="synperlPOD">manually, not with Moose.</span>

<span class="synperlPOD">You do not </span><span class="synIdentifier">I&lt;need&gt;</span><span class="synperlPOD"> to have a reader (or accessor) for the attribute in order</span>
<span class="synperlPOD">to delegate to it. Moose will create a means of accessing the value for you,</span>
<span class="synperlPOD">however this will be several times </span><span class="synIdentifier">B&lt;less&gt;</span><span class="synperlPOD"> efficient then if you had given</span>
<span class="synperlPOD">the attribute a reader (or accessor) to use.</span>

<span class="synperlPOD">Below is the documentation for each option format:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">C&lt;ARRAY&gt;</span>

<span class="synperlPOD">This is the most common usage for </span><span class="synIdentifier">I&lt;handles&gt;</span><span class="synperlPOD">. You basically pass a list of</span>
<span class="synperlPOD">method names to be delegated, and Moose will install a delegation method</span>
<span class="synperlPOD">for each one.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">C&lt;HASH&gt;</span>

<span class="synperlPOD">This is the second most common usage for </span><span class="synIdentifier">I&lt;handles&gt;</span><span class="synperlPOD">. Instead of a list of</span>
<span class="synperlPOD">method names, you pass a HASH ref where each key is the method name you</span>
<span class="synperlPOD">want installed locally, and its value is the name of the original method</span>
<span class="synperlPOD">in the class being delegated to.</span>

<span class="synperlPOD">This can be very useful for recursive classes like trees. Here is a</span>
<span class="synperlPOD">quick example (soon to be expanded into a Moose::Cookbook recipe):</span>

<span class="synPreProc">  package Tree;</span>
<span class="synPreProc">  use Moose;</span>

<span class="synPreProc">  has 'node' =&gt; (is =&gt; 'rw', isa =&gt; 'Any');</span>

<span class="synPreProc">  has 'children' =&gt; (</span>
<span class="synPreProc">      is      =&gt; 'ro',</span>
<span class="synPreProc">      isa     =&gt; 'ArrayRef',</span>
<span class="synPreProc">      default =&gt; sub { [] }</span>
<span class="synPreProc">  );</span>

<span class="synPreProc">  has 'parent' =&gt; (</span>
<span class="synPreProc">      is          =&gt; 'rw',</span>
<span class="synPreProc">      isa         =&gt; 'Tree',</span>
<span class="synPreProc">      weak_ref    =&gt; 1,</span>
<span class="synPreProc">      handles     =&gt; {</span>
<span class="synPreProc">          parent_node =&gt; 'node',</span>
<span class="synPreProc">          siblings    =&gt; 'children',</span>
<span class="synPreProc">      }</span>
<span class="synPreProc">  );</span>

<span class="synperlPOD">In this example, the Tree package gets </span><span class="synIdentifier">C&lt;parent_node&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;siblings&gt;</span><span class="synperlPOD"> methods,</span>
<span class="synperlPOD">which delegate to the </span><span class="synIdentifier">C&lt;node&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;children&gt;</span><span class="synperlPOD"> methods (respectively) of the Tree</span>
<span class="synperlPOD">instance stored in the </span><span class="synIdentifier">C&lt;parent&gt;</span><span class="synperlPOD"> slot.</span>

<span class="synperlPOD">You may also use an array reference to curry arguments to the original method.</span>

<span class="synPreProc">  has 'thing' =&gt; (</span>
<span class="synPreProc">      ...</span>
<span class="synPreProc">      handles =&gt; { set_foo =&gt; [ set =&gt; 'foo' ] },</span>
<span class="synPreProc">  );</span>

<span class="synPreProc">  # $self-&gt;set_foo(...) calls $self-&gt;thing-&gt;set('foo', ...)</span>

<span class="synperlPOD">The first element of the array reference is the original method name, and the</span>
<span class="synperlPOD">rest is a list of curried arguments.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">C&lt;REGEXP&gt;</span>

<span class="synperlPOD">The regexp option works very similar to the ARRAY option, except that it builds</span>
<span class="synperlPOD">the list of methods for you. It starts by collecting all possible methods of the</span>
<span class="synperlPOD">class being delegated to, then filters that list using the regexp supplied here.</span>

<span class="synIdentifier">B&lt;NOTE:&gt;</span><span class="synperlPOD"> An </span><span class="synIdentifier">I&lt;isa&gt;</span><span class="synperlPOD"> option is required when using the regexp option format. This</span>
<span class="synperlPOD">is so that we can determine (at compile time) the method list from the class.</span>
<span class="synperlPOD">Without an </span><span class="synIdentifier">I&lt;isa&gt;</span><span class="synperlPOD"> this is just not possible.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">C&lt;ROLE&gt;</span><span class="synString"> or </span><span class="synIdentifier">C&lt;ROLETYPE&gt;</span>

<span class="synperlPOD">With the role option, you specify the name of a role or a</span>
<span class="synIdentifier">L&lt;role type|Moose::Meta::TypeConstraint::Role&gt;</span><span class="synperlPOD"> whose &quot;interface&quot; then becomes</span>
<span class="synperlPOD">the list of methods to handle. The &quot;interface&quot; can be defined as; the methods</span>
<span class="synperlPOD">of the role and any required methods of the role. It should be noted that this</span>
<span class="synperlPOD">does </span><span class="synIdentifier">B&lt;not&gt;</span><span class="synperlPOD"> include any method modifiers or generated attribute methods (which</span>
<span class="synperlPOD">is consistent with role composition).</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">C&lt;DUCKTYPE&gt;</span>

<span class="synperlPOD">With the duck type option, you pass a duck type object whose &quot;interface&quot; then</span>
<span class="synperlPOD">becomes the list of methods to handle. The &quot;interface&quot; can be defined as the</span>
<span class="synperlPOD">list of methods passed to </span><span class="synIdentifier">C&lt;duck_type&gt;</span><span class="synperlPOD"> to create a duck type object. For more</span>
<span class="synperlPOD">information on </span><span class="synIdentifier">C&lt;duck_type&gt;</span><span class="synperlPOD"> please check</span>
<span class="synIdentifier">L&lt;Moose::Util::TypeConstraints&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">C&lt;CODE&gt;</span>

<span class="synperlPOD">This is the option to use when you really want to do something funky. You should</span>
<span class="synperlPOD">only use it if you really know what you are doing, as it involves manual</span>
<span class="synperlPOD">metaclass twiddling.</span>

<span class="synperlPOD">This takes a code reference, which should expect two arguments. The first is the</span>
<span class="synperlPOD">attribute meta-object this </span><span class="synIdentifier">I&lt;handles&gt;</span><span class="synperlPOD"> is attached to. The second is the</span>
<span class="synperlPOD">metaclass of the class being delegated to. It expects you to return a hash (not</span>
<span class="synperlPOD">a HASH ref) of the methods you want mapped.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;traits =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; [ @role_names ]&gt;</span>

<span class="synperlPOD">This tells Moose to take the list of </span><span class="synIdentifier">C&lt;@role_names&gt;</span><span class="synperlPOD"> and apply them to the</span>
<span class="synperlPOD">attribute meta-object. Custom attribute metaclass traits are useful for</span>
<span class="synperlPOD">extending the capabilities of the </span><span class="synIdentifier">I&lt;has&gt;</span><span class="synperlPOD"> keyword: they are the simplest way to</span>
<span class="synperlPOD">extend the MOP, but they are still a fairly advanced topic and too much to</span>
<span class="synperlPOD">cover here.</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;Metaclass and Trait Name Resolution&gt;</span><span class="synperlPOD"> for details on how a trait name is</span>
<span class="synperlPOD">resolved to a role name.</span>

<span class="synperlPOD">Also see </span><span class="synIdentifier">L&lt;Moose::Cookbook::Meta::Labeled_AttributeTrait&gt;</span><span class="synperlPOD"> for a metaclass</span>
<span class="synperlPOD">trait example.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;builder&gt;</span><span class="synString"> =&gt; Str</span>

<span class="synperlPOD">The value of this key is the name of the method that will be called to obtain</span>
<span class="synperlPOD">the value used to initialize the attribute. See the L&lt;builder option docs in</span>
<span class="synperlPOD">Class::MOP::Attribute|Class::MOP::Attribute/builder&gt; and/or</span>
<span class="synIdentifier">L&lt;Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild&gt;</span><span class="synperlPOD"> for more</span>
<span class="synperlPOD">information.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;default&gt;</span><span class="synString"> =&gt; SCALAR | CODE</span>

<span class="synperlPOD">The value of this key is the default value which will initialize the attribute.</span>

<span class="synTodo">NOTE:</span><span class="synperlPOD"> If the value is a simple scalar (string or number), then it can</span>
<span class="synperlPOD">be just passed as is.  However, if you wish to initialize it with a</span>
<span class="synperlPOD">HASH or ARRAY ref, then you need to wrap that inside a CODE reference.</span>
<span class="synperlPOD">See the L&lt;default option docs in</span>
<span class="synperlPOD">Class::MOP::Attribute|Class::MOP::Attribute/default&gt; for more</span>
<span class="synperlPOD">information.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;clearer&gt;</span><span class="synString"> =&gt; Str</span>

<span class="synperlPOD">Creates a method allowing you to clear the value. See the L&lt;clearer option</span>
<span class="synperlPOD">docs in Class::MOP::Attribute|Class::MOP::Attribute/clearer&gt; for more</span>
<span class="synperlPOD">information.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;predicate&gt;</span><span class="synString"> =&gt; Str</span>

<span class="synperlPOD">Creates a method to perform a basic test to see if a value has been set in the</span>
<span class="synperlPOD">attribute. See the L&lt;predicate option docs in</span>
<span class="synperlPOD">Class::MOP::Attribute|Class::MOP::Attribute/predicate&gt; for more information.</span>

<span class="synperlPOD">Note that the predicate will return true even for a </span><span class="synIdentifier">C&lt;weak_ref&gt;</span><span class="synperlPOD"> attribute</span>
<span class="synperlPOD">whose value has expired.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;documentation&gt;</span><span class="synString"> =&gt; $string</span>

<span class="synperlPOD">An arbitrary string that can be retrieved later by calling C&lt;&lt;</span>
<span class="synIdentifier">$attr</span><span class="synperlPOD">-&gt;documentation &gt;&gt;.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;has +$name =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; %options&gt;</span>

<span class="synperlPOD">This is variation on the normal attribute creator </span><span class="synIdentifier">C&lt;has&gt;</span><span class="synperlPOD"> which allows you to</span>
<span class="synperlPOD">clone and extend an attribute from a superclass or from a role. Here is an</span>
<span class="synperlPOD">example of the superclass usage:</span>

<span class="synPreProc">  package Foo;</span>
<span class="synPreProc">  use Moose;</span>

<span class="synPreProc">  has 'message' =&gt; (</span>
<span class="synPreProc">      is      =&gt; 'rw',</span>
<span class="synPreProc">      isa     =&gt; 'Str',</span>
<span class="synPreProc">      default =&gt; 'Hello, I am a Foo'</span>
<span class="synPreProc">  );</span>

<span class="synPreProc">  package My::Foo;</span>
<span class="synPreProc">  use Moose;</span>

<span class="synPreProc">  extends 'Foo';</span>

<span class="synPreProc">  has '+message' =&gt; (default =&gt; 'Hello I am My::Foo');</span>

<span class="synperlPOD">What is happening here is that </span><span class="synIdentifier">B&lt;My::Foo&gt;</span><span class="synperlPOD"> is cloning the </span><span class="synIdentifier">C&lt;message&gt;</span><span class="synperlPOD"> attribute</span>
<span class="synperlPOD">from its parent class </span><span class="synIdentifier">B&lt;Foo&gt;</span><span class="synperlPOD">, retaining the </span><span class="synIdentifier">C&lt;is =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; 'rw'&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;isa =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>
<span class="synperlPOD">'Str'&gt; characteristics, but changing the value in </span><span class="synIdentifier">C&lt;default&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Here is another example, but within the context of a role:</span>

<span class="synPreProc">  package Foo::Role;</span>
<span class="synPreProc">  use Moose::Role;</span>

<span class="synPreProc">  has 'message' =&gt; (</span>
<span class="synPreProc">      is      =&gt; 'rw',</span>
<span class="synPreProc">      isa     =&gt; 'Str',</span>
<span class="synPreProc">      default =&gt; 'Hello, I am a Foo'</span>
<span class="synPreProc">  );</span>

<span class="synPreProc">  package My::Foo;</span>
<span class="synPreProc">  use Moose;</span>

<span class="synPreProc">  with 'Foo::Role';</span>

<span class="synPreProc">  has '+message' =&gt; (default =&gt; 'Hello I am My::Foo');</span>

<span class="synperlPOD">In this case, we are basically taking the attribute which the role supplied</span>
<span class="synperlPOD">and altering it within the bounds of this feature.</span>

<span class="synperlPOD">Note that you can only extend an attribute from either a superclass or a role,</span>
<span class="synperlPOD">you cannot extend an attribute in a role that composes over an attribute from</span>
<span class="synperlPOD">another role.</span>

<span class="synperlPOD">Aside from where the attributes come from (one from superclass, the other</span>
<span class="synperlPOD">from a role), this feature works exactly the same. This feature is restricted</span>
<span class="synperlPOD">somewhat, so as to try and force at least </span><span class="synIdentifier">I&lt;some&gt;</span><span class="synperlPOD"> sanity into it. Most options work the same, but there are some exceptions:</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;reader&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;writer&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;accessor&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;clearer&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;predicate&gt;</span>

<span class="synperlPOD">These options can be added, but cannot override a superclass definition.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">I&lt;traits&gt;</span>

<span class="synperlPOD">You are allowed to </span><span class="synIdentifier">B&lt;add&gt;</span><span class="synperlPOD"> additional traits to the </span><span class="synIdentifier">C&lt;traits&gt;</span><span class="synperlPOD"> definition.</span>
<span class="synperlPOD">These traits will be composed into the attribute, but preexisting traits</span>
<span class="synIdentifier">B&lt;are not&gt;</span><span class="synperlPOD"> overridden, or removed.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;before $name|@names|\@names|qr/.../ =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; sub { ... }&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;after $name|@names|\@names|qr/.../ =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; sub { ... }&gt;</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;around $name|@names|\@names|qr/.../ =E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt; sub { ... }&gt;</span>

<span class="synperlPOD">These three items are syntactic sugar for the before, after, and around method</span>
<span class="synperlPOD">modifier features that </span><span class="synIdentifier">L&lt;Class::MOP&gt;</span><span class="synperlPOD"> provides. More information on these may be</span>
<span class="synperlPOD">found in </span><span class="synIdentifier">L&lt;Moose::Manual::MethodModifiers&gt;</span><span class="synperlPOD"> and the</span>
<span class="synIdentifier">L&lt;Class::MOP::Class documentation|Class::MOP::Class/&quot;Method Modifiers&quot;&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;override ($name, &amp;sub)&gt;</span>

<span class="synperlPOD">An </span><span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> method is a way of explicitly saying &quot;I am overriding this</span>
<span class="synperlPOD">method from my superclass&quot;. You can call </span><span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD"> within this method, and</span>
<span class="synperlPOD">it will work as expected. The same thing </span><span class="synIdentifier">I&lt;can&gt;</span><span class="synperlPOD"> be accomplished with a normal</span>
<span class="synperlPOD">method call and the </span><span class="synIdentifier">C&lt;SUPER::&gt;</span><span class="synperlPOD"> pseudo-package; it is really your choice.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;super&gt;</span>

<span class="synperlPOD">The keyword </span><span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD"> is a no-op when called outside of an </span><span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> method. In</span>
<span class="synperlPOD">the context of an </span><span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> method, it will call the next most appropriate</span>
<span class="synperlPOD">superclass method with the same arguments as the original method.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;augment ($name, &amp;sub)&gt;</span>

<span class="synperlPOD">An </span><span class="synIdentifier">C&lt;augment&gt;</span><span class="synperlPOD"> method, is a way of explicitly saying &quot;I am augmenting this</span>
<span class="synperlPOD">method from my superclass&quot;. Once again, the details of how </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">C&lt;augment&gt;</span><span class="synperlPOD"> work is best described in the</span>
<span class="synIdentifier">L&lt;Moose::Cookbook::Basics::Document_AugmentAndInner&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;inner&gt;</span>

<span class="synperlPOD">The keyword </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD">, much like </span><span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD">, is a no-op outside of the context of</span>
<span class="synperlPOD">an </span><span class="synIdentifier">C&lt;augment&gt;</span><span class="synperlPOD"> method. You can think of </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD"> as being the inverse of</span>
<span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD">; the details of how </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;augment&gt;</span><span class="synperlPOD"> work is best described in</span>
<span class="synperlPOD">the </span><span class="synIdentifier">L&lt;Moose::Cookbook::Basics::Document_AugmentAndInner&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;blessed&gt;</span>

<span class="synperlPOD">This is the </span><span class="synIdentifier">C&lt;Scalar::Util::blessed&gt;</span><span class="synperlPOD"> function. It is highly recommended that</span>
<span class="synperlPOD">this is used instead of </span><span class="synIdentifier">C&lt;ref&gt;</span><span class="synperlPOD"> anywhere you need to test for an object's class</span>
<span class="synperlPOD">name.</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">B&lt;confess&gt;</span>

<span class="synperlPOD">This is the </span><span class="synIdentifier">C&lt;Carp::confess&gt;</span><span class="synperlPOD"> function, and exported here for historical</span>
<span class="synperlPOD">reasons.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> METACLASS</span>

<span class="synperlPOD">When you use Moose, you can specify traits which will be applied to your</span>
<span class="synperlPOD">metaclass:</span>

<span class="synPreProc">    use Moose -traits =&gt; 'My::Trait';</span>

<span class="synperlPOD">This is very similar to the attribute traits feature. When you do</span>
<span class="synperlPOD">this, your class's </span><span class="synIdentifier">C&lt;meta&gt;</span><span class="synperlPOD"> object will have the specified traits</span>
<span class="synperlPOD">applied to it. See </span><span class="synIdentifier">L&lt;Metaclass and Trait Name Resolution&gt;</span><span class="synperlPOD"> for more</span>
<span class="synperlPOD">details.</span>

<span class="synStatement">=head2</span><span class="synString"> Metaclass and Trait Name Resolution</span>

<span class="synperlPOD">By default, when given a trait name, Moose simply tries to load a</span>
<span class="synperlPOD">class of the same name. If such a class does not exist, it then looks</span>
<span class="synperlPOD">for a class matching</span>
<span class="synIdentifier">B&lt;Moose::Meta::$type::Custom::Trait::$trait_name&gt;</span><span class="synperlPOD">. The </span><span class="synIdentifier">C&lt;$type&gt;</span>
<span class="synperlPOD">variable here will be one of </span><span class="synIdentifier">B&lt;Attribute&gt;</span><span class="synperlPOD"> or </span><span class="synIdentifier">B&lt;Class&gt;</span><span class="synperlPOD">, depending on</span>
<span class="synperlPOD">what the trait is being applied to.</span>

<span class="synperlPOD">If a class with this long name exists, Moose checks to see if it has</span>
<span class="synperlPOD">the method </span><span class="synIdentifier">C&lt;register_implementation&gt;</span><span class="synperlPOD">. This method is expected to</span>
<span class="synperlPOD">return the </span><span class="synIdentifier">I&lt;real&gt;</span><span class="synperlPOD"> class name of the trait. If there is no</span>
<span class="synIdentifier">C&lt;register_implementation&gt;</span><span class="synperlPOD"> method, it will fall back to using</span>
<span class="synIdentifier">B&lt;Moose::Meta::$type::Custom::Trait::$trait&gt;</span><span class="synperlPOD"> as the trait name.</span>

<span class="synperlPOD">The lookup method for metaclasses is the same, except that it looks</span>
<span class="synperlPOD">for a class matching </span><span class="synIdentifier">B&lt;Moose::Meta::$type::Custom::$metaclass_name&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">If all this is confusing, take a look at</span>
<span class="synIdentifier">L&lt;Moose::Cookbook::Meta::Labeled_AttributeTrait&gt;</span><span class="synperlPOD">, which demonstrates how to</span>
<span class="synperlPOD">create an attribute trait.</span>

<span class="synStatement">=head1</span><span class="synString"> UNIMPORTING FUNCTIONS</span>

<span class="synStatement">=head2</span><span class="synString"> </span><span class="synIdentifier">B&lt;unimport&gt;</span>

<span class="synperlPOD">Moose offers a way to remove the keywords it exports, through the </span><span class="synIdentifier">C&lt;unimport&gt;</span>
<span class="synperlPOD">method. You simply have to say </span><span class="synIdentifier">C&lt;no Moose&gt;</span><span class="synperlPOD"> at the bottom of your code for this</span>
<span class="synperlPOD">to work. Here is an example:</span>

<span class="synPreProc">    package Person;</span>
<span class="synPreProc">    use Moose;</span>

<span class="synPreProc">    has 'first_name' =&gt; (is =&gt; 'rw', isa =&gt; 'Str');</span>
<span class="synPreProc">    has 'last_name'  =&gt; (is =&gt; 'rw', isa =&gt; 'Str');</span>

<span class="synPreProc">    sub full_name {</span>
<span class="synPreProc">        my $self = shift;</span>
<span class="synPreProc">        $self-&gt;first_name . ' ' . $self-&gt;last_name</span>
<span class="synPreProc">    }</span>

<span class="synPreProc">    no Moose; # keywords are removed from the Person package</span>

<span class="synStatement">=head1</span><span class="synString"> EXTENDING AND EMBEDDING MOOSE</span>

<span class="synperlPOD">To learn more about extending Moose, we recommend checking out the</span>
<span class="synperlPOD">&quot;Extending&quot; recipes in the </span><span class="synIdentifier">L&lt;Moose::Cookbook&gt;</span><span class="synperlPOD">, starting with</span>
<span class="synIdentifier">L&lt;Moose::Cookbook::Extending::ExtensionOverview&gt;</span><span class="synperlPOD">, which provides an overview of</span>
<span class="synperlPOD">all the different ways you might extend Moose. </span><span class="synIdentifier">L&lt;Moose::Exporter&gt;</span><span class="synperlPOD"> and</span>
<span class="synIdentifier">L&lt;Moose::Util::MetaRole&gt;</span><span class="synperlPOD"> are the modules which provide the majority of the</span>
<span class="synperlPOD">extension functionality, so reading their documentation should also be helpful.</span>

<span class="synStatement">=head2</span><span class="synString"> The MooseX:: namespace</span>

<span class="synperlPOD">Generally if you're writing an extension </span><span class="synIdentifier">I&lt;for&gt;</span><span class="synperlPOD"> Moose itself you'll want</span>
<span class="synperlPOD">to put your extension in the </span><span class="synIdentifier">C&lt;MooseX::&gt;</span><span class="synperlPOD"> namespace. This namespace is</span>
<span class="synperlPOD">specifically for extensions that make Moose better or different in some</span>
<span class="synperlPOD">fundamental way. It is traditionally </span><span class="synIdentifier">B&lt;not&gt;</span><span class="synperlPOD"> for a package that just happens</span>
<span class="synperlPOD">to use Moose. This namespace follows from the examples of the </span><span class="synIdentifier">C&lt;LWPx::&gt;</span>
<span class="synperlPOD">and </span><span class="synIdentifier">C&lt;DBIx::&gt;</span><span class="synperlPOD"> namespaces that perform the same function for </span><span class="synIdentifier">C&lt;LWP&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;DBI&gt;</span>
<span class="synperlPOD">respectively.</span>

<span class="synStatement">=head1</span><span class="synString"> METACLASS COMPATIBILITY AND MOOSE</span>

<span class="synperlPOD">Metaclass compatibility is a thorny subject. You should start by</span>
<span class="synperlPOD">reading the &quot;About Metaclass compatibility&quot; section in the</span>
<span class="synIdentifier">C&lt;Class::MOP&gt;</span><span class="synperlPOD"> docs.</span>

<span class="synperlPOD">Moose will attempt to resolve a few cases of metaclass incompatibility</span>
<span class="synperlPOD">when you set the superclasses for a class, in addition to the cases that</span>
<span class="synIdentifier">C&lt;Class::MOP&gt;</span><span class="synperlPOD"> handles.</span>

<span class="synperlPOD">Moose tries to determine if the metaclasses only &quot;differ by roles&quot;. This</span>
<span class="synperlPOD">means that the parent and child's metaclass share a common ancestor in</span>
<span class="synperlPOD">their respective hierarchies, and that the subclasses under the common</span>
<span class="synperlPOD">ancestor are only different because of role applications. This case is</span>
<span class="synperlPOD">actually fairly common when you mix and match various </span><span class="synIdentifier">C&lt;MooseX::*&gt;</span>
<span class="synperlPOD">modules, many of which apply roles to the metaclass.</span>

<span class="synperlPOD">If the parent and child do differ by roles, Moose replaces the</span>
<span class="synperlPOD">metaclass in the child with a newly created metaclass. This metaclass</span>
<span class="synperlPOD">is a subclass of the parent's metaclass which does all of the roles that</span>
<span class="synperlPOD">the child's metaclass did before being replaced. Effectively, this</span>
<span class="synperlPOD">means the new metaclass does all of the roles done by both the</span>
<span class="synperlPOD">parent's and child's original metaclasses.</span>

<span class="synperlPOD">Ultimately, this is all transparent to you except in the case of an</span>
<span class="synperlPOD">unresolvable conflict.</span>

<span class="synStatement">=head1</span><span class="synString"> CAVEATS</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> *</span>

<span class="synperlPOD">It should be noted that </span><span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD"> </span><span class="synIdentifier">B&lt;cannot&gt;</span><span class="synperlPOD"> be used in the same</span>
<span class="synperlPOD">method. However, they may be combined within the same class hierarchy; see</span>
<span class="synIdentifier">F&lt;t/basics/override_augment_inner_super.t&gt;</span><span class="synperlPOD"> for an example.</span>

<span class="synperlPOD">The reason for this is that </span><span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD"> is only valid within a method</span>
<span class="synperlPOD">with the </span><span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> modifier, and </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD"> will never be valid within an</span>
<span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> method. In fact, </span><span class="synIdentifier">C&lt;augment&gt;</span><span class="synperlPOD"> will skip over any </span><span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> methods</span>
<span class="synperlPOD">when searching for its appropriate </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">This might seem like a restriction, but I am of the opinion that keeping these</span>
<span class="synperlPOD">two features separate (yet interoperable) actually makes them easy to use, since</span>
<span class="synperlPOD">their behavior is then easier to predict. Time will tell whether I am right or</span>
<span class="synperlPOD">not (UPDATE: so far so good).</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> GETTING HELP</span>

<span class="synperlPOD">We offer both a mailing list and a very active IRC channel.</span>

<span class="synperlPOD">The mailing list is </span><span class="synIdentifier">L&lt;mailto:moose@perl.org&gt;</span><span class="synperlPOD">. You must be subscribed to send</span>
<span class="synperlPOD">a message. To subscribe, send an empty message to</span>
<span class="synIdentifier">L&lt;mailto:moose-subscribe@perl.org&gt;</span>

<span class="synperlPOD">You can also visit us at </span><span class="synIdentifier">C&lt;#moose&gt;</span><span class="synperlPOD"> on </span><span class="synIdentifier">L&lt;irc://irc.perl.org/#moose&gt;</span>
<span class="synperlPOD">This channel is quite active, and questions at all levels (on Moose-related</span>
<span class="synperlPOD">topics ;) are welcome.</span>

<span class="synStatement">=head1</span><span class="synString"> WHAT DOES MOOSE STAND FOR?</span>

<span class="synperlPOD">Moose doesn't stand for one thing in particular, however, if you want, here</span>
<span class="synperlPOD">are a few of our favorites. Feel free to contribute more!</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> * Make Other Object Systems Envious</span>

<span class="synStatement">=item</span><span class="synString"> * Makes Object Orientation So Easy</span>

<span class="synStatement">=item</span><span class="synString"> * Makes Object Orientation Spiffy- Er (sorry ingy)</span>

<span class="synStatement">=item</span><span class="synString"> * Most Other Object Systems Emasculate</span>

<span class="synStatement">=item</span><span class="synString"> * Moose Often Ovulate Sorta Early</span>

<span class="synStatement">=item</span><span class="synString"> * Moose Offers Often Super Extensions</span>

<span class="synStatement">=item</span><span class="synString"> * Meta Object Obligates Salivary Excitation</span>

<span class="synStatement">=item</span><span class="synString"> * Meta Object Orientation Syntax Extensions</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> ACKNOWLEDGEMENTS</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> I blame Sam Vilain for introducing me to the insanity that is meta-models.</span>

<span class="synStatement">=item</span><span class="synString"> I blame Audrey Tang for then encouraging my meta-model habit in #perl6.</span>

<span class="synStatement">=item</span><span class="synString"> Without Yuval &quot;nothingmuch&quot; Kogman this module would not be possible,</span>
<span class="synperlPOD">and it certainly wouldn't have this name ;P</span>

<span class="synStatement">=item</span><span class="synString"> The basis of the TypeContraints module was Rob Kinyon's idea</span>
<span class="synperlPOD">originally, I just ran with it.</span>

<span class="synStatement">=item</span><span class="synString"> Thanks to mst &amp; chansen and the whole #moose posse for all the</span>
<span class="synperlPOD">early ideas/feature-requests/encouragement/bug-finding.</span>

<span class="synStatement">=item</span><span class="synString"> Thanks to David &quot;Theory&quot; Wheeler for meta-discussions and spelling fixes.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> SEE ALSO</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">L&lt;http://www.iinteractive.com/moose&gt;</span>

<span class="synperlPOD">This is the official web home of Moose. It contains links to our public git</span>
<span class="synperlPOD">repository, as well as links to a number of talks and articles on Moose and</span>
<span class="synperlPOD">Moose related technologies.</span>

<span class="synStatement">=item</span><span class="synString"> the </span><span class="synIdentifier">L&lt;Moose manual|Moose::Manual&gt;</span>

<span class="synperlPOD">This is an introduction to Moose which covers most of the basics.</span>

<span class="synStatement">=item</span><span class="synString"> Modern Perl, by chromatic</span>

<span class="synperlPOD">This is an introduction to modern Perl programming, which includes a section on</span>
<span class="synperlPOD">Moose. It is available in print and as a free download from</span>
<span class="synIdentifier">L&lt;http://onyxneon.com/books/modern_perl/&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=item</span><span class="synString"> The Moose is flying, a tutorial by Randal Schwartz</span>

<span class="synperlPOD">Part 1 - </span><span class="synIdentifier">L&lt;http://www.stonehenge.com/merlyn/LinuxMag/col94.html&gt;</span>

<span class="synperlPOD">Part 2 - </span><span class="synIdentifier">L&lt;http://www.stonehenge.com/merlyn/LinuxMag/col95.html&gt;</span>

<span class="synStatement">=item</span><span class="synString"> Several Moose extension modules in the </span><span class="synIdentifier">C&lt;MooseX::&gt;</span><span class="synString"> namespace.</span>

<span class="synperlPOD">See </span><span class="synIdentifier">L&lt;http://search.cpan.org/search?query=MooseX::&gt;</span><span class="synperlPOD"> for extensions.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Books</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> The Art of the MetaObject Protocol</span>

<span class="synperlPOD">I mention this in the </span><span class="synIdentifier">L&lt;Class::MOP&gt;</span><span class="synperlPOD"> docs too, as this book was critical in</span>
<span class="synperlPOD">the development of both modules and is highly recommended.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head2</span><span class="synString"> Papers</span>

<span class="synStatement">=over</span><span class="synperlPOD"> </span><span class="synNumber">4</span>

<span class="synStatement">=item</span><span class="synString"> </span><span class="synIdentifier">L&lt;http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf&gt;</span>

<span class="synperlPOD">This paper (suggested by lbr on #moose) was what lead to the implementation</span>
<span class="synperlPOD">of the </span><span class="synIdentifier">C&lt;super&gt;</span><span class="synperlPOD">/</span><span class="synIdentifier">C&lt;override&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">C&lt;inner&gt;</span><span class="synperlPOD">/</span><span class="synIdentifier">C&lt;augment&gt;</span><span class="synperlPOD"> features. If you really</span>
<span class="synperlPOD">want to understand them, I suggest you read this.</span>

<span class="synStatement">=back</span>

<span class="synStatement">=head1</span><span class="synString"> BUGS</span>

<span class="synperlPOD">All complex software has bugs lurking in it, and this module is no</span>
<span class="synperlPOD">exception.</span>

<span class="synperlPOD">Please report any bugs to </span><span class="synIdentifier">C&lt;bug-moose@rt.cpan.org&gt;</span><span class="synperlPOD">, or through the web</span>
<span class="synperlPOD">interface at </span><span class="synIdentifier">L&lt;http://rt.cpan.org&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">You can also discuss feature requests or possible bugs on the Moose mailing</span>
<span class="synperlPOD">list (moose</span><span class="synIdentifier">@perl</span><span class="synperlPOD">.org) or on IRC at </span><span class="synIdentifier">L&lt;irc://irc.perl.org/#moose&gt;</span><span class="synperlPOD">.</span>

<span class="synStatement">=head1</span><span class="synString"> FEATURE REQUESTS</span>

<span class="synperlPOD">We are very strict about what features we add to the Moose core, especially</span>
<span class="synperlPOD">the user-visible features. Instead we have made sure that the underlying</span>
<span class="synperlPOD">meta-system of Moose is as extensible as possible so that you can add your</span>
<span class="synperlPOD">own features easily.</span>

<span class="synperlPOD">That said, occasionally there is a feature needed in the meta-system</span>
<span class="synperlPOD">to support your planned extension, in which case you should either</span>
<span class="synperlPOD">email the mailing list (moose</span><span class="synIdentifier">@perl</span><span class="synperlPOD">.org) or join us on IRC at</span>
<span class="synIdentifier">L&lt;irc://irc.perl.org/#moose&gt;</span><span class="synperlPOD"> to discuss. The</span>
<span class="synIdentifier">L&lt;Moose::Manual::Contributing&gt;</span><span class="synperlPOD"> has more detail about how and when you</span>
<span class="synperlPOD">can contribute.</span>

<span class="synStatement">=head1</span><span class="synString"> CABAL</span>

<span class="synperlPOD">There are only a few people with the rights to release a new version</span>
<span class="synperlPOD">of Moose. The Moose Cabal are the people to go to with questions regarding</span>
<span class="synperlPOD">the wider purview of Moose. They help maintain not just the code</span>
<span class="synperlPOD">but the community as well.</span>

<span class="synperlPOD">Stevan (stevan) Little </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">stevan</span><span class="synIdentifier">@iinteractive</span><span class="synperlPOD">.com</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synperlPOD">Jesse (doy) Luehrs </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">doy at tozt dot net</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synperlPOD">Yuval (nothingmuch) Kogman</span>

<span class="synperlPOD">Shawn (sartak) Moore </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">sartak</span><span class="synIdentifier">@bestpractical</span><span class="synperlPOD">.com</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synperlPOD">Hans Dieter (confound) Pearcey </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">hdp</span><span class="synIdentifier">@pobox</span><span class="synperlPOD">.com</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synperlPOD">Chris (perigrin) Prather</span>

<span class="synperlPOD">Florian Ragwitz </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">rafl</span><span class="synIdentifier">@debian</span><span class="synperlPOD">.org</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synperlPOD">Dave (autarch) Rolsky </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">autarch</span><span class="synIdentifier">@urth</span><span class="synperlPOD">.org</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synperlPOD">Karen (ether) Etheridge </span><span class="synIdentifier">E&lt;</span><span class="synString">lt</span><span class="synIdentifier">&gt;</span><span class="synperlPOD">ether</span><span class="synIdentifier">@cpan</span><span class="synperlPOD">.org</span><span class="synIdentifier">E&lt;</span><span class="synString">gt</span><span class="synIdentifier">&gt;</span>

<span class="synStatement">=head1</span><span class="synString"> CONTRIBUTORS</span>

<span class="synperlPOD">Moose is a community project, and as such, involves the work of many, many</span>
<span class="synperlPOD">members of the community beyond just the members in the cabal. In particular:</span>

<span class="synperlPOD">Dave (autarch) Rolsky wrote most of the documentation in </span><span class="synIdentifier">L&lt;Moose::Manual&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">John (jgoulah) Goulah wrote </span><span class="synIdentifier">L&lt;Moose::Cookbook::Snack::Keywords&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Jess (castaway) Robinson wrote </span><span class="synIdentifier">L&lt;Moose::Cookbook::Snack::Types&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Aran (bluefeet) Clary Deltac wrote</span>
<span class="synIdentifier">L&lt;Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Anders (Debolaz) Nor Berle contributed </span><span class="synIdentifier">L&lt;Test::Moose&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">L&lt;Moose::Util&gt;</span><span class="synperlPOD">.</span>

<span class="synperlPOD">Also, the code in </span><span class="synIdentifier">L&lt;Moose::Meta::Attribute::Native&gt;</span><span class="synperlPOD"> is based on code from the</span>
<span class="synIdentifier">L&lt;MooseX::AttributeHelpers&gt;</span><span class="synperlPOD"> distribution, which had contributions from:</span>

<span class="synperlPOD">Chris (perigrin) Prather</span>

<span class="synperlPOD">Cory (gphat) Watson</span>

<span class="synperlPOD">Evan Carroll</span>

<span class="synperlPOD">Florian (rafl) Ragwitz</span>

<span class="synperlPOD">Jason May</span>

<span class="synperlPOD">Jay Hannah</span>

<span class="synperlPOD">Jesse (doy) Luehrs</span>

<span class="synperlPOD">Paul (frodwith) Driver</span>

<span class="synperlPOD">Robert (rlb3) Boone</span>

<span class="synperlPOD">Robert Buels</span>

<span class="synperlPOD">Robert (phaylon) Sedlacek</span>

<span class="synperlPOD">Shawn (Sartak) Moore</span>

<span class="synperlPOD">Stevan Little</span>

<span class="synperlPOD">Tom (dec) Lanyon</span>

<span class="synperlPOD">Yuval Kogman</span>

<span class="synperlPOD">Finally, these people also contributed various tests, bug fixes,</span>
<span class="synperlPOD">documentation, and features to the Moose codebase:</span>

<span class="synperlPOD">Aankhen</span>

<span class="synperlPOD">Adam (Alias) Kennedy</span>

<span class="synperlPOD">Christian (chansen) Hansen</span>

<span class="synperlPOD">Cory (gphat) Watson</span>

<span class="synperlPOD">Dylan Hardison (doc fixes)</span>

<span class="synperlPOD">Eric (ewilhelm) Wilhelm</span>

<span class="synperlPOD">Evan Carroll</span>

<span class="synperlPOD">Guillermo (groditi) Roditi</span>

<span class="synperlPOD">Jason May</span>

<span class="synperlPOD">Jay Hannah</span>

<span class="synperlPOD">Jonathan (jrockway) Rockway</span>

<span class="synperlPOD">Matt (mst) Trout</span>

<span class="synperlPOD">Nathan (kolibrie) Gray</span>

<span class="synperlPOD">Paul (frodwith) Driver</span>

<span class="synperlPOD">Piotr (dexter) Roszatycki</span>

<span class="synperlPOD">Robert Buels</span>

<span class="synperlPOD">Robert (phaylon) Sedlacek</span>

<span class="synperlPOD">Robert (rlb3) Boone</span>

<span class="synperlPOD">Sam (mugwump) Vilain</span>

<span class="synperlPOD">Scott (konobi) McWhirter</span>

<span class="synperlPOD">Shlomi (rindolf) Fish</span>

<span class="synperlPOD">Tom (dec) Lanyon</span>

<span class="synperlPOD">Wallace (wreis) Reis</span>

<span class="synperlPOD">... and many other #moose folks</span>

<span class="synStatement">=head1</span><span class="synString"> AUTHOR</span>

<span class="synperlPOD">Moose is maintained by the Moose Cabal, along with the help of many contributors. See </span><span class="synIdentifier">L&lt;Moose/CABAL&gt;</span><span class="synperlPOD"> and </span><span class="synIdentifier">L&lt;Moose/CONTRIBUTORS&gt;</span><span class="synperlPOD"> for details.</span>

<span class="synStatement">=head1</span><span class="synString"> COPYRIGHT AND LICENSE</span>

<span class="synperlPOD">This software is copyright (c) 2013 by Infinity Interactive, Inc..</span>

<span class="synperlPOD">This is free software; you can redistribute it and/or modify it under</span>
<span class="synperlPOD">the same terms as the Perl 5 programming language system itself.</span>

<span class="synStatement">=cut</span>
</pre>

 </body>
</html>
